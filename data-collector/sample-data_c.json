[
    {
        "question_id": 1642028,
        "question_code": "comp.lang.c++.moderated\n#include &lt;stdio.h&gt;\nint main()\n{\n    int x = 10;\n    while (x --&gt; 0) // x goes to 0\n    {\n        printf(&quot;%d &quot;, x);\n    }\n}\n\n9 8 7 6 5 4 3 2 1 0\n",
        "answer_code_snippets": [
            "--&gt;\n--\n&gt;\nx\nx\n0\n&gt;\nwhile( (x--) &gt; 0 )\n",
            "x\n0\nwhile (x --\\\n            \\\n             \\\n              \\\n               &gt; 0)\n     printf(\"%d \", x);\n",
            "--\n&gt;",
            "x\nint x = 10;\n\nwhile( 0 &lt;---- x )\n{\n   printf(&quot;%d &quot;, x);\n}\n\n8 6 4 2 \nint x = 100;\n\nwhile( 0 &lt;-------------------- x )\n{\n   printf(&quot;%d &quot;, x);\n}\n\n90 80 70 60 50 40 30 20 10 ",
            "while (x-- &gt; 0)\n\nx--\nx = x-1\nx\nwhile(x &gt; 0) {\n    x = x-1;\n    // logic\n}\nx--;   // The post decrement done when x &lt;= 0\n",
            "#include &lt;stdio.h&gt;\n\nint main(void) {\n    int x = 10;\n    while (x-- &gt; 0) { // x goes to 0\n        printf(&quot;%d &quot;, x);\n    }\n    return 0;\n}\n\n--\n&gt;",
            "--&gt;\n--&gt;\nx\n0",
            "#define as ;while\n\nint main(int argc, char* argv[])\n{\n    int n = atoi(argv[1]);\n    do printf(\"n is %d\\n\", n) as ( n --&gt; 0);\n    return 0;\n}\n",
            "x--&gt;0\n\ntoken 1: x\ntoken 2: --\ntoken 3: &gt;\ntoken 4: 0\nconclude: x-- &gt; 0\n\na-----b\n\ntoken 1: a\ntoken 2: --\ntoken 3: --\ntoken 4: -\ntoken 5: b\nconclude: (a--)-- - b\n",
            "while(x--)",
            "\"--&gt;\"\n\"for (x = 10; x &gt; 0; x --)\"",
            "&gt;\n9 8 7 6 5 4 3 2 1 0\n\n#include &lt;stdio.h&gt;\nint main(void)\n{\n    int x = 10;\n\n    while( --x&gt; 0 ) // x goes to 0\n    {\n        printf(\"%d \", x);\n    }\n    return 0;\n}\n\n9 8 7 6 5 4 3 2 1\n",
            "#include &lt;iostream&gt;\nint main()\n{\n    int x = 10;\n\n    while( x --&gt; 0 ) // x goes to 0\n    {\n        std::cout &lt;&lt; x;\n    }\n}\n\nwhile( x-- &gt; 0 )\nwhile( x &gt; 0)\nx--\nx\nwhile( x &gt; 0 ) \n{\n    x--;\n    std::cout &lt;&lt; x;\n}\n",
            "--\n&gt;\nx\nx&gt;0 ?",
            "--\n&gt;\n--&gt;",
            "--\n&gt;\n#include&lt;stdio.h&gt;\n\nint main()\n{\n    int x = 10;\n\n    while (x-- &gt; 0)\n        printf(&quot;%d &quot;,x);\n\n    return 0;\n}\n\n9 8 7 6 5 4 3 2 1 0            \n",
            "a---b\n(a--) - b\nx--&gt;0\n(x--)&gt;0",
            "x\n--&gt;\n(x--) &gt; 0\nx\n--&gt;    x--&gt;0\n++&gt;    x++&gt;0\n--&gt;=   x--&gt;=0\n++&gt;=   x++&gt;=0\n",
            "int x = 10;\nwhile( --x&gt; 0 )\n    printf(&quot;%d &quot;, x);\n",
            "#include &lt;stdio.h&gt;\n\nint main() {\n    int x = 10;\n    while (x &gt; 0) {\n        printf(&quot;%d &quot;, x);\n        x = x - 1;\n    }\n}\n\nx--\n&gt;\noperator",
            "()\n{}\n--\n&gt;\nint abc(){\n    int a = 5\n    while((a--) &gt; 0){ // Decrement and comparison both at once\n        // Code\n    }\n}\n\na\na\n0\nint abc() {\n    int a = 5;\n    while(a &gt; 0) {\n        a = a -1 // Decrement inside loop\n        // Code\n    }\n}\n",
            "(x --&gt; 0)\n(x-- &gt; 0)\n(x --&gt;)\nOutput: 9 8 7 6 5 4 3 2 1 0\n(-- x &gt; 0)\n(--x &gt; 0)\nOutput: 9 8 7 6 5 4 3 2 1\n(--\\\n    \\\n     x &gt; 0)\n\nOutput:  9 8 7 6 5 4 3 2 1\n(\\\n  \\\n   x --&gt; 0)\n\nOutput: 9 8 7 6 5 4 3 2 1 0\n(\\\n  \\\n   x --&gt; 0\n          \\\n           \\\n            )\n\nOutput: 9 8 7 6 5 4 3 2 1 0\n(\n x \n  --&gt; \n      0\n       )\n\nOutput: 9 8 7 6 5 4 3 2 1 0",
            "--&gt;\n--\n&gt;\n#include &lt;stdio.h&gt;\nint main() {\n    int x = 10;\n    while (x-- &gt; 0) { // x goes to 0\n        printf(&quot;%d &quot;, x);\n    }\n}\n\n10\n0\n10\n0\nx\nx\n-1\nx\nsize_t\nfor (i = length-1; i &gt;= 0; i--)\nwhile (x --&gt; 0)\nfor (;;)\nwhile (1)\nwhile (l)",
            "--&gt;\n-&gt;\n--&gt;\nwhile(x-- &gt;0)\nwhile(x--)\n0",
            "--\n while (x-- &gt; 0) // x goes to 0\n {\n     printf(&quot;%d &quot;, x);\n }\n\n(x &gt; 0) // 10 &gt; 0\nx-- // x = 9\nx=1\nx = 0\nx = 0\n(x &gt; 0 )",
            "while((x--) &gt; 0)\n"
        ]
    },
    {
        "question_id": 1711631,
        "question_code": "/*************************************************************\n    Baseline code to experiment with SQLite performance.\n\n    Input data is a 28 MB TAB-delimited text file of the\n    complete Toronto Transit System schedule/route info\n    from http://www.toronto.ca/open/datasets/ttc-routes/\n\n**************************************************************/\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;time.h&gt;\n#include &lt;string.h&gt;\n#include &quot;sqlite3.h&quot;\n\n#define INPUTDATA &quot;C:\\\\TTC_schedule_scheduleitem_10-27-2009.txt&quot;\n#define DATABASE &quot;c:\\\\TTC_schedule_scheduleitem_10-27-2009.sqlite&quot;\n#define TABLE &quot;CREATE TABLE IF NOT EXISTS TTC (id INTEGER PRIMARY KEY, Route_ID TEXT, Branch_Code TEXT, Version INTEGER, Stop INTEGER, Vehicle_Index INTEGER, Day Integer, Time TEXT)&quot;\n#define BUFFER_SIZE 256\n\nint main(int argc, char **argv) {\n\n    sqlite3 * db;\n    sqlite3_stmt * stmt;\n    char * sErrMsg = 0;\n    char * tail = 0;\n    int nRetCode;\n    int n = 0;\n\n    clock_t cStartClock;\n\n    FILE * pFile;\n    char sInputBuf [BUFFER_SIZE] = &quot;\\0&quot;;\n\n    char * sRT = 0;  /* Route */\n    char * sBR = 0;  /* Branch */\n    char * sVR = 0;  /* Version */\n    char * sST = 0;  /* Stop Number */\n    char * sVI = 0;  /* Vehicle */\n    char * sDT = 0;  /* Date */\n    char * sTM = 0;  /* Time */\n\n    char sSQL [BUFFER_SIZE] = &quot;\\0&quot;;\n\n    /*********************************************/\n    /* Open the Database and create the Schema */\n    sqlite3_open(DATABASE, &amp;db);\n    sqlite3_exec(db, TABLE, NULL, NULL, &amp;sErrMsg);\n\n    /*********************************************/\n    /* Open input file and import into Database*/\n    cStartClock = clock();\n\n    pFile = fopen (INPUTDATA,&quot;r&quot;);\n    while (!feof(pFile)) {\n\n        fgets (sInputBuf, BUFFER_SIZE, pFile);\n\n        sRT = strtok (sInputBuf, &quot;\\t&quot;);     /* Get Route */\n        sBR = strtok (NULL, &quot;\\t&quot;);            /* Get Branch */\n        sVR = strtok (NULL, &quot;\\t&quot;);            /* Get Version */\n        sST = strtok (NULL, &quot;\\t&quot;);            /* Get Stop Number */\n        sVI = strtok (NULL, &quot;\\t&quot;);            /* Get Vehicle */\n        sDT = strtok (NULL, &quot;\\t&quot;);            /* Get Date */\n        sTM = strtok (NULL, &quot;\\t&quot;);            /* Get Time */\n\n        /* ACTUAL INSERT WILL GO HERE */\n\n        n++;\n    }\n    fclose (pFile);\n\n    printf(&quot;Imported %d records in %4.2f seconds\\n&quot;, n, (clock() - cStartClock) / (double)CLOCKS_PER_SEC);\n\n    sqlite3_close(db);\n    return 0;\n}\n\nsprintf(sSQL, &quot;INSERT INTO TTC VALUES (NULL, '%s', '%s', '%s', '%s', '%s', '%s', '%s')&quot;, sRT, sBR, sVR, sST, sVI, sDT, sTM);\nsqlite3_exec(db, sSQL, NULL, NULL, &amp;sErrMsg);\n\nsqlite3_exec(db, &quot;BEGIN TRANSACTION&quot;, NULL, NULL, &amp;sErrMsg);\n\npFile = fopen (INPUTDATA,&quot;r&quot;);\nwhile (!feof(pFile)) {\n\n    ...\n\n}\nfclose (pFile);\n\nsqlite3_exec(db, &quot;END TRANSACTION&quot;, NULL, NULL, &amp;sErrMsg);\n\nsqlite3_prepare_v2\nsqlite3_bind_text\n/* Open input file and import into the database */\ncStartClock = clock();\n\nsprintf(sSQL, &quot;INSERT INTO TTC VALUES (NULL, @RT, @BR, @VR, @ST, @VI, @DT, @TM)&quot;);\nsqlite3_prepare_v2(db,  sSQL, BUFFER_SIZE, &amp;stmt, &amp;tail);\n\nsqlite3_exec(db, &quot;BEGIN TRANSACTION&quot;, NULL, NULL, &amp;sErrMsg);\n\npFile = fopen (INPUTDATA,&quot;r&quot;);\nwhile (!feof(pFile)) {\n\n    fgets (sInputBuf, BUFFER_SIZE, pFile);\n\n    sRT = strtok (sInputBuf, &quot;\\t&quot;);   /* Get Route */\n    sBR = strtok (NULL, &quot;\\t&quot;);        /* Get Branch */\n    sVR = strtok (NULL, &quot;\\t&quot;);        /* Get Version */\n    sST = strtok (NULL, &quot;\\t&quot;);        /* Get Stop Number */\n    sVI = strtok (NULL, &quot;\\t&quot;);        /* Get Vehicle */\n    sDT = strtok (NULL, &quot;\\t&quot;);        /* Get Date */\n    sTM = strtok (NULL, &quot;\\t&quot;);        /* Get Time */\n\n    sqlite3_bind_text(stmt, 1, sRT, -1, SQLITE_TRANSIENT);\n    sqlite3_bind_text(stmt, 2, sBR, -1, SQLITE_TRANSIENT);\n    sqlite3_bind_text(stmt, 3, sVR, -1, SQLITE_TRANSIENT);\n    sqlite3_bind_text(stmt, 4, sST, -1, SQLITE_TRANSIENT);\n    sqlite3_bind_text(stmt, 5, sVI, -1, SQLITE_TRANSIENT);\n    sqlite3_bind_text(stmt, 6, sDT, -1, SQLITE_TRANSIENT);\n    sqlite3_bind_text(stmt, 7, sTM, -1, SQLITE_TRANSIENT);\n\n    sqlite3_step(stmt);\n\n    sqlite3_clear_bindings(stmt);\n    sqlite3_reset(stmt);\n\n    n++;\n}\nfclose (pFile);\n\nsqlite3_exec(db, &quot;END TRANSACTION&quot;, NULL, NULL, &amp;sErrMsg);\n\nprintf(&quot;Imported %d records in %4.2f seconds\\n&quot;, n, (clock() - cStartClock) / (double)CLOCKS_PER_SEC);\n\nsqlite3_finalize(stmt);\nsqlite3_close(db);\n\nreturn 0;\n\nsqlite3_clear_bindings\nsqlite3_reset\nsynchronous = OFF\n/* Open the database and create the schema */\nsqlite3_open(DATABASE, &amp;db);\nsqlite3_exec(db, TABLE, NULL, NULL, &amp;sErrMsg);\nsqlite3_exec(db, &quot;PRAGMA synchronous = OFF&quot;, NULL, NULL, &amp;sErrMsg);\n\nPRAGMA journal_mode = MEMORY\n/* Open the database and create the schema */\nsqlite3_open(DATABASE, &amp;db);\nsqlite3_exec(db, TABLE, NULL, NULL, &amp;sErrMsg);\nsqlite3_exec(db, &quot;PRAGMA journal_mode = MEMORY&quot;, NULL, NULL, &amp;sErrMsg);\n\n/* Open the database and create the schema */\nsqlite3_open(DATABASE, &amp;db);\nsqlite3_exec(db, TABLE, NULL, NULL, &amp;sErrMsg);\nsqlite3_exec(db, &quot;PRAGMA synchronous = OFF&quot;, NULL, NULL, &amp;sErrMsg);\nsqlite3_exec(db, &quot;PRAGMA journal_mode = MEMORY&quot;, NULL, NULL, &amp;sErrMsg);\n\n#define DATABASE &quot;:memory:&quot;\n\nchar*\nwhile\nstrtok()\nsqlite3_bind_text()\npFile = fopen (INPUTDATA,&quot;r&quot;);\nwhile (!feof(pFile)) {\n\n    fgets (sInputBuf, BUFFER_SIZE, pFile);\n\n    sqlite3_bind_text(stmt, 1, strtok (sInputBuf, &quot;\\t&quot;), -1, SQLITE_TRANSIENT); /* Get Route */\n    sqlite3_bind_text(stmt, 2, strtok (NULL, &quot;\\t&quot;), -1, SQLITE_TRANSIENT);    /* Get Branch */\n    sqlite3_bind_text(stmt, 3, strtok (NULL, &quot;\\t&quot;), -1, SQLITE_TRANSIENT);    /* Get Version */\n    sqlite3_bind_text(stmt, 4, strtok (NULL, &quot;\\t&quot;), -1, SQLITE_TRANSIENT);    /* Get Stop Number */\n    sqlite3_bind_text(stmt, 5, strtok (NULL, &quot;\\t&quot;), -1, SQLITE_TRANSIENT);    /* Get Vehicle */\n    sqlite3_bind_text(stmt, 6, strtok (NULL, &quot;\\t&quot;), -1, SQLITE_TRANSIENT);    /* Get Date */\n    sqlite3_bind_text(stmt, 7, strtok (NULL, &quot;\\t&quot;), -1, SQLITE_TRANSIENT);    /* Get Time */\n\n    sqlite3_step(stmt);        /* Execute the SQL Statement */\n    sqlite3_clear_bindings(stmt);    /* Clear bindings */\n    sqlite3_reset(stmt);        /* Reset VDBE */\n\n    n++;\n}\nfclose (pFile);\n\nSELECT\nsqlite3_exec(db, &quot;CREATE  INDEX 'TTC_Stop_Index' ON 'TTC' ('Stop')&quot;, NULL, NULL, &amp;sErrMsg);\nsqlite3_exec(db, &quot;BEGIN TRANSACTION&quot;, NULL, NULL, &amp;sErrMsg);\n...\n\n...\nsqlite3_exec(db, &quot;END TRANSACTION&quot;, NULL, NULL, &amp;sErrMsg);\nsqlite3_exec(db, &quot;CREATE  INDEX 'TTC_Stop_Index' ON 'TTC' ('Stop')&quot;, NULL, NULL, &amp;sErrMsg);\n",
        "answer_code_snippets": [
            "pragma journal_mode\nNORMAL\nOFF\nOFF/MEMORY\nPRAGMA page_size\nCREATE INDEX\nINTEGER PRIMARY KEY\n!feof(file)",
            "SQLITE_STATIC\nSQLITE_TRANSIENT\nSQLITE_TRANSIENT\nSQLITE_STATIC",
            "sqlite3_clear_bindings(stmt)\nsqlite3_clear_bindings",
            "SELECT COUNT(*) FROM table\n\nSELECT * FROM table ORDER BY _ROWID_ LIMIT &lt;limit&gt; OFFSET &lt;offset&gt;\n\n&lt;limit&gt;\n&lt;offset&gt;\nint limit = (count + n_threads - 1)/n_threads;\n\nint offset = thread_index * limit\n",
            "PRAGMA cache_size=10000;",
            "PRAGMA journal_mode = WAL\nINSERT\nPRAGMA auto_vacuum = 0",
            "CREATE TABLE mySEQUENCE (\n    id INTEGER PRIMARY KEY --AUTOINCREMENT\n    ,dummy INT \n);\n\n\nINSERT INTO mySEQUENCE (dummy) VALUES (1);\nSELECT last_insert_rowid(); --&gt; 1\n\nINSERT INTO mySEQUENCE (dummy) VALUES (2);\nSELECT last_insert_rowid(); --&gt; 2\n\nDELETE FROM mySEQUENCE WHERE id &gt; 1;\nSELECT last_insert_rowid(); --&gt; 2\n\nINSERT INTO mySEQUENCE (dummy) VALUES (3);\nSELECT last_insert_rowid(); --&gt; 2\n\nSELECT * FROM mySEQUENCE;\nid  dummy\n1   1\n2   3\n\nDELETE FROM mySEQUENCE; -- clean it\nINSERT INTO mySEQUENCE (dummy) VALUES (4);\nSELECT last_insert_rowid(); --&gt; 1\n\nSELECT * FROM mySEQUENCE;\nid  dummy\n1   4\n",
            "private SQLiteDatabase database;\ndatabase = dbHelper.getWritableDatabase();\n\npublic int bulkInsert(@NonNull Uri uri, @NonNull ContentValues[] values) {\n\ndatabase.beginTransaction();\n\nfor (ContentValues value : values)\n db.insert(\"TABLE_NAME\", null, value);\n\ndatabase.setTransactionSuccessful();\ndatabase.endTransaction();\n\n}\n\nApp.getAppContext().getContentResolver().bulkInsert(contentUriTable,\n            contentValuesArray);\n"
        ]
    },
    {
        "question_id": 47981,
        "question_code": "",
        "answer_code_snippets": [
            "|\nn\nnumber\n1\n// Can be whatever unsigned integer type you want, but\n// it's important to use the same type everywhere to avoid\n// performance issues caused by mixing integer types.\ntypedef unsigned long Uint;\n\n// In C++, this can be template.\n// In C11, you can make it generic with _Generic, or with macros prior to C11.\ninline Uint bit_set(Uint number, Uint n) {\n    return number | ((Uint)1 &lt;&lt; n);\n}\n\nUint\n&amp;\nn\nnumber\n0\ninline Uint bit_clear(Uint number, Uint n) {\n    return number &amp; ~((Uint)1 &lt;&lt; n);\n}\n\n~\n^\nn\nnumber\ninline Uint bit_toggle(Uint number, Uint n) {\n    return number ^ ((Uint)1 &lt;&lt; n);\n}\n\nnumber\nn\n// bool requires #include &lt;stdbool.h&gt; prior to C23\ninline bool bit_check(Uint number, Uint n) {\n    return (number &gt;&gt; n) &amp; (Uint)1;\n}\n\nbit_clear\nbit_set\ninline Uint bit_set_to(Uint number, Uint n, bool x) {\n    return (number &amp; ~((Uint)1 &lt;&lt; n)) | ((Uint)x &lt;&lt; n);\n}\n",
            "std::bitset&lt;N&gt;\nboost::dynamic_bitset\n#include &lt;bitset&gt;\n#include &lt;iostream&gt;\n\nint main()\n{\n    std::bitset&lt;5&gt; x;\n\n    x[1] = 1;\n    x[2] = 0;\n    // Note x[0-4]  valid\n\n    std::cout &lt;&lt; x &lt;&lt; std::endl;\n}\n\n./a.out\n\n00010\n",
            "struct bits {\n    unsigned int a:1;\n    unsigned int b:1;\n    unsigned int c:1;\n};\n\nstruct bits mybits;\n\nmybits.b = 1;\nmybits.c = 0;\n\nmybits.a = !mybits.a;\nmybits.b = ~mybits.b;\nmybits.c ^= 1;  /* all work */\n\nif (mybits.c)  //if mybits.c is non zero the next line below will execute\n",
            "/* a=target variable, b=bit number to act upon 0-n */\n#define BIT_SET(a,b) ((a) |= (1ULL&lt;&lt;(b)))\n#define BIT_CLEAR(a,b) ((a) &amp;= ~(1ULL&lt;&lt;(b)))\n#define BIT_FLIP(a,b) ((a) ^= (1ULL&lt;&lt;(b)))\n#define BIT_CHECK(a,b) (!!((a) &amp; (1ULL&lt;&lt;(b))))        // '!!' to make sure this returns 0 or 1\n\n#define BITMASK_SET(x, mask) ((x) |= (mask))\n#define BITMASK_CLEAR(x, mask) ((x) &amp;= (~(mask)))\n#define BITMASK_FLIP(x, mask) ((x) ^= (mask))\n#define BITMASK_CHECK_ALL(x, mask) (!(~(x) &amp; (mask)))\n#define BITMASK_CHECK_ANY(x, mask) ((x) &amp; (mask))\n",
            "enum\nenum ThingFlags = {\n  ThingMask  = 0x0000,\n  ThingFlag0 = 1 &lt;&lt; 0,\n  ThingFlag1 = 1 &lt;&lt; 1,\n  ThingError = 1 &lt;&lt; 8,\n}\n\nthingstate |= ThingFlag1;\nthingstate &amp;= ~ThingFlag0;\nif (thing &amp; ThingError) {...}\n",
            "/*\n**  Bit set, clear, and test operations\n**\n**  public domain snippet by Bob Stout\n*/\n\ntypedef enum {ERROR = -1, FALSE, TRUE} LOGICAL;\n\n#define BOOL(x) (!(!(x)))\n\n#define BitSet(arg,posn) ((arg) | (1L &lt;&lt; (posn)))\n#define BitClr(arg,posn) ((arg) &amp; ~(1L &lt;&lt; (posn)))\n#define BitTst(arg,posn) BOOL((arg) &amp; (1L &lt;&lt; (posn)))\n#define BitFlp(arg,posn) ((arg) ^ (1L &lt;&lt; (posn)))\n\n0000 0000 0000 0000 0000 0000 0000 0001 binary.\n\n0000 0000 0000 0000 0000 0001 0000 0000 binary.\n\n#define BOOL(x) (!(!(x)))\n\n#define BitSet(arg,posn) ((arg) | (1L &lt;&lt; (posn)))\n#define BitClr(arg,posn) ((arg) &amp; ~(1L &lt;&lt; (posn)))\n#define BitTst(arg,posn) BOOL((arg) &amp; (1L &lt;&lt; (posn)))\n#define BitFlp(arg,posn) ((arg) ^ (1L &lt;&lt; (posn)))\n\nint bitmanip(int word)\n{\n      word = BitSet(word, 2);\n      word = BitSet(word, 7);\n      word = BitClr(word, 3);\n      word = BitFlp(word, 9);\n      return word;\n}\n\n----[ TEST.OUT (disassembled) ]-----------------------------------------------\n\nModule: C:\\BINK\\tst.c\nGroup: 'DGROUP' CONST,CONST2,_DATA,_BSS\n\nSegment: _TEXT  BYTE   00000008 bytes\n 0000  0c 84             bitmanip_       or      al,84H    ; set bits 2 and 7\n 0002  80 f4 02                          xor     ah,02H    ; flip bit 9 of EAX (bit 1 of AH)\n 0005  24 f7                             and     al,0f7H\n 0007  c3                                ret\n\nNo disassembly errors\n\n----[ finis ]-----------------------------------------------------------------\n",
            "value is 0x55;\nbitnum : 3rd.\n\n&amp;\n0101 0101\n&amp;\n0000 1000\n___________\n0000 0000 (mean 0: False). It will work fine if the third bit is 1 (then the answer will be True)\n\n0101 0101\n^\n0000 1000\n___________\n0101 1101 (Flip the third bit without affecting other bits)\n\n|\n0101 0101\n|\n0000 1000\n___________\n0101 1101 (set the third bit without affecting other bits)\n",
            "num = 55\nn = 4\nnth\nnum\nn\n&amp;\nbit = (num &gt;&gt; n) &amp; 1;\n\n       0011 0111 (55 in decimal)\n    &gt;&gt;         4 (right shift 4 times)\n-----------------\n       0000 0011\n     &amp; 0000 0001 (1 in decimal)\n-----------------\n    =&gt; 0000 0001 (final result)\n\nn\n|\nnum\nnum |= 1 &lt;&lt; n;    // Equivalent to num = (1 &lt;&lt; n) | num;\n\n       0000 0001 (1 in decimal)\n    &lt;&lt;         4 (left shift 4 times)\n-----------------\n       0001 0000\n     | 0011 0111 (55 in decimal)\n-----------------\n    =&gt; 0001 0000 (final result)\n\nn\n1 &lt;&lt; n\n~ (1 &lt;&lt; n)\n&amp;\nnum\nnum &amp; (~ (1 &lt;&lt; n))\nnum &amp;= ~(1 &lt;&lt; n);    // Equivalent to num = num &amp; ~(1 &lt;&lt; n);\n\n       0000 0001 (1 in decimal)\n    &lt;&lt;         4 (left shift 4 times)\n-----------------\n     ~ 0001 0000\n-----------------\n       1110 1111\n     &amp; 0011 0111 (55 in decimal)\n-----------------\n    =&gt; 0010 0111 (final result)\n\n^\nnum ^= 1 &lt;&lt; n;    // Equivalent to num = num ^ (1 &lt;&lt; n);\n\n0 ^ 1 =&gt; 1\n1 ^ 1 =&gt; 0\n       0000 0001 (1 in decimal)\n    &lt;&lt;         4 (left shift 4 times)\n-----------------\n       0001 0000\n     ^ 0011 0111 (55 in decimal)\n-----------------\n    =&gt; 0010 0111 (final result)\n",
            "unsigned char\nsize_t\n#define BITOP(a,b,op) \\\n ((a)[(size_t)(b)/(8*sizeof *(a))] op ((size_t)1&lt;&lt;((size_t)(b)%(8*sizeof *(a)))))\n\nBITOP(array, bit, |=);\n\nBITOP(array, bit, &amp;=~);\n\nBITOP(array, bit, ^=);\n\nif (BITOP(array, bit, &amp;)) ...\n",
            "struct HwRegister {\n    unsigned int errorFlag:1;  // one-bit flag field\n    unsigned int Mode:3;       // three-bit mode field\n    unsigned int StatusCode:4;  // four-bit status code\n};\n\nstruct HwRegister CR3342_AReg;\n",
            "#define bit_test(x, y)  ( ( ((const char*)&amp;(x))[(y)&gt;&gt;3] &amp; 0x80 &gt;&gt; ((y)&amp;0x07)) &gt;&gt; (7-((y)&amp;0x07) ) )\n\nint main(void)\n{\n    unsigned char arr[8] = { 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF };\n\n    for (int ix = 0; ix &lt; 64; ++ix)\n        printf(\"bit %d is %d\\n\", ix, bit_test(arr, ix));\n\n    return 0;\n}\n",
            "#define BITS 8\n#define BIT_SET(  p, n) (p[(n)/BITS] |=  (0x80&gt;&gt;((n)%BITS)))\n#define BIT_CLEAR(p, n) (p[(n)/BITS] &amp;= ~(0x80&gt;&gt;((n)%BITS)))\n#define BIT_ISSET(p, n) (p[(n)/BITS] &amp;   (0x80&gt;&gt;((n)%BITS)))\n",
            "{\n    unsigned int data = 0x000000F0;\n    int bitpos = 4;\n    int bitvalue = 1;\n    unsigned int bit = data;\n    bit = (bit&gt;&gt;bitpos)&amp;0x00000001;\n    int invbitvalue = 0x00000001&amp;(~bitvalue);\n    printf(\"%x\\n\",bit);\n\n    if (bitvalue == 0)\n    {\n        if (bit == 0)\n            printf(\"%x\\n\", data);\n        else\n        {\n             data = (data^(invbitvalue&lt;&lt;bitpos));\n             printf(\"%x\\n\", data);\n        }\n    }\n    else\n    {\n        if (bit == 1)\n            printf(\"elseif %x\\n\", data);\n        else\n        {\n            data = (data|(bitvalue&lt;&lt;bitpos));\n            printf(\"else %x\\n\", data);\n        }\n    }\n}\n",
            "const unsigned char TQuickByteMask[8] =\n{\n   0x01, 0x02, 0x04, 0x08,\n   0x10, 0x20, 0x40, 0x80,\n};\n\n\n/** Set bit in any sized bit mask.\n *\n * @return    none\n *\n * @param     bit    - Bit number.\n * @param     bitmap - Pointer to bitmap.\n */\nvoid TSetBit( short bit, unsigned char *bitmap)\n{\n    short n, x;\n\n    x = bit / 8;        // Index to byte.\n    n = bit % 8;        // Specific bit in byte.\n\n    bitmap[x] |= TQuickByteMask[n];        // Set bit.\n}\n\n\n/** Reset bit in any sized mask.\n *\n * @return  None\n *\n * @param   bit    - Bit number.\n * @param   bitmap - Pointer to bitmap.\n */\nvoid TResetBit( short bit, unsigned char *bitmap)\n{\n    short n, x;\n\n    x = bit / 8;        // Index to byte.\n    n = bit % 8;        // Specific bit in byte.\n\n    bitmap[x] &amp;= (~TQuickByteMask[n]);    // Reset bit.\n}\n\n\n/** Toggle bit in any sized bit mask.\n *\n * @return   none\n *\n * @param   bit    - Bit number.\n * @param   bitmap - Pointer to bitmap.\n */\nvoid TToggleBit( short bit, unsigned char *bitmap)\n{\n    short n, x;\n\n    x = bit / 8;        // Index to byte.\n    n = bit % 8;        // Specific bit in byte.\n\n    bitmap[x] ^= TQuickByteMask[n];        // Toggle bit.\n}\n\n\n/** Checks specified bit.\n *\n * @return  1 if bit set else 0.\n *\n * @param   bit    - Bit number.\n * @param   bitmap - Pointer to bitmap.\n */\nshort TIsBitSet( short bit, const unsigned char *bitmap)\n{\n    short n, x;\n\n    x = bit / 8;    // Index to byte.\n    n = bit % 8;    // Specific bit in byte.\n\n    // Test bit (logigal AND).\n    if (bitmap[x] &amp; TQuickByteMask[n])\n        return 1;\n\n    return 0;\n}\n\n\n/** Checks specified bit.\n *\n * @return  1 if bit reset else 0.\n *\n * @param   bit    - Bit number.\n * @param   bitmap - Pointer to bitmap.\n */\nshort TIsBitReset( short bit, const unsigned char *bitmap)\n{\n    return TIsBitSet(bit, bitmap) ^ 1;\n}\n\n\n/** Count number of bits set in a bitmap.\n *\n * @return   Number of bits set.\n *\n * @param    bitmap - Pointer to bitmap.\n * @param    size   - Bitmap size (in bits).\n *\n * @note    Not very efficient in terms of execution speed. If you are doing\n *        some computationally intense stuff you may need a more complex\n *        implementation which would be faster (especially for big bitmaps).\n *        See (http://graphics.stanford.edu/~seander/bithacks.html).\n */\nint TCountBits( const unsigned char *bitmap, int size)\n{\n    int i, count = 0;\n\n    for (i=0; i&lt;size; i++)\n        if (TIsBitSet(i, bitmap))\n            count++;\n\n    return count;\n}\n\nTSetBit( n, &amp;my_int);\n",
            "int ToggleNthBit ( unsigned char n, int num )\n{\n    if(num &amp; (1 &lt;&lt; n))\n        num &amp;= ~(1 &lt;&lt; n);\n    else\n        num |= (1 &lt;&lt; n);\n\n    return num;\n}\n",
            "set_bit  Atomically set a bit in memory\nclear_bit  Clears a bit in memory\nchange_bit  Toggle a bit in memory\ntest_and_set_bit  Set a bit and return its old value\ntest_and_clear_bit  Clear a bit and return its old value\ntest_and_change_bit  Change a bit and return its old value\ntest_bit  Determine whether a bit is set\n",
            "sizeof()\nbool IsGph[256], IsNotGph[256];\n\n// Initialize boolean array to detect printable characters\nfor(i=0; i&lt;sizeof(IsGph); i++) {\n    IsGph[i] = isgraph((unsigned char)i);\n}\n\nIsGph[i] =1\nIsGph[i] =0\n// Initialize boolean array to detect UN-printable characters,\n// then call function to toggle required bits true, while initializing a 2nd\n// boolean array as the complement of the 1st.\nfor(i=0; i&lt;sizeof(IsGph); i++) {\n    if(IsGph[i]) {\n        IsNotGph[i] = 0;\n    } \n    else {\n        IsNotGph[i] = 1;\n    }\n}\n",
            "bitset\n#include &lt;iostream&gt;\n#include &lt;bitset&gt;\n#include &lt;string&gt;\n\nusing namespace std;\nint main() {\n  bitset&lt;8&gt; byte(std::string(\"10010011\");\n\n  // Set Bit\n  byte.set(3); // 10010111\n\n  // Clear Bit\n  byte.reset(2); // 10010101\n\n  // Toggle Bit\n  byte.flip(7); // 00010101\n\n  cout &lt;&lt; byte &lt;&lt; endl;\n\n  return 0;\n}\n",
            "int set_nth_bit(int num, int n){    \n    return (num | 1 &lt;&lt; n);\n}\n\nint clear_nth_bit(int num, int n){    \n    return (num &amp; ~( 1 &lt;&lt; n));\n}\n\nint toggle_nth_bit(int num, int n){    \n    return num ^ (1 &lt;&lt; n);\n}\n\nint check_nth_bit(int num, int n){    \n    return num &amp; (1 &lt;&lt; n);\n}\n",
            "1\nnumber\n1\nx\n1 &lt;&lt; x\nx\n~\n// Assume 32 bit int/unsigned\nunsigned long long number = foo();\n\nunsigned x = 40; \nnumber |= (1 &lt;&lt; x);  // UB\nnumber ^= (1 &lt;&lt; x);  // UB\nnumber &amp;= ~(1 &lt;&lt; x); // UB\n\nx = 10;\nnumber &amp;= ~(1 &lt;&lt; x); // Wrong mask, not wide enough\n\n1ull\n(uintmax_t)1\nnumber |= (1ull &lt;&lt; x);\nnumber |= ((uintmax_t)1 &lt;&lt; x);\n\nnumber |= (type_of_number)1 &lt;&lt; x;\n\n1\nnumber\nnumber |= (number*0 + 1) &lt;&lt; x;\n",
            "SET_FLAG(Status, Flag)            ((Status) |= (Flag))\nCLEAR_FLAG(Status, Flag)          ((Status) &amp;= ~(Flag))\nINVALID_FLAGS(ulFlags, ulAllowed) ((ulFlags) &amp; ~(ulAllowed))\nTEST_FLAGS(t,ulMask, ulBit)       (((t)&amp;(ulMask)) == (ulBit))\nIS_FLAG_SET(t,ulMask)             TEST_FLAGS(t,ulMask,ulMask)\nIS_FLAG_CLEAR(t,ulMask)           TEST_FLAGS(t,ulMask,0)\n",
            "namespace bit {\n  template &lt;typename T1, typename T2&gt;\n  constexpr inline T1 bitmask(T2 bit) \n  {return (T1)1 &lt;&lt; bit;}\n  template &lt;typename T1, typename T3, typename ...T2&gt;\n  constexpr inline T1 bitmask(T3 bit, T2 ...bits) \n  {return ((T1)1 &lt;&lt; bit) | bitmask&lt;T1&gt;(bits...);}\n\n  /** Set these bits (others retain their state) */\n  template &lt;typename T1, typename ...T2&gt;\n  constexpr inline void set (T1 &amp;variable, T2 ...bits) \n  {variable |= bitmask&lt;T1&gt;(bits...);}\n  /** Set only these bits (others will be cleared) */\n  template &lt;typename T1, typename ...T2&gt;\n  constexpr inline void setOnly (T1 &amp;variable, T2 ...bits) \n  {variable = bitmask&lt;T1&gt;(bits...);}\n  /** Clear these bits (others retain their state) */\n  template &lt;typename T1, typename ...T2&gt;\n  constexpr inline void clear (T1 &amp;variable, T2 ...bits) \n  {variable &amp;= ~bitmask&lt;T1&gt;(bits...);}\n  /** Flip these bits (others retain their state) */\n  template &lt;typename T1, typename ...T2&gt;\n  constexpr inline void flip (T1 &amp;variable, T2 ...bits) \n  {variable ^= bitmask&lt;T1&gt;(bits...);}\n  /** Check if any of these bits are set */\n  template &lt;typename T1, typename ...T2&gt;\n  constexpr inline bool isAnySet(const T1 &amp;variable, T2 ...bits) \n  {return variable &amp; bitmask&lt;T1&gt;(bits...);}\n  /** Check if all these bits are set */\n  template &lt;typename T1, typename ...T2&gt;\n  constexpr inline bool isSet (const T1 &amp;variable, T2 ...bits) \n  {return ((variable &amp; bitmask&lt;T1&gt;(bits...)) == bitmask&lt;T1&gt;(bits...));}\n  /** Check if all these bits are not set */\n  template &lt;typename T1, typename ...T2&gt;\n  constexpr inline bool isNotSet (const T1 &amp;variable, T2 ...bits) \n  {return ((variable &amp; bitmask&lt;T1&gt;(bits...)) != bitmask&lt;T1&gt;(bits...));}\n}\n\n#include &lt;iostream&gt;\n#include &lt;bitset&gt; // for console output of binary values\n\n// and include the code above of course\n\nusing namespace std;\n\nint main() {\n  uint8_t v = 0b1111'1100;\n  bit::set(v, 0);\n  cout &lt;&lt; bitset&lt;8&gt;(v) &lt;&lt; endl;\n\n  bit::clear(v, 0,1);\n  cout &lt;&lt; bitset&lt;8&gt;(v) &lt;&lt; endl;\n\n  bit::flip(v, 0,1);\n  cout &lt;&lt; bitset&lt;8&gt;(v) &lt;&lt; endl;\n\n  bit::clear(v, 0,1,2,3,4,5,6,7);\n  cout &lt;&lt; bitset&lt;8&gt;(v) &lt;&lt; endl;\n\n  bit::flip(v, 0,7);\n  cout &lt;&lt; bitset&lt;8&gt;(v) &lt;&lt; endl;\n}\n",
            "public class BitwiseOperations {\n\n    public static void main(String args[]) {\n\n        setABit(0, 4);    // Set the 4th bit, 0000 -&gt; 1000 [8]\n        clearABit(16, 5); // Clear the 5th bit, 10000 -&gt; 00000 [0]\n        toggleABit(8, 4); // Toggle the 4th bit, 1000 -&gt; 0000 [0]\n        checkABit(8, 4);  // Check the 4th bit 1000 -&gt; true\n    }\n\n    public static void setABit(int input, int n) {\n        input = input | (1 &lt;&lt; n-1);\n        System.out.println(input);\n    }\n\n\n    public static void clearABit(int input, int n) {\n        input = input &amp; ~(1 &lt;&lt; n-1);\n        System.out.println(input);\n    }\n\n    public static void toggleABit(int input, int n) {\n        input = input ^ (1 &lt;&lt; n-1);\n        System.out.println(input);\n    }\n\n    public static void checkABit(int input, int n) {\n        boolean isSet = ((input &gt;&gt; n-1) &amp; 1) == 1;\n        System.out.println(isSet);\n    }\n}\n\n8\n0\n0\ntrue\n",
            "#define INT_BIT (unsigned int) (sizeof(unsigned int) * 8U) //number of bits in unsigned int\n\nint main(void)\n{\n    \n    unsigned int k = 5; //k is the bit position; here it is the 5th bit from the LSb (0th bit)\n    \n    unsigned int regA = 0x00007C7C; //we perform bitwise operations on regA\n    \n    regA |= (1U &lt;&lt; k);    //Set kth bit\n    \n    regA &amp;= ~(1U &lt;&lt; k);   //Clear kth bit\n    \n    regA ^= (1U &lt;&lt; k);    //Toggle kth bit\n    \n    regA = (regA &lt;&lt; k) | regA &gt;&gt; (INT_BIT - k); //Rotate left by k bits\n    \n    regA = (regA &gt;&gt; k) | regA &lt;&lt; (INT_BIT - k); //Rotate right by k bits\n\n    return 0;   \n}\n\n",
            "#include &lt;stdio.h&gt;\n#include &lt;stdbool.h&gt;\n\ntypedef unsigned long Uint;\n\nUint bit_set(Uint number, Uint n);\nUint bit_clear(Uint number, Uint n);\nUint bit_toggle(Uint number, Uint n);\nbool bit_check(Uint number, Uint n);\nUint bit_set_to(Uint number, Uint n, bool x);\nvoid print_binary(Uint number, int total_bits);\n\nint main() {\n    Uint number = 29; // Example number in binary: 00011101\n    Uint n = 3;       // Example: bit position 3 (starting from 0)\n\n    printf(&quot;Initial number: %lu (binary: &quot;, number);\n    print_binary(number, 8);  // Print number in binary\n\n    // Set nth bit to 1\n    printf(&quot;\\nSetting bit %lu...\\n&quot;, n);\n    number = bit_set(number, n);\n    printf(&quot;Number after setting bit %lu: %lu (binary: &quot;, n, number);\n    print_binary(number, 8);\n\n    // Clear nth bit (set to 0)\n    printf(&quot;\\nClearing bit %lu...\\n&quot;, n);\n    number = bit_clear(number, n);\n    printf(&quot;Number after clearing bit %lu: %lu (binary: &quot;, n, number);\n    print_binary(number, 8);\n\n    // Toggle nth bit\n    printf(&quot;\\nToggling bit %lu...\\n&quot;, n);\n    number = bit_toggle(number, n);\n    printf(&quot;Number after toggling bit %lu: %lu (binary: &quot;, n, number);\n    print_binary(number, 8);\n\n    // Check nth bit\n    printf(&quot;\\nChecking bit %lu...\\n&quot;, n);\n    bool is_set = bit_check(number, n);\n    printf(&quot;Bit %lu is %s\\n&quot;, n, is_set ? &quot;set (1)&quot; : &quot;clear (0)&quot;);\n\n    // Set nth bit to specific value (example: set to 1)\n    printf(&quot;\\nSetting bit %lu to 1...\\n&quot;, n);\n    number = bit_set_to(number, n, true);\n    printf(&quot;Number after setting bit %lu to 1: %lu (binary: &quot;, n, number);\n    print_binary(number, 8);\n\n    // Set nth bit to specific value (example: set to 0)\n    printf(&quot;\\nSetting bit %lu to 0...\\n&quot;, n);\n    number = bit_set_to(number, n, false);\n    printf(&quot;Number after setting bit %lu to 0: %lu (binary: &quot;, n, number);\n    print_binary(number, 8);\n\n    return 0;\n}\n\nUint bit_set(Uint number, Uint n) {\n    return number | ((Uint)1 &lt;&lt; n);\n}\n\nUint bit_clear(Uint number, Uint n) {\n    return number &amp; ~((Uint)1 &lt;&lt; n);\n}\n\nUint bit_toggle(Uint number, Uint n) {\n    return number ^ ((Uint)1 &lt;&lt; n);\n}\n\nbool bit_check(Uint number, Uint n) {\n    return (number &gt;&gt; n) &amp; (Uint)1;\n}\n\nUint bit_set_to(Uint number, Uint n, bool x) {\n    return (number &amp; ~((Uint)1 &lt;&lt; n)) | ((Uint)x &lt;&lt; n);\n}\n\nvoid print_binary(Uint number, int total_bits) {\n    for (int i = total_bits - 1; i &gt;= 0; i--) {\n        printf(&quot;%lu&quot;, (number &gt;&gt; i) &amp; 1);\n    }\n    printf(&quot;)\\n&quot;);\n}\n",
            "number = (((number | (1 &lt;&lt; n)) ^ (1 &lt;&lt; n))) | (x &lt;&lt; n);\n\n((number | (1 &lt;&lt; n)\n|\n(...) ^ (1 &lt;&lt; n)\n(...) | x &lt;&lt; n)\nx",
            "char bitfield;\n\n// Start at 0th position\n\nvoid chang_n_bit(int n, int value)\n{\n    bitfield = (bitfield | (1 &lt;&lt; n)) &amp; (~( (1 &lt;&lt; n) ^ (value &lt;&lt; n) ));\n}\n\nvoid chang_n_bit(int n, int value)\n{\n    bitfield = (bitfield | (1 &lt;&lt; n)) &amp; ((value &lt;&lt; n) | ((~0) ^ (1 &lt;&lt; n)));\n}\n\nvoid chang_n_bit(int n, int value)\n{\n    if(value)\n        bitfield |= 1 &lt;&lt; n;\n    else\n        bitfield &amp;= ~0 ^ (1 &lt;&lt; n);\n}\n\nchar get_n_bit(int n)\n{\n    return (bitfield &amp; (1 &lt;&lt; n)) ? 1 : 0;\n}\n"
        ]
    },
    {
        "question_id": 21593,
        "question_code": "include\n#include &lt;filename&gt;\n#include &quot;filename&quot;",
        "answer_code_snippets": [
            "#include &lt;filename&gt;\n#include &quot;filename&quot;",
            "#include &lt;h-char-sequence&gt; new-line\n\n&lt;\n&gt;\n#include \"q-char-sequence\" new-line\n\n\"\n#include &lt;h-char-sequence&gt; new-line\n\n&gt;\n#include pp-tokens new-line\n\ninclude\n&lt;\n&gt;\n\"\n&gt;\n\"",
            "#include \"file\"\n#include &lt;file&gt;\n#include\n#include",
            "#include \"file.h\"\n./file.h\n.\n#include\n#include &lt;file.h&gt;\n/usr/include/file.h\n/usr/include",
            "#include &lt;file.h&gt;\nfile.h\n#include &quot;file&quot;\nfile\n-I\n-I\nincludes\nmyheader.h\n#include &lt;myheader.h&gt;\n-I .\n-I\n#include &quot;myheader.h&quot;\nmyheader.h\ninclude",
            "‘#include’\n#include &lt;file&gt;\n-I\n#include \"file\"\n&lt;file&gt;\n-iquote\n‘#include’\n#include &lt;x/*y&gt;\nx/*y\n#include \"x\\n\\\\y\"\n‘/’\n‘/’",
            "\"mypath/myfile\" is short for ./mypath/myfile\n\n.\n#include\ndefault_include_paths\n&lt;mypath/myfile&gt; is short for &lt;defaultincludepaths&gt;/mypath/myfile\n\n./\n&lt;default_include_paths&gt;\nmypath/myfile",
            "&lt;file&gt;\n-I\n\"file\"\n-I\n# include &lt;h-char-sequence&gt; new-line\n# include \"q-char-sequence\" new-line\n# include &lt;h-char-sequence&gt; new-line\n\"xxx\"\n&lt;xxx&gt;",
            "#include &lt;h-char-sequence&gt; new-line\n\n&lt;\n&gt;\n#include \"q-char-sequence\" new-line\n\n\"\n#include &lt;h-char-sequence&gt; new-line\n\n&gt;\n#include pp-tokens new-line\n\ninclude\n&lt;\n&gt;\n\"\n&gt;\n\"\n&lt;stdio.h&gt;\n#include \"...\"\n#include\n#include &lt;...&gt;",
            "#include \"\"\n#include &lt;&gt;",
            "&quot;myApp.hpp&quot;\n&lt;libHeader.hpp&gt;\n/I\nINCLUDE\n#include &quot;../../MyProgDir/SourceDir1/someFile.hpp&quot;\n\n&quot;./myHeader.h&quot;\n/I\nINCLUDE\n/I\nINCLUDE",
            "#include &lt;list&gt;\n#include &lt;xxx&gt;",
            "#include &lt;&gt;\n#include &lt;iostream&gt;\n\n#include \" \"\nmyfile.h\n#include \"myfile.h\"\n",
            "#include \"filename\" // User defined header\n#include &lt;filename&gt; // Standard library header.\n\nSeller.h\n#ifndef SELLER_H     // Header guard\n#define SELLER_H     // Header guard\n\n#include &lt;string&gt;\n#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n\nclass Seller\n{\n    private:\n        char name[31];\n        double sales_total;\n\n    public:\n        Seller();\n        Seller(char[], double);\n        char*getName();\n\n#endif\n\nSeller.cpp\nSeller.h\n#include \"Seller.h\"\n",
            "#include &lt;abc.h&gt;\n\n#include \"xyz.h\"\n\n-I",
            "#include &lt;file&gt; \n\n#include &quot;file&quot; \n",
            "&quot;&quot;\n./\ngcc -v -o a a.c\n\n// a.c\n#include &quot;stdio.h&quot;\nint main() {\n        int a = 3;\n        printf(&quot;a = %d\\n&quot;, a);\n        return 0;\n\n}\n\n// b.c\n#include &lt;stdio.h&gt;\nint main() {\n        int a = 3;\n        printf(&quot;a = %d\\n&quot;, a);\n        return 0;\n\n}\n\nstdio.h\n// stdio.h\ninline int foo()\n{\n        return 10;\n}\n\na.c\nb.c\nd.c\n// d.c\n#include &lt;stdio.h&gt;\n#include &quot;stdio.h&quot;\nint main()\n{\n        int a = 0;\n\n        a = foo();\n\n        printf(&quot;a=%d\\n&quot;, a);\n\n        return 0;\n}\n",
            "#include &lt;filename&gt;\n/usr/include\n/usr/local/include\n#include \"filename\"",
            "#include &lt;filename&gt;\n#include &quot;path-to-file/filename&quot;",
            "#include &lt;filename&gt;\n#include \"filename\"\n#include &lt;filename&gt;\n#include &lt;filename&gt;",
            "cpp -v /dev/null -o /dev/null",
            "#include &lt;myFilename&gt;\n#include &quot;myFilename&quot;",
            "#include\"filename\"\n#include&lt;filename&gt;\n\n#include\"mylib.h\"\n\nmylib.h\n#include&lt;mylib.h&gt;\n\nmylib.h"
        ]
    },
    {
        "question_id": 605845,
        "question_code": "malloc\nint *sieve = malloc(sizeof(*sieve) * length);\n\nint *sieve = (int *) malloc(sizeof(*sieve) * length);\n",
        "answer_code_snippets": [
            "void *\n&lt;stdlib.h&gt;\nint\nint\nint *sieve = malloc(length * sizeof *sieve);\n\nsizeof\nsizeof\nlength\nsizeof\nsizeof\nlength\nint *sieve = malloc(sizeof *sieve * length);\n\nsizeof\nsize_t\nmalloc(sizeof *sieve * length * width)\nmalloc(length * width * sizeof *sieve)\nlength * width\nwidth\nlength\nsize_t",
            "malloc\nmalloc\nint *sieve = malloc(sizeof *sieve * length);\n\nsieve",
            "type *\ntype **\n#include\nmalloc()",
            "#ifdef __cplusplus\n# define MALLOC(type) ((type *)malloc(sizeof(type)))\n# define CALLOC(count, type) ((type *)calloc(count, sizeof(type)))\n#else\n# define MALLOC(type) (malloc(sizeof(type)))\n# define CALLOC(count, type) (calloc(count, sizeof(type)))\n#endif\n# define FREE(pointer) free(pointer)\n\nint *sieve = MALLOC(int); // allocate single int =&gt; compare to stack int sieve = ???;\nint *sieve_arr = CALLOC(4, int); // allocate 4 times size of int =&gt; compare to stack (int sieve_arr[4] = {0, 0, 0, 0};\n// do something with the ptr or the value\nFREE(sieve);\nFREE(sieve_arr);\n",
            "malloc",
            "void",
            "malloc\nmalloc\nvoid*\nnew\nmalloc()\n&lt;stdlib.h&gt;\n&lt;stdlib.h&gt;\nint\nmalloc",
            "void *",
            "malloc()\nvoid *\nchar *",
            "malloc\nvoid*\nvoid*",
            "malloc\nvoid *",
            "malloc\nmalloc\nvoid*",
            "#include &lt;stdlib.h&gt;\n#define NEW_ARRAY(ptr, n) (ptr) = malloc((n) * sizeof *(ptr))\n#define NEW(ptr) NEW_ARRAY((ptr), 1)\n\nNEW_ARRAY(sieve, length);\n\n#define LEN(arr) (sizeof (arr) / sizeof (arr)[0])\n\nint i, a[100];\n\nfor (i = 0; i &lt; LEN(a); i++) {\n   ...\n}\n",
            "#include &lt;stdlib.h&gt;\nmalloc()\nmalloc()\nint\nsizeof(int) != sizeof(int*)\nstdlib.h\nmalloc()\nstdlib.h\nmalloc()\n_Alignof (max_align_t)\n_Alignof (max_align_t)\nmalloc()",
            "malloc()\nvoid *\n#include &lt;stdlib.h&gt;\nlong x = 5;\ndouble *p = (double *)&amp;x;\ndouble y = *p;\n\nstruct foo { int x; };\nstruct bar { int x; int y; };\nstruct bar b = { 1, 2};\nstruct foo *p = (struct foo *)&amp;b;\nint z = p-&gt;x;\n\nvoid *\nint x = 5;\nprintf(\"%p\\n\", (void *)&amp;x);\n\nprintf()\nvoid *",
            "double d;\nvoid *p = &amp;d;\nint *q = p;\n\nmalloc\nunsigned char *\nvoid *\nchar *\nunsigned char *\nmemset\nmemcpy\nmalloc\nvoid *\n/* In a header somewhere */\n#ifdef __cplusplus\n#define strip_qual(TYPE, EXPR) (const_cast&lt;TYPE&gt;(EXPR))\n#define convert(TYPE, EXPR) (static_cast&lt;TYPE&gt;(EXPR))\n#define coerce(TYPE, EXPR) (reinterpret_cast&lt;TYPE&gt;(EXPR))\n#else\n#define strip_qual(TYPE, EXPR) ((TYPE) (EXPR))\n#define convert(TYPE, EXPR) ((TYPE) (EXPR))\n#define coerce(TYPE, EXPR) ((TYPE) (EXPR))\n#endif\n\ngrep\nstrip_qual\nconst\nvolatile\n-Wold-style-cast\n(type)\nmalloc",
            "g_new\ng_new0\ng_new\ng_new0\ng_new\ng_new0\nmalloc\ncalloc\n0",
            "-Wall\nauto\n-Wall\n-std=c++11\nstdlib.h\nmalloc\nmalloc\nvoid*\nT*\nauto memblock=static_cast&lt;T*&gt;(malloc(n*sizeof(T))); //Mult may overflow...\n",
            "void *\n&lt;stdlib.h&gt;\nmalloc",
            "malloc\nmalloc()\nptr = (T*)malloc(sizeof(T));\nptr = malloc(sizeof *ptr);\nptr\nptr\nnew\n#define NEW(T) ((T*)malloc(sizeof(T)))\n...\nptr = NEW(T);\n\nptr\nvoid*\nptr\nptr\nvoid*",
            "malloc\nmalloc\nmalloc"
        ]
    },
    {
        "question_id": 7825055,
        "question_code": "!ErrorHasOccured() ??!??! HandleError();\n\n??!??!\n??!??!",
        "answer_code_snippets": [
            "??!\n|\n!ErrorHasOccured() || HandleError();\n\nif (ErrorHasOccured())\n    HandleError();\n",
            "{ | } ~ \n\n??!\n|\n||",
            "??!??!\n??!\n??!\n||\nTrigraph   Replaces\n\n??(        [\n??)        ]\n??&lt;        {\n??&gt;        }\n??/        \\\n??'        ^\n??=        #\n??!        |\n??-        ~\n\n??(??)\n[]\n??(??)??(??)\n[][]\ncpp\ntrigr.c\nvoid main(){ const char *s = &quot;??!??!&quot;; } \n\ncpp -trigraphs trigr.c \n\nvoid main(){ const char *s = &quot;||&quot;; }\n\n-trigraphs\ncpp",
            "??!\n|\n??!??!\n||"
        ]
    },
    {
        "question_id": 1041866,
        "question_code": "extern \"C\"\nextern \"C\" {\n   void foo();\n}\n",
        "answer_code_snippets": [
            "extern &quot;C&quot;\nextern &quot;C&quot;\nextern &quot;C&quot;\nextern &quot;C&quot; void foo(int);\nextern &quot;C&quot;\n{\n   void g(char);\n   int i;\n}\n\nextern &quot;C&quot;\nextern &quot;C&quot;\nextern &quot;C&quot;\nextern &quot;C&quot;\nstatic\nextern &quot;C&quot;",
            "#ifdef __cplusplus\nextern &quot;C&quot; {\n#endif\n\n// all of your legacy C code here\n\n#ifdef __cplusplus\n}\n#endif\n\n__cplusplus\nextern &quot;C&quot; {\n#include &quot;legacy_C_header.h&quot;\n}\n",
            "g++\nvoid f() {}\nvoid g();\n\nextern &quot;C&quot; {\n    void ef() {}\n    void eg();\n}\n\n/* Prevent g and eg from being optimized away. */\nvoid h() { g(); eg(); }\n\ng++ -c -std=c++11 -Wall -Wextra -pedantic -o main.o main.cpp\nreadelf -s main.o\n\n     8: 0000000000000000     7 FUNC    GLOBAL DEFAULT    1 _Z1fv\n     9: 0000000000000007     7 FUNC    GLOBAL DEFAULT    1 ef\n    10: 000000000000000e    17 FUNC    GLOBAL DEFAULT    1 _Z1hv\n    11: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND _GLOBAL_OFFSET_TABLE_\n    12: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND _Z1gv\n    13: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND eg\n\nef\neg\n$ c++filt _Z1fv\nf()\n$ c++filt _Z1hv\nh()\n$ c++filt _Z1gv\ng()\n\nNdx = UND\nextern &quot;C&quot;\ng++\ngcc\ng++\ngcc\nextern C\nextern &quot;C&quot; {\n    // Overloading.\n    // error: declaration of C function ‘void f(int)’ conflicts with\n    void f();\n    void f(int i);\n\n    // Templates.\n    // error: template with C linkage\n    template &lt;class C&gt; void f(C i) { }\n}\n\n#include &lt;cassert&gt;\n\n#include &quot;c.h&quot;\n\nint main() {\n    assert(f() == 1);\n}\n\n#ifndef C_H\n#define C_H\n\n/* This ifdef allows the header to be used from both C and C++ \n * because C does not know what this extern &quot;C&quot; thing is. */\n#ifdef __cplusplus\nextern &quot;C&quot; {\n#endif\nint f();\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n\n#include &quot;c.h&quot;\n\nint f(void) { return 1; }\n\ng++ -c -o main.o -std=c++98 main.cpp\ngcc -c -o c.o -std=c89 c.c\ng++ -o main.out main.o c.o\n./main.out\n\nextern &quot;C&quot;\nmain.cpp:6: undefined reference to `f()'\n\ng++\nf\ngcc\n#include &lt;assert.h&gt;\n\n#include &quot;cpp.h&quot;\n\nint main(void) {\n    assert(f_int(1) == 2);\n    assert(f_float(1.0) == 3);\n    return 0;\n}\n\n#ifndef CPP_H\n#define CPP_H\n\n#ifdef __cplusplus\n// C cannot see these overloaded prototypes, or else it would get confused.\nint f(int i);\nint f(float i);\nextern &quot;C&quot; {\n#endif\nint f_int(int i);\nint f_float(float i);\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n\n#include &quot;cpp.h&quot;\n\nint f(int i) {\n    return i + 1;\n}\n\nint f(float i) {\n    return i + 2;\n}\n\nint f_int(int i) {\n    return f(i);\n}\n\nint f_float(float i) {\n    return f(i);\n}\n\ngcc -c -o main.o -std=c89 -Wextra main.c\ng++ -c -o cpp.o -std=c++98 cpp.cpp\ng++ -o main.out main.o cpp.o\n./main.out\n\nextern &quot;C&quot;\nmain.c:6: undefined reference to `f_int'\nmain.c:7: undefined reference to `f_float'\n\ng++\ngcc\nextern &quot;c&quot;\ncstdio\n#pragma GCC system_header\n/usr/include/unistd.h\n__BEGIN_DECLS\n__BEGIN_DECLS\n#include &lt;features.h&gt;",
            "dlsym()\ndlopen()",
            "extern &quot;C&quot;\n#include &lt;stdio.h&gt;\n    \n// Two functions are defined with the same name\n//   but have different parameters\n\nvoid printMe(int a) {\n  printf(&quot;int: %i\\n&quot;, a);\n}\n\nvoid printMe(char a) {\n  printf(&quot;char: %c\\n&quot;, a);\n}\n    \nint main() {\n  printMe('a');\n  printMe(1);\n  return 0;\n}\n\nprintMe\nint a\nchar a\nprintMe\nextern &quot;C&quot;\ninclude\nextern &quot;C&quot;\nextern &quot;C&quot; void printMe(int a);",
            "extern \"C\" {\nstruct method {\n    int virtual;\n};\n}\n",
            "extern &quot;C&quot;",
            "extern \"C\"\nextern \"language\" function-prototype\n\nextern \"language\"\n{\n     function-prototype\n};\n\n#include&lt;iostream&gt;\nusing namespace std;\n\nextern \"C\"\n{\n     #include&lt;stdio.h&gt;    // Include C Header\n     int n;               // Declare a Variable\n     void func(int,int);  // Declare a function (function prototype)\n}\n\nint main()\n{\n    func(int a, int b);   // Calling function . . .\n    return 0;\n}\n\n// Function definition . . .\nvoid func(int m, int n)\n{\n    //\n    //\n}\n",
            "#include &lt;stdio.h&gt;\n\nconst char* get_message2(void); \nint get_message2(char*); \n\nint main() {\n   char test[] = &quot;BBBBBBB&quot;;\n   get_message2(test);\n   return 0;\n}\n\nconst char* get_message2() {\n    char test[] = &quot;AAAAAAA&quot;;\n    return &quot;message2&quot;;\n};\n\nint get_message2(char* arg) {\n    char test[] = &quot;CCCCCCC&quot;;\n   return 0;\n}\n\ndrazen@HP-ProBook-640G1:~/proba$ readelf  -a proba | grep message\n    34: 0000000000001199    70 FUNC    GLOBAL DEFAULT   16 _Z12get_message2v\n    36: 00000000000011df    72 FUNC    GLOBAL DEFAULT   16 _Z12get_message2Pc\n\nextern &quot;C&quot;\nconst char* get_message2(void); \nextern &quot;C&quot; {\n   int get_message2(char*); \n}\n\nint get_message2(char*);\ndrazen@HP-ProBook-640G1:~/proba$ readelf  -a proba | grep message\n    32: 00000000000011df    72 FUNC    GLOBAL DEFAULT   16 get_message2\n    35: 0000000000001199    70 FUNC    GLOBAL DEFAULT   16 _Z12get_message2v\n",
            "#include &lt;string.h&gt;\n#include &lt;windows.h&gt;\n\nusing namespace std;\n\n#define DLL extern \"C\" __declspec(dllexport)\n//I defined DLL for dllexport function\nDLL main ()\n{\n    MessageBox(NULL,\"Hi from DLL\",\"DLL\",MB_OK);\n}\n\n#include &lt;string.h&gt;\n#include &lt;windows.h&gt;\n\nusing namespace std;\n\ntypedef LPVOID (WINAPI*Function)();//make a placeholder for function from dll\nFunction mainDLLFunc;//make a variable for function placeholder\n\nint main()\n{\n    char winDir[MAX_PATH];//will hold path of above dll\n    GetCurrentDirectory(sizeof(winDir),winDir);//dll is in same dir as exe\n    strcat(winDir,\"\\\\exmple.dll\");//concentrate dll name with path\n    HINSTANCE DLL = LoadLibrary(winDir);//load example dll\n    if(DLL==NULL)\n    {\n        FreeLibrary((HMODULE)DLL);//if load fails exit\n        return 0;\n    }\n    mainDLLFunc=(Function)GetProcAddress((HMODULE)DLL, \"main\");\n    //defined variable is used to assign a function from dll\n    //GetProcAddress is used to locate function with pre defined extern name \"DLL\"\n    //and matcing function name\n    if(mainDLLFunc==NULL)\n    {\n        FreeLibrary((HMODULE)DLL);//if it fails exit\n        return 0;\n    }\n    mainDLLFunc();//run exported function \n    FreeLibrary((HMODULE)DLL);\n}\n",
            "extern &quot;C&quot;\nextern &quot;C&quot;\nvoid cf () {}\n\nvoid cppf () {}\n\ndumpbin /symbols\n01A 00000000 SECT7  notype ()    External     | _cf\n01B 00000000 SECT5  notype ()    External     | ?cppf@@YAXXZ (void __cdecl cppf(void))\n\ntypedef struct {\n  int a;\n  int b;\n}\nCppStruct;\n\nextern &quot;C&quot; {\n  typedef struct {\n    int a;\n    int b;\n    int c;\n  }\n  CStruct;\n  CStruct cCStruct;\n  CppStruct cCppStruct;\n}\nCStruct cppCStruct;\nCppStruct cppCppStruct;\n\ndumpbin /symbols\n009 00000000 SECT3  notype       External     | _cCStruct\n00A 0000000C SECT3  notype       External     | _cCppStruct\n00B 00000014 SECT3  notype       External     | ?cppCStruct@@3UCStruct@@A (struct CStruct cppCStruct)\n00C 00000020 SECT3  notype       External     | ?cppCppStruct@@3UCppStruct@@A (struct CppStruct cppCppStruct)\n\ndumpbin\nextern &quot;C&quot;\nextern &quot;C&quot;\nextern CppStruct ifcStruct;\nextern int       ifcVar;\n/* ... */\n\nextern &quot;C&quot;\n{\nCppStruct ifcStruct;\nint       ifcVar = 0;\n}\n\ndumpbin /symbols\n00C 00000000 SECT4  notype       External     | ?ifcStruct@@3UCppStruct@@A (struct CppStruct ifcStruct)\n00D 00000008 SECT4  notype       External     | ?ifcVar@@3HA (int ifcVar)\n\nextern &quot;C&quot;\ntest.cpp(20): error C2732: linkage specification contradicts earlier specification for 'ifcf'\ntest.cpp(20): note: see declaration of 'ifcf'\n\nextern &quot;C&quot;\nextern &quot;C&quot; __declspec(dllexport) IKlass* __cdecl create_klass()\nextern &quot;C&quot;\ncreate_klass\n__declspec(dllexport)\ncreate_klass\ncreate_klass\n__cdecl\n__stdcall\niklass_factory",
            "C\nextern \"C\"",
            "extern &quot;c&quot;\n#include &lt;stdio.h&gt;\nextern &quot;C&quot;{\n\n\nstruct myint{\n    int i;\n};\n\nstruct myint2\n{\n    int a;\n    myint2(int a): a(a) {};\n    operator myint() const {return myint{a};}\n};\n\n}\n\nvoid f1(myint i){\n    printf(&quot;%d&quot;, i.i);\n}\n\nint main(){\n    myint2 a(1);\n    f1(a);\n}\n\nnm\nmain"
        ]
    },
    {
        "question_id": 1143262,
        "question_code": "const int *\nconst int * const\nint * const",
        "answer_code_snippets": [
            "int*\nint const *\nint * const\nint const * const\nconst\nconst int *\nint const *\nconst int * const\nint const * const\nint **\nint ** const\nint * const *\nint const **\nint * const * const\nconst\nint a = 5, b = 10, c = 15;\n\nconst int* foo;     // pointer to constant int.\nfoo = &amp;a;           // assignment to where foo points to.\n\n/* dummy statement*/\n*foo = 6;           // the value of a can´t get changed through the pointer.\n\nfoo = &amp;b;           // the pointer foo can be changed.\n\n\n\nint *const bar = &amp;c;  // constant pointer to int \n                      // note, you actually need to set the pointer \n                      // here because you can't change it later ;)\n\n*bar = 16;            // the value of c can be changed through the pointer.    \n\n/* dummy statement*/\nbar = &amp;a;             // not possible because bar is a constant pointer.           \n\nfoo\nconst char\nbar\nT* const\nNULL",
            "typedef\ntypedef char *ASTRING;\nconst ASTRING astring;\n\nastring\nchar * const\nconst char *\nconst",
            "const X* p\nX* const p\nconst X* const p\nconst X* p\nX* const p\nconst X* const p",
            "int var0 = 0;\nconst int &amp;ptr1 = var0;\nptr1 = 8; // Error\nvar0 = 6; // OK\n\nint var1 = 1;\nint var2 = 0;\n\nint *const ptr2 = &amp;var1;\nptr2 = &amp;var2; // Error\n\nint const * ptr3 = &amp;var2;\n*ptr3 = 4; // Error\n\nint var3 = 0;\nint var4 = 0;\nconst int * const ptr4 = &amp;var3;\n*ptr4 = 1;     // Error\n ptr4 = &amp;var4; // Error\n",
            "const\nconst\nconst int*\nint const*\nconst int* const\nint const* const",
            "const\nconst\nconst int Constant1=96; \n\nConstant1\n#define\nconst\nconst int * Constant2 \n\nConstant2\nint const * Constant2\n\nint * const Constant3\n\nConstant3\nint const * const Constant4\n\nConstant4",
            "const\nint\nchar\nfloat\nconst int *p\n*p\np\nint const *p\n*p\np\nint *p const\nint *const p\np\np\np\nconst int *p const\nconst int const *p\n*p\nconst int *const p\n*p\np\np\np\nint const *p const\nint const int *p\nint const const *p\n*p\nint const *p\nint const *const p\n*p\np\np\np",
            "const\nconst\nconst\nconst",
            "Type\nPtr_\ntemplate&lt; class Type &gt;\nusing Ptr_ = Type*;\n\nPtr_&lt;char&gt;\nchar\nPtr_&lt;const char&gt;\nconst char\nconst Ptr_&lt;const char&gt;\nconst\nconst char",
            "const\n*\nconst\n*\nconst\nconst\n*\nconst",
            "TYPE const &amp;\nTYPE&amp; TYPE::operator=(const TYPE &amp;rhs) { ... return *this; }\nTYPE &amp;  const\nconst\nTYPE const &amp;\nbool TYPE::operator==(const TYPE &amp;rhs) const { ... }\nconst TYPE TYPE::operator+(const TYPE &amp;rhs) const { ... }\nT const&amp; operator[] (unsigned i) const;\ninline T&amp; operator[] (unsigned i) {\n  return const_cast&lt;char&amp;&gt;( \n     static_cast&lt;const TYPE&amp;&gt;(*this)[](i)\n  );\n}\nint const &amp;",
            "const int *ptr=&amp;i;\n\nint const *ptr=&amp;i;\n\nconst\n*\nint *const ptr=&amp;i;\n\n const int *ptr1=&amp;i, *ptr2=&amp;j;\n\nint const *ptr1=&amp;i, *const ptr2=&amp;j;\n",
            "const\n*\nconst int\nint const\nconst\n*\nconst int *p\nint x = 5;\nconst int *p = &amp;x;\nx = 6; //legal\nprintf(\"%d\", *p) // prints 6\n*p = 7; //error \n",
            "int const v\nconst int v",
            "x\nint *p;\nint const *p;\nint * const p;\nint const * const p;\nint **pp;\nint ** const pp;\nint * const *pp;\nint const **pp;\nint * const * const pp;\nint const ** const pp;\nint const * const *pp;\nint const * const * const pp;\n// Example 1\nint x;\nx = 10;\nint *p = NULL;\np = &amp;x;\nint **pp = NULL;\npp = &amp;p;\nprintf(\"%d\\n\", **pp);\n\n// Example 2\nint x;\nx = 10;\nint *p = NULL;\np = &amp;x;\nint ** const pp = &amp;p; // Definition must happen during declaration\nprintf(\"%d\\n\", **pp);\n\n// Example 3\nint x;\nx = 10;\nint * const p = &amp;x; // Definition must happen during declaration\nint * const *pp = NULL;\npp = &amp;p;\nprintf(\"%d\\n\", **pp);\n\n// Example 4\nint const x = 10; // Definition must happen during declaration\nint const * p = NULL;\np = &amp;x;\nint const **pp = NULL;\npp = &amp;p;\nprintf(\"%d\\n\", **pp);\n\n// Example 5\nint x;\nx = 10;\nint * const p = &amp;x; // Definition must happen during declaration\nint * const * const pp = &amp;p; // Definition must happen during declaration\nprintf(\"%d\\n\", **pp);\n\n// Example 6\nint const x = 10; // Definition must happen during declaration\nint const *p = NULL;\np = &amp;x;\nint const ** const pp = &amp;p; // Definition must happen during declaration\nprintf(\"%d\\n\", **pp);\n\n// Example 7\nint const x = 10; // Definition must happen during declaration\nint const * const p = &amp;x; // Definition must happen during declaration\nint const * const *pp = NULL;\npp = &amp;p;\nprintf(\"%d\\n\", **pp);\n\n// Example 8\nint const x = 10; // Definition must happen during declaration\nint const * const p = &amp;x; // Definition must happen during declaration\nint const * const * const pp = &amp;p; // Definition must happen during declaration\nprintf(\"%d\\n\", **pp);\n\nint x = 10;\nint *p = &amp;x;\nint **pp = &amp;p;\nint ***ppp = &amp;pp;\nint ****pppp = &amp;ppp;\n\nprintf(\"%d \\n\", ****pppp);\n",
            "const\nconst\nconst\nconst\nconst\nint const *foo;\nint * const bar;\nconst\nvoid func(int param)\nvoid func(int const param)\nvoid func(int &amp;param)\nfunc\nparam\nvoid func(int const &amp;param)\nfunc\nparam\nvoid func(int *param)\nvoid func(int const *param)\nnullptr\nfunc\nnullptr\nparam\nnullptr",
            "const int*\nint\nint\nconst int * const\nint\nint\nint const *\nint\nconst int*\nint\nint * const\nint\nint\nint",
            "int i;\ni\nint\ni\nint *p;\np\n*\nint\np\nconst int *p;\np\n*\nconst int\np\nint *const p;\np\n*\nint\np\nconst int *const p;\np\n*\nconst int\np\nint a[3];\na\nint\na\nint *a[3];\na\nint *\na\nint (*a)[3];\na\n*a\n*a\n*a\na\nint i = (*a)[1];\nint (*a)[3][2];\noperator()()\noperator*()\nint *f();\nf\nint i = *f();\nint (*fp)();\nfp\n*fp\nfp\noperator()()\nfp\nint *(*fp)();\nint (*(*fp)())[3];\n(*fp) \n#include &lt;iostream&gt;\nusing namespace std;\n\nint (*f())[3]\n{\n  static int arr[3] = {1,2,3};\n  return &amp;arr;\n}\n\nint (*(*fp)())[3] = &amp;f;\n\nint main()\n{\n  for(int i=0; i&lt;3; i++)\n  {\n    cout &lt;&lt; (*(*fp)())[i] &lt;&lt; endl;\n  }\n}\n",
            "type\n*\nname\nint *i\ni\nint\nconst int *i\ni\nconst int\nint *const i\nconst i\nint\nint const *i",
            "const int a=3,b;\n\na=4;  // give error\nb=5;  // give error as b is also const int \n\nyou have to intialize while declaring itself as no way to assign\nit afterwards.\n\ntype a.    p is ptr to const int\n\ntype b.    p is const ptr to int \n \ntype c.    p is const ptr to const int\n\nif * comes before int \n\n1. const int *\n\n2. const const int *\n\n*const int p      [Error]\n*int const p      [Error]\n\nconst int *p      type a. p is ptr to const int \nconst *int p      [Error]\n\nint const *p      type a. \nint * const p     type b. p is const ptr to int\n\n* int const const p     [Error]\n* const int const p     [Error]\n* const const int p     [Error]\n \n\nint const const *p      type a. p is ptr to const int\nint const * const p     type c. p is const ptr to const int\nint * const const p     type b. p is const ptr to int\n\nconst const int *p     type a.\nconst const * int p    [Error]\n\nconst int const *p      type a.\nconst int * const p     type c.\n\nconst * int const p    [Error]\nconst * const int p    [Error]\n\nconst int *p\nint const *p\n\nint const const *p\nconst const int  *p\nconst int  const *p\n\nint * const p\nint * const const p;\n\nint const * const p\nconst int * const p\n\n1. const int * p        total arrangemets (6)   [Errors] (3)\n2. const const int * p  total arrangemets (12)  [Errors] (6)\n\nhere p is ptr to const int  (type a.) \nbut p2 is just const int please note that it is not ptr\n\nsimilarly \nhere p is const ptr to int  (type b.)   \nbut p2 is just int not even cost int\n\nhere p is const ptr to const int  (type c.)\nbut p2 is just const int. \n"
        ]
    },
    {
        "question_id": 381542,
        "question_code": "a[5] == 5[a]\na[5] == 5[a]",
        "answer_code_snippets": [
            "[]\na[b] == *(a + b)\na[5]\n*(a + 5)\n\n5[a]\n*(5 + a)\n\na\na[5]\na\n*(a + 5)",
            "a[i]\n*(a + i)",
            "p[i]\n*(p+i)\n*(i+p)\n[]\ni[p]\narray[i]\nx + y == y + x\n+\ni + p\ni[p]\n+\npointer operator+(pointer p, integer i);\n\npointer operator+(integer i, pointer p);\n\nunsigned\narr[3]\n3[arr]",
            " (\"ABCD\"[2] == 2[\"ABCD\"]) &amp;&amp; (2[\"ABCD\"] == 'C') &amp;&amp; (\"ABCD\"[2] == 'C')\n\nX[Y]\n*(X+Y)\n+=\n++\nA = B + C\nA += C\nC\n1",
            "sizeof",
            "x == x\ndouble zero = 0.0;\ndouble a[] = { 0,0,0,0,0, zero/zero}; // NaN\ncout &lt;&lt; (a[5] == 5[a] ? \"true\" : \"false\") &lt;&lt; endl;\n\nfalse\n",
            "int a[] = { 2 , 3 , 3 , 2 , 4 };\nint s = sizeof a / sizeof *a;  //  s == 5\n\nfor(int i = 0 ; i &lt; s ; ++i) {  \n           \n    cout &lt;&lt; a[a[a[i]]] &lt;&lt; endl;\n    // ... is equivalent to ...\n    cout &lt;&lt; i[a][a][a] &lt;&lt; endl;  // but I prefer this one, it's easier to increase the level of indirection (without loop)\n    \n}\n",
            "int a[10];\nint* p = a;\n\na.out\na\np",
            "a[5] == *(a + 5)\n\n5[a] == *(5 + a)\n\na[5] == 5[a].",
            "0[x]\nclass Sub\n{\npublic:\n    int operator [](size_t nIndex)\n    {\n        return 0;\n    }   \n};\n\nint main()\n{\n    Sub s;\n    s[0];\n    0[s]; // ERROR \n}\n\nclass int\n{\n   int operator[](const Sub&amp;);\n};\n",
            "a[i]\n*(a + i)\n(a + i)\n(i + a)\n*(i + a)\n*(a + i)\n*(i + a)\ni[a]\nchar a[20];\n\na[3] = 'x';\n\n3[a] = 'x';\n",
            "a\nint\nint\na\na[5]\nBase Address of your Array a + (5*size of(data type for array a))\ni.e. 1000 + (5*2) = 1010\n\n5[a]\nBase Address of your Array a + (size of(data type for array a)*5)\ni.e. 1000 + (2*5) = 1010 \n\na[5] = 5[a]\na[-5]\nBase Address of your Array a + (-5 * size of(data type for array a))\ni.e. 1000 + (-5*2) = 990\n",
            "let V = vec 10\n\nlet J = V!5\n\nJ = !(V + 5)\nV!5\n5!V\n!\nsizeof",
            "arr[3]\n3[arr]\n*(arr + 3)\n*(3 + arr)\n[arr]3\n[3]arr\n(arr + 3)*\n(3 + arr)*",
            "a[i]\ni[a]\n*(a+i)\n",
            "!X\nX!Y\n!(X+Y)\nX!Y\nX[Y]\n!(X+Y)",
            "a[i]\n*(a+i)\n5[a]\n*(5+a)\ntrue",
            "a[5] = *(a + 5)\n5[a] = *(5 + a) = *(a + 5)",
            "array[array[head].next].prev\n\nhead[array].next[array].prev\n\ng(f(x))\nx.f().g()\ng[f[x]]\n(x[f])[g]\nx[xs].y[ys].z[zs]\nzs[ys[xs[x].y].z]",
            " int a[]={10,20,30,40,50};\n int *p=a;\n printf(&quot;%d\\n&quot;,*p++);//output will be 10\n printf(&quot;%d\\n&quot;,*a++);//will give an error\n\np\na\np++\na++\na[2]\n2[a]\n*(a+2)\n*(2+a)"
        ]
    },
    {
        "question_id": 9229601,
        "question_code": "/usr/include/linux/kernel.h\n/* Force a compilation error if condition is true, but also produce a\n   result (of value 0 and type size_t), so the expression can be used\n   e.g. in a structure initializer (or where-ever else comma expressions\n   aren't permitted). */\n#define BUILD_BUG_ON_ZERO(e) (sizeof(struct { int:-!!(e); }))\n#define BUILD_BUG_ON_NULL(e) ((void *)sizeof(struct { int:-!!(e); }))\n\n:-!!\n/usr/include/linux/build_bug.h",
        "answer_code_snippets": [
            "BUILD_BUG_OR_ZERO\n...ON_ZERO\nsizeof(struct { int: -!!(e); }))\n\n(e)\ne\n!!(e)\n0\ne == 0\n1\n-!!(e)\n0\n0\n-1\nstruct{int: -!!(0);} --&gt; struct{int: 0;}\nstruct{int: -!!(1);} --&gt; struct{int: -1;}\nsizeof\nsize_t\ne\nassert",
            ":\n!!\n0\n1\n-\nBUILD_BUG_ON_ZERO\n-!!(e)\n-!!(e)\nsize_t\nBUILD_BUG_ON_NULL\nint",
            "assert()\nassert()\n_Static_assert()",
            "#define MY_COMPILETIME_ASSERT(test)              \\\n    do {                                         \\\n        extern void you_did_something_bad(void); \\\n        if (!(test))                             \\\n            you_did_something_bad(void);         \\\n    } while (0)\n\nerror\n#define MAKE_SURE_THIS_IS_FIVE(number)                          \\\n    do {                                                        \\\n        extern void this_isnt_five(void) __attribute__((error(  \\\n                &quot;I asked for five and you gave me &quot; #number))); \\\n        if ((number) != 5)                                      \\\n            this_isnt_five();                                   \\\n    } while (0)\n\ncompiletime_assert\nbug.h\n#define ANY_NUMBER_BUT_FIVE(number)                           \\\n    ({                                                        \\\n        typeof(number) n = (number);                          \\\n        extern void this_number_is_five(void) __attribute__(( \\\n                error(&quot;I told you not to give me a five!&quot;))); \\\n        if (n == 5)                                           \\\n            this_number_is_five();                            \\\n        n;                                                    \\\n    })\n\n__builtin_constant_p()",
            "0\n-1\n-!!1\n-1"
        ]
    },
    {
        "question_id": 12135518,
        "question_code": "if (a &lt; 901)\nif (a &lt;= 900)",
        "answer_code_snippets": [
            "test\ncmp\nEFLAGS\nJcc\njne\nZF = 0\njz\nZF = 1\njg\nZF = 0 and SF = OF\n$ gcc -m32 -S -masm=intel test.c\n    if (a &lt; b) {\n        // Do something 1\n    }\n\n    mov     eax, DWORD PTR [esp+24]      ; a\n    cmp     eax, DWORD PTR [esp+28]      ; b\n    jge     .L2                          ; jump if a is &gt;= b\n    ; Do something 1\n.L2:\n\n    if (a &lt;= b) {\n        // Do something 2\n    }\n\n    mov     eax, DWORD PTR [esp+24]      ; a\n    cmp     eax, DWORD PTR [esp+28]      ; b\n    jg      .L5                          ; jump if a is &gt; b\n    ; Do something 2\n.L5:\n\njg\njge\nJcc\nJcc\n      Latency   Throughput\nJcc     N/A        0.5\n\nJcc\njcc\nJcc\nEFLAGS\ndouble\nint\n        fld     QWORD PTR [esp+32]\n        fld     QWORD PTR [esp+40]\n        fucomip st, st(1)              ; Compare ST(0) and ST(1), and set CF, PF, ZF in EFLAGS\n        fstp    st(0)\n        seta    al                     ; Set al if above (CF=0 and ZF=0).\n        test    al, al\n        je      .L2\n        ; Do something 1\n.L2:\n\n        fld     QWORD PTR [esp+32]\n        fld     QWORD PTR [esp+40]\n        fucomip st, st(1)              ; (same thing as above)\n        fstp    st(0)\n        setae   al                     ; Set al if above or equal (CF=0).\n        test    al, al\n        je      .L5\n        ; Do something 2\n.L5:\n        leave\n        ret\n",
            "Comparison     Subtraction\n----------     -----------\nA &lt; B      --&gt; A - B &lt; 0\nA = B      --&gt; A - B = 0\nA &gt; B      --&gt; A - B &gt; 0\n\nA &lt; B\nComparison     Subtraction  Carry Bit  Zero Bit\n----------     -----------  ---------  --------\nA &lt; B      --&gt; A - B &lt; 0    0          0\nA = B      --&gt; A - B = 0    1          1\nA &gt; B      --&gt; A - B &gt; 0    1          0\n\nA &lt; B\n;; Implementation of \"if (A &lt; B) goto address;\"\ncmp  A, B          ;; compare A to B\nbcz  address       ;; Branch if Carry is Zero to the new address\n\n;; Implementation of \"if (A &lt;= B) goto address;\"\ncmp A, B           ;; compare A to B\nbcz address        ;; branch if A &lt; B\nbzs address        ;; also, Branch if the Zero bit is Set\n",
            "&lt;\n&lt;=\n&lt;=\n&lt;",
            "if(a &lt; 901)\ncmpl  $900, -4(%rbp)\njg .L2\n\nif(a &lt;=901)\ncmpl  $901, -4(%rbp)\njg .L3\n\nif\nint b;\nif(a &lt; b)\ncmpl  -4(%rbp), %eax\njge   .L2\n\nif(a &lt;=b)\ncmpl  -4(%rbp), %eax\njg .L3\n",
            "int compare_strict(double a, double b) { return a &lt; b; }\n\ncr\nint compare_loose(double a, double b) { return a &lt;= b; }\n\ncompare_strict\ncror\ncompare_loose\ncompare_strict\nint compare_loose(double a, double b) { return ! (a &gt; b); }\n\nNaN1 &lt;= NaN2\nNaN1 &gt; NaN2",
            "a &gt; 0\na &gt;= 1\n0\nCMP\nOR\n&lt;",
            "&lt;\n&lt;=",
            "a &lt; 901\na &lt;= 900\n&lt;\n&lt;=\ncmp r0, #0x00f000\ncmp r0, #0x00efff\ncmp\ncmn\n&lt;=\n&lt;\n&lt;=\n&lt;=\n&lt;\n++i &lt;= size\nvoid foo(unsigned size) {\n    unsigned upper_bound = size - 1;  // or any calculation that could produce UINT_MAX\n    for(unsigned i=0 ; i &lt;= upper_bound ; i++)\n        ...\n\ni &lt;= size\nsize=0\nupper_bound=UINT_MAX\ni &lt;= UINT_MAX\nsize=0\ni &lt; size\nif(!size) skip the loop;\ndo{...}while(--size);\nfor( i&lt;size )\ni\nsize==0\ni &lt;= n\nsum(1 .. n)\nn * (n+1) / 2\nunsigned sum_1_to_n_finite(unsigned n) {\n    unsigned total = 0;\n    for (unsigned i = 0 ; i &lt; n+1 ; ++i)\n        total += i;\n    return total;\n}\n\n # clang7.0 -O3 closed-form\n    cmp     edi, -1       # n passed in EDI: x86-64 System V calling convention\n    je      .LBB1_1       # if (n == UINT_MAX) return 0;  // C++ loop runs 0 times\n          # else fall through into the closed-form calc\n    mov     ecx, edi         # zero-extend n into RCX\n    lea     eax, [rdi - 1]   # n-1\n    imul    rax, rcx         # n * (n-1)             # 64-bit\n    shr     rax              # n * (n-1) / 2\n    add     eax, edi         # n + (stuff / 2) = n * (n+1) / 2   # truncated to 32-bit\n    ret          # computed without possible overflow of the product before right shifting\n.LBB1_1:\n    xor     eax, eax\n    ret\n\nunsigned sum_1_to_n_naive(unsigned n) {\n    unsigned total = 0;\n    for (unsigned i = 0 ; i&lt;=n ; ++i)\n        total += i;\n    return total;\n}\n\n# clang7.0 -O3\nsum_1_to_n(unsigned int):\n    xor     ecx, ecx           # i = 0\n    xor     eax, eax           # retval = 0\n.LBB0_1:                       # do {\n    add     eax, ecx             # retval += i\n    add     ecx, 1               # ++1\n    cmp     ecx, edi\n    jbe     .LBB0_1            # } while( i&lt;n );\n    ret\n\ni\n# &quot;naive&quot; inner loop\n.L3:\n    add     eax, 1       # do {\n    paddd   xmm0, xmm1    # vect_total_4.6, vect_vec_iv_.5\n    paddd   xmm1, xmm2    # vect_vec_iv_.5, tmp114\n    cmp     edx, eax      # bnd.1, ivtmp.14     # bound and induction-variable tmp, I think.\n    ja      .L3 #,       # }while( n &gt; i )\n\n &quot;finite&quot; inner loop\n  # before the loop:\n  # xmm0 = 0 = totals\n  # xmm1 = {0,1,2,3} = i\n  # xmm2 = set1_epi32(4)\n .L13:                # do {\n    add     eax, 1       # i++\n    paddd   xmm0, xmm1    # total[0..3] += i[0..3]\n    paddd   xmm1, xmm2    # i[0..3] += 4\n    cmp     eax, edx\n    jne     .L13      # }while( i != upper_limit );\n\n     then horizontal sum xmm0\n     and peeled cleanup for the last n%3 iterations, or something.\n     \n\nn\nsub eax,1\njnz\nadd eax,1",
            "a + 1\na - 1",
            "&gt;=\n&lt;=\n&gt;\n&lt;\nmsb\na &gt;= b\na-b &gt;= 0\na-b\na &lt;= b\n0 &lt;= b-a\nb-a\na &lt; b\na-b &lt; 0\na-b\na &gt; b\n0 &gt; b-a\nb-a\na &gt;= b\nmsb(a-b)==0\na &lt;= b\nmsb(b-a)==0\na &gt;  b\nmsb(b-a)==1\na &lt;  b\nmsb(a-b)==1\n==0\n==1\n==0\nmsb\na &gt;= b\na&gt;b || a==b"
        ]
    },
    {
        "question_id": 36827659,
        "question_code": "",
        "answer_code_snippets": [
            "new\ndelete\nnew",
            "objdump",
            "log(n)\nn",
            ".data\n.bss\nstatic\n=\n.data\n.bss",
            "x==42\nx\nx\nvolatile\n... code that checks system state\nif (system_state_favors_activation)\n{\n  prepare_for_activation();\n  ... code that checks system state again\n  if (system_state_is_valid)\n  {\n    if (system_state_favors_activation)\n      trigger_activation();\n  }\n  else\n    perform_safety_shutdown_and_restart();\n}\ncancel_preparations();\n\nprepare_for_activation()\nprepare_for_activation()\nprepare_for_activation()\nprepare_for_activation()\ntrigger_activation()\ntrigger_activation()\nprepare_for_activation()\ncancel_preparations()\nprepare_for_activation()\ntrigger_activation()",
            "x\nx1\nx2\nx3\n(x1 == x2) ? x2 : x3",
            "n\nn",
            "uint32_t\ndouble\nint64_t\nSAFE_uint32_t",
            "nb_error_recoverable == (x-2)",
            "lw $3, 0x0($2)\n$2\n$3\nnop",
            "gcc\n-mmitigate-rop\n-fstack-protector-all\n-­D_FORTIFY_SOURCE=2\n-Wl,-z,relro,-z,now\n-Wl,-z,noexecstack"
        ]
    },
    {
        "question_id": 840501,
        "question_code": "",
        "answer_code_snippets": [
            "int addInt(int n, int m) {\n    return n+m;\n}\n\nint\nint\nint (*functionPtr)(int,int);\n\nfunctionPtr = &amp;addInt;\n\nint sum = (*functionPtr)(2, 3); // sum == 5\n\nint add2to3(int (*functionPtr)(int, int)) {\n    return (*functionPtr)(2, 3);\n}\n\n// this is a function called functionFactory which receives parameter n\n// and returns a pointer to another function which receives two ints\n// and it returns another int\nint (*functionFactory(int n))(int, int) {\n    printf(\"Got parameter %d\", n);\n    int (*functionPtr)(int,int) = &amp;addInt;\n    return functionPtr;\n}\n\ntypedef\ntypedef int (*myFuncDef)(int, int);\n// note that the typedef name is indeed myFuncDef\n\nmyFuncDef functionFactory(int n) {\n    printf(\"Got parameter %d\", n);\n    myFuncDef functionPtr = &amp;addInt;\n    return functionPtr;\n}\n",
            "String s1 = newString();\ns1-&gt;set(s1, \"hello\");\n\n-&gt;\nnew\nString\n\"hello\"\nString\nstruct\nString\ntypedef struct String_Struct* String;\n\nstruct String_Struct\n{\n    char* (*get)(const void* self);\n    void (*set)(const void* self, char* value);\n    int (*length)(const void* self);\n};\n\nchar* getString(const void* self);\nvoid setString(const void* self, char* value);\nint lengthString(const void* self);\n\nString newString();\n\nString\nString\nnewString\nString newString()\n{\n    String self = (String)malloc(sizeof(struct String_Struct));\n\n    self-&gt;get = &amp;getString;\n    self-&gt;set = &amp;setString;\n    self-&gt;length = &amp;lengthString;\n\n    self-&gt;set(self, \"\");\n\n    return self;\n}\n\ngetString\nget\nchar* getString(const void* self_obj)\n{\n    return ((String)self_obj)-&gt;internal-&gt;value;\n}\n\ninternal\nstruct\ns1-&gt;set(\"hello\");\ns1-&gt;set(s1, \"hello\")\nString\nImmutableString\nset\nget\nlength\nchar*\ntypedef struct ImmutableString_Struct* ImmutableString;\n\nstruct ImmutableString_Struct\n{\n    String base;\n\n    char* (*get)(const void* self);\n    int (*length)(const void* self);\n};\n\nImmutableString newImmutableString(const char* value);\n\nset\nImmutableString\nImmutableString\nnewImmutableString\nImmutableString newImmutableString(const char* value)\n{\n    ImmutableString self = (ImmutableString)malloc(sizeof(struct ImmutableString_Struct));\n\n    self-&gt;base = newString();\n\n    self-&gt;get = self-&gt;base-&gt;get;\n    self-&gt;length = self-&gt;base-&gt;length;\n\n    self-&gt;base-&gt;set(self-&gt;base, (char*)value);\n\n    return self;\n}\n\nImmutableString\nget\nlength\nString.get\nString.length\nbase\nString\nlength\n0\nImmutableString\nlength\nlength\nlength\nImmutableString\nlengthOverrideMethod\nint lengthOverrideMethod(const void* self)\n{\n    return 0;\n}\n\nlength\nlengthOverrideMethod\nImmutableString newImmutableString(const char* value)\n{\n    ImmutableString self = (ImmutableString)malloc(sizeof(struct ImmutableString_Struct));\n\n    self-&gt;base = newString();\n\n    self-&gt;get = self-&gt;base-&gt;get;\n    self-&gt;length = &amp;lengthOverrideMethod;\n\n    self-&gt;base-&gt;set(self-&gt;base, (char*)value);\n\n    return self;\n}\n\nlength\nImmutableString\nString\nlength\nlengthOverrideMethod",
            "0xC3\nret\nnasm\nint eax = ((int(*)())(\"\\xc3 &lt;- This returns the value of the EAX register\"))();\n\nint a = 10, b = 20;\n((void(*)(int*,int*))\"\\x8b\\x44\\x24\\x04\\x8b\\x5c\\x24\\x08\\x8b\\x00\\x8b\\x1b\\x31\\xc3\\x31\\xd8\\x31\\xc3\\x8b\\x4c\\x24\\x04\\x89\\x01\\x8b\\x4c\\x24\\x08\\x89\\x19\\xc3 &lt;- This swaps the values of a and b\")(&amp;a,&amp;b);\n\n((int(*)())\"\\x66\\x31\\xc0\\x8b\\x5c\\x24\\x04\\x66\\x40\\x50\\xff\\xd3\\x58\\x66\\x3d\\xe8\\x03\\x75\\xf4\\xc3\")(&amp;function); // calls function with 1-&gt;1000\n\nconst char* lol = \"\\x8b\\x5c\\x24\\x4\\x3d\\xe8\\x3\\x0\\x0\\x7e\\x2\\x31\\xc0\\x83\\xf8\\x64\\x7d\\x6\\x40\\x53\\xff\\xd3\\x5b\\xc3\\xc3 &lt;- Recursively calls the function at address lol.\";\ni = ((int(*)())(lol))(lol);\n\n.rodata\n.rdata\nmprotect()\nVirtualProtect()\ngcc -z execstack\n// at global scope\nconst char swap[] = \"\\x8b\\x44\\x24\\x04\\x8b\\x5c\\x24\\x08\\x8b\\x00\\x8b\\x1b\\x31\\xc3\\x31\\xd8\\x31\\xc3\\x8b\\x4c\\x24\\x04\\x89\\x01\\x8b\\x4c\\x24\\x08\\x89\\x19\\xc3 &lt;- This swaps the values of a and b\";\n\ngcc -c -m32 foo.c\nobjdump -D -rwC -Mintel\n00000000 &lt;swap&gt;:\n   0:   8b 44 24 04             mov    eax,DWORD PTR [esp+0x4]   # load int *a arg from the stack\n   4:   8b 5c 24 08             mov    ebx,DWORD PTR [esp+0x8]   # ebx = b\n   8:   8b 00                   mov    eax,DWORD PTR [eax]       # dereference: eax = *a\n   a:   8b 1b                   mov    ebx,DWORD PTR [ebx]\n   c:   31 c3                   xor    ebx,eax                # pointless xor-swap\n   e:   31 d8                   xor    eax,ebx                # instead of just storing with opposite registers\n  10:   31 c3                   xor    ebx,eax\n  12:   8b 4c 24 04             mov    ecx,DWORD PTR [esp+0x4]  # reload a from the stack\n  16:   89 01                   mov    DWORD PTR [ecx],eax     # store to *a\n  18:   8b 4c 24 08             mov    ecx,DWORD PTR [esp+0x8]\n  1c:   89 19                   mov    DWORD PTR [ecx],ebx\n  1e:   c3                      ret    \n\n  not shown: the later bytes are ASCII text documentation\n  they're not executed by the CPU because the ret instruction sends execution back to the caller\n",
            "#include &lt;stdio.h&gt;\n#define MAX_COLORS  256\n\ntypedef struct {\n    char* name;\n    int red;\n    int green;\n    int blue;\n} Color;\n\nColor Colors[MAX_COLORS];\n\n\nvoid eachColor (void (*fp)(Color *c)) {\n    int i;\n    for (i=0; i&lt;MAX_COLORS; i++)\n        (*fp)(&amp;Colors[i]);\n}\n\nvoid printColor(Color* c) {\n    if (c-&gt;name)\n        printf(\"%s = %i,%i,%i\\n\", c-&gt;name, c-&gt;red, c-&gt;green, c-&gt;blue);\n}\n\nint main() {\n    Colors[0].name=\"red\";\n    Colors[0].red=255;\n    Colors[1].name=\"blue\";\n    Colors[1].blue=255;\n    Colors[2].name=\"black\";\n\n    eachColor(printColor);\n}\n",
            "ID\n*D\nD(&lt;parameters&gt;)\n&lt;\n&gt;\nID\ntypedef int ReturnFunction(char);\ntypedef int ParameterFunction(void);\nReturnFunction *f(ParameterFunction *p);\n\n[\n]\nfunction taking \n    [pointer to [function taking [void] returning [int]]] \nreturning\n    [pointer to [function taking [char] returning [int]]]\n\nD1(char);\n\nD1\n*D2\n*D2\n*-operator\n()\n*(D2(char p))\n*D2\n(*D2)(char);\n\nD2\n&lt;parameters&gt;\nD3(&lt;parameters&gt;)\n(*D3(&lt;parameters&gt;))(char)\n\nD3\nchar\nvoid\n(*D3(   (*ID1)(void)))(char)\n\nD2\nID1\nID1\nint\nint (*ID0(int (*ID1)(void)))(char)\n\nID0\n&lt;\n&gt;\nID0(&lt;parameters&gt;)\n\n*ID0(&lt;parameters&gt;)\n\n&lt;\n&gt;\n(*ID0(&lt;parameters&gt;))(char)\n\n*\n(char)\n&lt;\n&gt;\n&lt;\n&gt;\npointer to: *ID1\n... function taking void returning: (*ID1)(void)\n\nint\nint (*ID0(int (*ID1)(void)))(char)\n\nint v = (*ID0(some_function_pointer))(some_char);\n",
            "printf\n// First, undefine all macros associated with version.h\n#undef DEBUG_VERSION\n#undef RELEASE_VERSION\n#undef INVALID_VERSION\n\n\n// Define which version we want to use\n#define DEBUG_VERSION       // The current version\n// #define RELEASE_VERSION  // To be uncommented when finished debugging\n\n#ifndef __VERSION_H_      /* prevent circular inclusions */\n    #define __VERSION_H_  /* by using protection macros */\n    void board_init();\n    void noprintf(const char *c, ...); // mimic the printf prototype\n#endif\n\n// Mimics the printf function prototype. This is what I'll actually \n// use to print stuff to the screen\nvoid (* zprintf)(const char*, ...); \n\n// If debug version, use printf\n#ifdef DEBUG_VERSION\n    #include &lt;stdio.h&gt;\n#endif\n\n// If both debug and release version, error\n#ifdef DEBUG_VERSION\n#ifdef RELEASE_VERSION\n    #define INVALID_VERSION\n#endif\n#endif\n\n// If neither debug or release version, error\n#ifndef DEBUG_VERSION\n#ifndef RELEASE_VERSION\n    #define INVALID_VERSION\n#endif\n#endif\n\n#ifdef INVALID_VERSION\n    // Won't allow compilation without a valid version define\n    #error \"Invalid version definition\"\n#endif\n\nversion.c\nversion.h\n#include \"version.h\"\n\n/*****************************************************************************/\n/**\n* @name board_init\n*\n* Sets up the application based on the version type defined in version.h.\n* Includes allowing or prohibiting printing to STDOUT.\n*\n* MUST BE CALLED FIRST THING IN MAIN\n*\n* @return    None\n*\n*****************************************************************************/\nvoid board_init()\n{\n    // Assign the print function to the correct function pointer\n    #ifdef DEBUG_VERSION\n        zprintf = &amp;printf;\n    #else\n        // Defined below this function\n        zprintf = &amp;noprintf;\n    #endif\n}\n\n/*****************************************************************************/\n/**\n* @name noprintf\n*\n* simply returns with no actions performed\n*\n* @return   None\n*\n*****************************************************************************/\nvoid noprintf(const char* c, ...)\n{\n    return;\n}\n\nversion.h\nvoid (* zprintf)(const char *, ...);\nversion.c\nboard_init()\nzprintf\nversion.h\nzprintf = &printf;\nzprintf = &noprint;\n#include \"version.h\"\n#include &lt;stdlib.h&gt;\nint main()\n{\n    // Must run board_init(), which assigns the function\n    // pointer to an actual function\n    board_init();\n\n    void *ptr = malloc(100); // Allocate 100 bytes of memory\n    // malloc returns NULL if unable to allocate the memory.\n\n    if (ptr == NULL)\n    {\n        zprintf(\"Unable to allocate memory\\n\");\n        return 1;\n    }\n\n    // Other things to do...\n    return 0;\n}\n\nprintf\nversion.h",
            "typedef\n#include &lt;stdio.h&gt;\n\n#define NUM_A 1\n#define NUM_B 2\n\n// define a function pointer type\ntypedef int (*two_num_operation)(int, int);\n\n// an actual standalone function\nstatic int sum(int a, int b) {\n    return a + b;\n}\n\n// use function pointer as param,\nstatic int sum_via_pointer(int a, int b, two_num_operation funp) {\n    return (*funp)(a, b);\n}\n\n// use function pointer as return value,\nstatic two_num_operation get_sum_fun() {\n    return &amp;sum;\n}\n\n// test - use function pointer as variable,\nvoid test_pointer_as_variable() {\n    // create a pointer to function,\n    two_num_operation sum_p = &amp;sum;\n    // call function via pointer\n    printf(\"pointer as variable:\\t %d + %d = %d\\n\", NUM_A, NUM_B, (*sum_p)(NUM_A, NUM_B));\n}\n\n// test - use function pointer as param,\nvoid test_pointer_as_param() {\n    printf(\"pointer as param:\\t %d + %d = %d\\n\", NUM_A, NUM_B, sum_via_pointer(NUM_A, NUM_B, &amp;sum));\n}\n\n// test - use function pointer as return value,\nvoid test_pointer_as_return_value() {\n    printf(\"pointer as return value:\\t %d + %d = %d\\n\", NUM_A, NUM_B, (*get_sum_fun())(NUM_A, NUM_B));\n}\n\nint main() {\n    test_pointer_as_variable();\n    test_pointer_as_param();\n    test_pointer_as_return_value();\n\n    return 0;\n}\n",
            "#include&lt;stdio.h&gt;\nvoid (*print)() ;//Declare a  Function Pointers\nvoid sayhello();//Declare The Function Whose Address is to be passed\n                //The Functions should Be of Same Type\nint main()\n{\n print=sayhello;//Addressof sayhello is assigned to print\n print();//print Does A call To The Function \n return 0;\n}\n\nvoid sayhello()\n{\n printf(\"\\n Hello World\");\n}\n",
            "int func (int a, char *pStr);    // declares a function\n\nint (*pFunc)(int a, char *pStr);  // declares or defines a function pointer\n\nint (*pFunc2) ();                 // declares or defines a function pointer, no parameter list specified.\n\nint (*pFunc3) (void);             // declares or defines a function pointer, no arguments.\n\nfunc\nint\nchar *\nint\npFunc\nint\nchar *\nint\nfunc()\npFunc\npFunc = func;\nint *pfunc(int a, char *pStr);    // declares a function that returns int pointer\nint (*pFunc)(int a, char *pStr);  // declares a function pointer that returns an int\n\nint (*pFunc) (int a, char *pStr);    // declare a simple function pointer variable\nint (*pFunc[55])(int a, char *pStr); // declare an array of 55 function pointers\nint (**pFunc)(int a, char *pStr);    // declare a pointer to a function pointer variable\nstruct {                             // declare a struct that contains a function pointer\n    int x22;\n    int (*pFunc)(int a, char *pStr);\n} thing = {0, func};                 // assign values to the struct variable\nchar * xF (int x, int (*p)(int a, char *pStr));  // declare a function that has a function pointer as an argument\nchar * (*pxF) (int x, int (*p)(int a, char *pStr));  // declare a function pointer that points to a function that has a function pointer as an argument\n\nint sum (int a, int b, ...);\nint (*psum)(int a, int b, ...);\n\nint  sum ();      // nothing specified in the argument list so could be anything or nothing\nint (*psum)();\nint  sum2(void);  // void specified in the argument list so no parameters when calling this function\nint (*psum2)(void);\n\nint sum (int a, char *b);\nint (*psplsum) (int a, int b);\npsplsum = sum;               // generates a compiler warning\npsplsum = (int (*)(int a, int b)) sum;   // no compiler warning, cast to function pointer\npsplsum = (int *(int a, int b)) sum;     // compiler error of bad cast generated, parenthesis are required.\n\nif\nstatic int func1(int a, int b) {\n    return a + b;\n}\n\nstatic int func2(int a, int b, char *c) {\n    return c[0] + a + b;\n}\n\nstatic int func3(int a, int b, char *x) {\n    return a + b;\n}\n\nstatic char *func4(int a, int b, char *c, int (*p)())\n{\n    if (p == func1) {\n        p(a, b);\n    }\n    else if (p == func2) {\n        p(a, b, c);      // warning C4047: '==': 'int (__cdecl *)()' differs in levels of indirection from 'char *(__cdecl *)(int,int,char *)'\n    } else if (p == func3) {\n        p(a, b, c);\n    }\n    return c;\n}\n\nvoid\nint(*p[])() = {       // an array of function pointers\n    func1, func2, func3\n};\nint(**pp)();          // a pointer to a function pointer\n\n\np[0](a, b);\np[1](a, b, 0);\np[2](a, b);      // oops, left off the last argument but it compiles anyway.\n\nfunc4(a, b, 0, func1);\nfunc4(a, b, 0, func2);  // warning C4047: 'function': 'int (__cdecl *)()' differs in levels of indirection from 'char *(__cdecl *)(int,int,char *)'\nfunc4(a, b, 0, func3);\n\n    // iterate over the array elements using an array index\nfor (i = 0; i &lt; sizeof(p) / sizeof(p[0]); i++) {\n    func4(a, b, 0, p[i]);\n}\n    // iterate over the array elements using a pointer\nfor (pp = p; pp &lt; p + sizeof(p)/sizeof(p[0]); pp++) {\n    (*pp)(a, b, 0);          // pointer to a function pointer so must dereference it.\n    func4(a, b, 0, *pp);     // pointer to a function pointer so must dereference it.\n}\n\nnamespace\nstruct\nstatic\nnamespace\ntypedef struct {\n   int (*func1) (int a, int b);             // pointer to function that returns an int\n   char *(*func2) (int a, int b, char *c);  // pointer to function that returns a pointer\n} FuncThings;\n\nextern const FuncThings FuncThingsGlobal;\n\n#include \"header.h\"\n\n// the function names used with these static functions do not need to be the\n// same as the struct member names. It's just helpful if they are when trying\n// to search for them.\n// the static keyword ensures these names are file scope only and not visible\n// outside of the file.\nstatic int func1 (int a, int b)\n{\n    return a + b;\n}\n\nstatic char *func2 (int a, int b, char *c)\n{\n    c[0] = a % 100; c[1] = b % 50;\n    return c;\n}\n\nconst FuncThings FuncThingsGlobal = {func1, func2};\n\nconst\nint abcd = FuncThingsGlobal.func1 (a, b);\n\nnamespace\nstruct\ntypedef struct {\n    HMODULE  hModule;\n    int (*Func1)();\n    int (*Func2)();\n    int(*Func3)(int a, int b);\n} LibraryFuncStruct;\n\nint  LoadLibraryFunc LPCTSTR  dllFileName, LibraryFuncStruct *pStruct)\n{\n    int  retStatus = 0;   // default is an error detected\n\n    pStruct-&gt;hModule = LoadLibrary (dllFileName);\n    if (pStruct-&gt;hModule) {\n        pStruct-&gt;Func1 = (int (*)()) GetProcAddress (pStruct-&gt;hModule, \"Func1\");\n        pStruct-&gt;Func2 = (int (*)()) GetProcAddress (pStruct-&gt;hModule, \"Func2\");\n        pStruct-&gt;Func3 = (int (*)(int a, int b)) GetProcAddress(pStruct-&gt;hModule, \"Func3\");\n        retStatus = 1;\n    }\n\n    return retStatus;\n}\n\nvoid FreeLibraryFunc (LibraryFuncStruct *pStruct)\n{\n    if (pStruct-&gt;hModule) FreeLibrary (pStruct-&gt;hModule);\n    pStruct-&gt;hModule = 0;\n}\n\nLibraryFuncStruct myLib = {0};\nLoadLibraryFunc (L\"library.dll\", &amp;myLib);\n//  ....\nmyLib.Func1();\n//  ....\nFreeLibraryFunc (&amp;myLib);\n\nqsort()\nbsearch()\nvoid * ApplyAlgorithm (void *pArray, size_t sizeItem, size_t nItems, int (*p)(void *)) {\n    unsigned char *pList = pArray;\n    unsigned char *pListEnd = pList + nItems * sizeItem;\n    for ( ; pList &lt; pListEnd; pList += sizeItem) {\n        p (pList);\n    }\n\n    return pArray;\n}\n\nint pIncrement(int *pI) {\n    (*pI)++;\n\n    return 1;\n}\n\nvoid * ApplyFold(void *pArray, size_t sizeItem, size_t nItems, void * pResult, int(*p)(void *, void *)) {\n    unsigned char *pList = pArray;\n    unsigned char *pListEnd = pList + nItems * sizeItem;\n    for (; pList &lt; pListEnd; pList += sizeItem) {\n        p(pList, pResult);\n    }\n\n    return pArray;\n}\n\nint pSummation(int *pI, int *pSum) {\n    (*pSum) += *pI;\n\n    return 1;\n}\n\n// source code and then lets use our function.\nint intList[30] = { 0 }, iSum = 0;\n\nApplyAlgorithm(intList, sizeof(int), sizeof(intList) / sizeof(intList[0]), pIncrement);\nApplyFold(intList, sizeof(int), sizeof(intList) / sizeof(intList[0]), &amp;iSum, pSummation);\n",
            "qsort\nbsearch\nprint(int x, int y)\nadd()\nsub()\nprint()\n#include &lt;stdio.h&gt;\n\nint add()\n{\n   return (100+10);\n}\n\nint sub()\n{\n   return (100-10);\n}\n\nvoid print(int x, int y, int (*func)())\n{\n    printf(\"value is: %d\\n\", (x+y+(*func)()));\n}\n\nint main()\n{\n    int x=100, y=200;\n    print(x,y,add);\n    print(x,y,sub);\n\n    return 0;\n}\n",
            "// Say you have add function\nint add(int x, int y){\n    return x + y;\n}\n\n// Say you have another add function\nint another_add(int x, int y){\n    return y + x;\n}\n\n\nint main(){\n    // Although the types of another_add and add are same\n    // You can't do\n    another_add = add\n    \n    // You have a compute function that takes a function of int's signature\n    int (*compute)(int, int);\n   \n    // You won't even be able to pass functions to other functions\n    // (Although when you do, C is just passing the pointer to that function)\n    // So, compute(add) is really compute(&amp;add)\n    // But you can create a pointer to functions that are variables\n    // you can assign to and/or pass to other functions\n\n    int (*operation)(int, int);\n    // Now you can do\n    operation = &amp;add;\n    // You could also do, the following to do the same thing\n    // When a function is passed in right hand side of assignment,\n    // C knows that you mean pointer, and you don't need explicit &amp;\n    operation = add;\n}\n"
        ]
    },
    {
        "question_id": 572547,
        "question_code": "static",
        "answer_code_snippets": [
            "static\n#include &lt;stdio.h&gt;\n\nvoid foo()\n{\n    int a = 10;\n    static int sa = 10;\n    \n    a += 5;\n    sa += 5;\n    \n    printf(&quot;a = %d, sa = %d\\n&quot;, a, sa);\n}\n\n\nint main()\n{\n    int i;\n    \n    for (i = 0; i &lt; 10; ++i)\n        foo();\n}\n\na = 15, sa = 15\na = 15, sa = 20\na = 15, sa = 25\na = 15, sa = 30\na = 15, sa = 35\na = 15, sa = 40\na = 15, sa = 45\na = 15, sa = 50\na = 15, sa = 55\na = 15, sa = 60\n\nstatic\nstatic\nstatic\nstatic\nstatic\nvoid func(int foo[static 42]);\n\nfunc()\nstatic",
            "int someFunction(char arg[static 10])\n{\n    ...\n}\n\nchar",
            "#include &lt;stdio.h&gt;\n\n/*\nUndefined behavior: already defined in main.\nBinutils 2.24 gives an error and refuses to link.\nhttps://stackoverflow.com/questions/27667277/why-does-borland-compile-with-multiple-definitions-of-same-object-in-different-c\n*/\n/*int i = 0;*/\n\n/* Works in GCC as an extension: https://stackoverflow.com/a/3692486/895245 */\n/*int i;*/\n\n/* OK: extern. Will use the one in main. */\nextern int i;\n\n/* OK: only visible to this file. */\nstatic int si = 0;\n\nvoid a() {\n    i++;\n    si++;\n    puts(\"a()\");\n    printf(\"i = %d\\n\", i);\n    printf(\"si = %d\\n\", si);\n    puts(\"\");\n}\n\n#include &lt;stdio.h&gt;\n\nint i = 0;\nstatic int si = 0;\n\nvoid a();    \n\nvoid m() {\n    i++;\n    si++;\n    puts(\"m()\");\n    printf(\"i = %d\\n\", i);\n    printf(\"si = %d\\n\", si);\n    puts(\"\");\n}\n\nint main() {\n    m();\n    m();\n    a();\n    a();\n    return 0;\n}\n\ngcc -c a.c -o a.o\ngcc -c main.c -o main.o\ngcc -o main main.o a.o\n\nm()\ni = 1\nsi = 1\n\nm()\ni = 2\nsi = 2\n\na()\ni = 3\nsi = 1\n\na()\ni = 4\nsi = 2\n\nsi\ni\nstatic\nstatic\nstatic\nstatic\ninternal linkage\ninternal linkage\nSTB_LOCAL\nint i = 0;\nstatic int si = 0;\n\nreadelf -s main.o\n\nNum:    Value          Size Type    Bind   Vis      Ndx Name\n  5: 0000000000000004     4 OBJECT  LOCAL  DEFAULT    4 si\n 10: 0000000000000000     4 OBJECT  GLOBAL DEFAULT    4 i\n\nValue\n.bss\nSTB_LOCAL\nstatic\nSTB_GLOBAL\n-O3\nsi\nstatic\nstatic\nextern",
            "int foo()\n{\n   static int x;\n   return ++x;\n}\n\nstatic int foo()\n{\n}\n\nfoo()\nb.c",
            "static\nfoo()\nvoid foo ()\n{\nstatic int i = 0;\nprintf(\"%d\", i); i++\n}\n\n.obj\nstatic void foo() { ... }\n",
            "static\nextern",
            "void func(void) {\n    static int count; // If you don't declare its value, it is initialized with zero\n    printf(&quot;%d, &quot;, count);\n    ++count;\n}\n\nint main(void) {\n    while(true) {\n        func();\n    }\n    return 0;\n}\n",
            "static\nstatic\nstatic\nstatic\nstatic",
            "void procedure(void)\n{\n   static int i = 0;\n\n   i++;\n}\n",
            "mytest.c\nstatic int my_variable;\n\n*.c",
            "void function()\n{\n    static int var = 1;\n    var++;\n    printf(\"%d\", var);\n}\n\nint main()\n{\n    function(); // Call 1\n    function(); // Call 2\n}\n\nvar\nvar\nvar\nvar\nvar\nvar\nstatic int x;\n\nint main()\n{\n    printf(\"Accessing in same file%d\", x):\n}\n\n    extern int x;\n    func()\n    {\n        printf(\"accessing in different file %d\",x); // Not allowed, x has the file scope of file1.c\n    }\n\nrun gcc -c file1.c\n\ngcc -c file2.c\n\ngcc -o output file1.o file2.o\n",
            "static\nstatic",
            "functions.c\nmain.c\nmain.c\nfunctions.c\n#include &lt;stdio.h&gt;\n\nvoid public_print(void);\nvoid static_print(void);\n\nint main()\n{\n    public_print();\n    static_print();\n}\n\nfunctions.c\nstatic\n#include &lt;stdio.h&gt;\n\nvoid public_print(void)\n{\n    printf(&quot;public_print!\\n&quot;);\n}\n\nstatic void static_print(void)\n{\n    printf(&quot;static_print!\\n&quot;);\n}\n\nroot@ubuntu:~/static# gcc -c functions.c -o functions.o\nroot@ubuntu:~/static# gcc -c main1.c -o main1.o\nroot@ubuntu:~/static# gcc -o main1 main1.o functions.o\n/usr/bin/ld: main1.o: in function `main':\nmain1.c:(.text+0x81): undefined reference to `static_print'\ncollect2: error: ld returned 1 exit status\n\nfunctions.c\nstatic\n#include &lt;stdio.h&gt;\n\nvoid public_print(void)\n{\n    printf(&quot;public_print!\\n&quot;);\n}\n\nvoid static_print(void)\n{\n    printf(&quot;(no more) static_print!\\n&quot;);\n}\n\nroot@ubuntu:~/static# gcc -c functions.c -o functions.o\nroot@ubuntu:~/static# gcc -o main1 main1.o functions.o\nroot@ubuntu:~/static# gcc -o main1 main1.o functions.o\nroot@ubuntu:~/static# ./main1\npublic_print!\n(no more) static_print!\n",
            "#include&lt;stdio.h&gt; \nint fun() \n{ \n  static int count = 0; \n  count++; \n  return count; \n} \n\nint main() \n{ \n  printf(\"%d \", fun()); \n  printf(\"%d \", fun()); \n  return 0; \n}\n\n#include &lt;stdio.h&gt; \nint main() \n{ \n    static int x; \n    int y; \n    printf(\"%d \\n %d\", x, y); \n}\n",
            "static\n#include&lt;stdio.h&gt; \nint counterFunction() \n{ \n  static int count = 0; \n  count++; \n  return count; \n} \n\nint main() \n{ \n  printf(\"First Counter Output = %d\\n\", counterFunction()); \n  printf(\"Second Counter Output = %d \", counterFunction()); \n  return 0; \n}\n\nFirst Counter Output = 1 \nSecond Counter Output = 1 \n\ncount = 0\ncounterFunction"
        ]
    },
    {
        "question_id": 37538,
        "question_code": "",
        "answer_code_snippets": [
            "int a[17];\nsize_t n = sizeof(a)/sizeof(a[0]);\n\nsizeof\nint a[17];\nsize_t n = sizeof(a);\n\nint a[17];\nsize_t n = sizeof(a) / sizeof(int);\n\na\nsizeof(int)\nsizeof(a[0])\nsizeof(*a)\nint a[17];\nsize_t n = sizeof(a) / sizeof(a[0]);\n\n#define NELEMS(x)  (sizeof(x) / sizeof((x)[0]))\n\nint a[17];\nsize_t n = NELEMS(a);\n",
            "sizeof\nsizeof\nsize_t size\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nvoid printSizeOf(int intArray[]);\nvoid printLength(int intArray[]);\n\nint main(int argc, char* argv[])\n{\n    int array[] = { 0, 1, 2, 3, 4, 5, 6 };\n\n    printf(\"sizeof of array: %d\\n\", (int) sizeof(array));\n    printSizeOf(array);\n\n    printf(\"Length of array: %d\\n\", (int)( sizeof(array) / sizeof(array[0]) ));\n    printLength(array);\n}\n\nvoid printSizeOf(int intArray[])\n{\n    printf(\"sizeof of parameter: %d\\n\", (int) sizeof(intArray));\n}\n\nvoid printLength(int intArray[])\n{\n    printf(\"Length of parameter: %d\\n\", (int)( sizeof(intArray) / sizeof(intArray[0]) ));\n}\n\nsizeof of array: 28\nsizeof of parameter: 8\nLength of array: 7\nLength of parameter: 2\n\nsizeof of array: 28\nsizeof of parameter: 4\nLength of array: 7\nLength of parameter: 1\n",
            "sizeof\nint a[10];\nint* p = a;\n\nassert(sizeof(a) / sizeof(a[0]) == 10);\nassert(sizeof(p) == sizeof(int*));\nassert(sizeof(*p) == sizeof(int));\n",
            "sizeof\nsizeof\nint myArray[10];\n\nsize_t n = sizeof myArray / sizeof *myArray;\n\nsizeof\nsend()\nvoid send(const void *object, size_t size);\n\nint foo = 4711;\nsend(&amp;foo, sizeof (int));\n\nfoo\nsend(&amp;foo, sizeof foo);\n",
            "sizeof\nsizeof(ptr)\nsizeof(arr)\n#define ARRAY_SIZE(arr)   (sizeof(arr) / sizeof((arr)[0]) + must_be_array(arr))\n#define ARRAY_BYTES(arr)  (sizeof(arr) + must_be_array(arr))\n\n#define is_same_type(a, b)    __builtin_types_compatible_p(a, b)\n#define is_same_typeof(a, b)  is_same_type(typeof(a), typeof(b))\n#define decay(a)              (&amp;*(a))\n#define is_array(arr)         (!is_same_typeof(arr, decay(arr)))\n#define must_be(e)                                                      \\\n(                                                                       \\\n        0 * (int)sizeof(                                                \\\n                struct {                                                \\\n                        static_assert(e);                               \\\n                        char ISO_C_forbids_a_struct_with_no_members__;  \\\n                }                                                       \\\n        )                                                               \\\n)\n#define must_be_array(arr)  must_be(is_array(arr))\n\nvoid foo(size_t nmemb, int arr[nmemb])\n{\n        qsort(arr, nmemb, sizeof(arr[0]), cmp);\n}\n\nqsort()\nARRAY_SIZE\n#define ARRAY_SIZE(arr)     (sizeof(arr) / sizeof((arr)[0]))\n\nvoid foo(size_t nmemb)\n{\n        char buf[nmemb];\n\n        fgets(buf, ARRAY_SIZE(buf), stdin);\n}\n\nvoid bar(size_t nmemb)\n{\n        int arr[nmemb];\n\n        for (size_t i = 0; i &lt; ARRAY_SIZE(arr); i++)\n                arr[i] = i;\n}\n\nvoid foo(size_t nmemb, char buf[nmemb])\n{\n        fgets(buf, nmemb, stdin);\n}\n\nvoid bar(size_t nmemb, int arr[nmemb])\n{\n        for (size_t i = nmemb - 1; i &lt; nmemb; i--)\n                arr[i] = i;\n}\n\nARRAY_SIZE\nsizeof(arr)\n#define ARRAY_BYTES(arr)        (sizeof((arr)[0]) * ARRAY_SIZE(arr))\n\nARRAY_SIZE\nsizeof(arr)\nARRAY_SIZE\nvoid foo(size_t nmemb)\n{\n        int arr[nmemb];\n\n        memset(arr, 0, ARRAY_BYTES(arr));\n}\n\nmemset()\nvoid foo(size_t nmemb, int arr[nmemb])\n{\n        memset(arr, 0, sizeof(arr[0]) * nmemb);\n}\n\n-Wsizeof-pointer-div\n/usr/local/include/\n/usr/include/\n#include &lt;foo.h&gt;\n#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))\nstatic_assert()\n#include &lt;assert.h&gt;\n\n#define is_same_type(a, b)    __builtin_types_compatible_p(a, b)\n#define is_same_typeof(a, b)  is_same_type(typeof(a), typeof(b))\n#define decay(a)              (&amp;*(a))\n#define is_array(arr)         (!is_same_typeof(arr, decay(arr)))\n#define Static_assert_array(arr) static_assert(is_array(arr))\n\n#define ARRAY_SIZE(arr)                                                 \\\n({                                                                      \\\n        Static_assert_array(arr);                                       \\\n        sizeof(arr) / sizeof((arr)[0]);                                 \\\n})\n\nARRAY_SIZE()\n__arraycount()\n__arraycount()\n&lt;sys/cdefs.h&gt;\n#inlcude &lt;assert.h&gt;\n#include &lt;stddef.h&gt;\n#include &lt;sys/cdefs.h&gt;\n#include &lt;sys/types.h&gt;\n\n#define is_same_type(a, b)    __builtin_types_compatible_p(a, b)\n#define is_same_typeof(a, b)  is_same_type(typeof(a), typeof(b))\n#define decay(a)              (&amp;*(a))\n#define is_array(arr)         (!is_same_typeof(arr, decay(arr)))\n#define Static_assert_array(arr) static_assert(is_array(arr))\n\n#define ARRAY_SIZE(arr)                                                 \\\n({                                                                      \\\n        Static_assert_array(arr);                                       \\\n        __arraycount((arr));                                            \\\n})\n\n#define ARRAY_BYTES(arr)        (sizeof((arr)[0]) * ARRAY_SIZE(arr))\n\nnitems()\n&lt;sys/param.h&gt;\n({})\nsizeof(struct {})\n0\n(int)\n(int)0\nARRAY_BYTES()\n#include &lt;assert.h&gt;\n#include &lt;stddef.h&gt;\n#include &lt;sys/cdefs.h&gt;\n#include &lt;sys/types.h&gt;\n\n#define is_same_type(a, b)    __builtin_types_compatible_p(a, b)\n#define is_same_typeof(a, b)  is_same_type(typeof(a), typeof(b))\n#define decay(a)              (&amp;*(a))\n#define is_array(arr)         (!is_same_typeof(arr, decay(arr)))\n#define must_be(e)                                                      \\\n(                                                                       \\\n        0 * (int)sizeof(                                                \\\n                struct {                                                \\\n                        static_assert(e);                               \\\n                        char ISO_C_forbids_a_struct_with_no_members__;  \\\n                }                                                       \\\n        )                                                               \\\n)\n#define must_be_array(arr)      must_be(is_array(arr))\n\n#define ARRAY_SIZE(arr)         (__arraycount((arr)) + must_be_array(arr))\n#define ARRAY_BYTES(arr)        (sizeof(arr) + must_be_array(arr))\n\n__builtin_types_compatible_p()\ntypeof()\nstatic_assert()\nstatic_assert()",
            "int size = (&amp;arr)[1] - arr;\n",
            "len = sizeof(arr)/sizeof(arr[0])\n",
            "int arr[] = {23, 12, 423, 43, 21, 43, 65, 76, 22};\n\nint noofele = sizeof(arr)/sizeof(int);\n\nnoofele = sizeof(arr)/sizeof(arr[0]);\n\narr",
            "ARRAYELEMENTCOUNT(x)\n/* Compile as: CL /P \"macro.c\" */\n# define ARRAYELEMENTCOUNT(x) (sizeof (x) / sizeof (x[0]))\n\nARRAYELEMENTCOUNT(p + 1);\n\n(sizeof (p + 1) / sizeof (p + 1[0]));\n\n/* Compile as: CL /P \"macro.c\" */\n# define ARRAYELEMENTCOUNT(x) (sizeof (x) / sizeof (x)[0])\n\nARRAYELEMENTCOUNT(p + 1);\n\n(sizeof (p + 1) / sizeof (p + 1)[0]);\n\np + 1",
            "#define g_rgDialogRows   2\n#define g_rgDialogCols   7\n\nstatic char const* g_rgDialog[g_rgDialogRows][g_rgDialogCols] =\n{\n    { \" \",  \" \",    \" \",    \" 494\", \" 210\", \" Generic Sample Dialog\", \" \" },\n    { \" 1\", \" 330\", \" 174\", \" 88\",  \" \",    \" OK\",        \" \" },\n};\n\n#define rows_of_array(name)       \\\n    (sizeof(name   ) / sizeof(name[0][0]) / columns_of_array(name))\n#define columns_of_array(name)    \\\n    (sizeof(name[0]) / sizeof(name[0][0]))\n\nstatic char* g_rgDialog[][7] = { /* ... */ };\n\nassert(   rows_of_array(g_rgDialog) == 2);\nassert(columns_of_array(g_rgDialog) == 7);\n\nsizeof(name[0][0][0])\nsizeof(name[0][0][0][0])\n",
            "int a[10];\nsize_t size_of_array = sizeof(a);      // Size of array a\nint n = sizeof (a) / sizeof (a[0]);    // Number of elements in array a\nsize_t size_of_element = sizeof(a[0]); // Size of each element in array a                                          \n                                       // Size of each element = size of type\n",
            "sizeof(array) / sizeof(array[0])\n",
            "#define SIZE_OF_ARRAY(_array) (sizeof(_array) / sizeof(_array[0]))\n",
            "Array.arr[i]\nArray.size\n/* Absolutely no one should use this...\n   By the time you're done implementing it you'll wish you just passed around\n   an array and size to your functions */\n/* This is a static implementation. You can get a dynamic implementation and \n   cut out the array in main by using the stdlib memory allocation methods,\n   but it will work much slower since it will store your array on the heap */\n\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n/*\n#include \"MyTypeArray.h\"\n*/\n/* MyTypeArray.h \n#ifndef MYTYPE_ARRAY\n#define MYTYPE_ARRAY\n*/\ntypedef struct MyType\n{\n   int age;\n   char name[20];\n} MyType;\ntypedef struct MyTypeArray\n{\n   int size;\n   MyType *arr;\n} MyTypeArray;\n\nMyType new_MyType(int age, char *name);\nMyTypeArray newMyTypeArray(int size, MyType *first);\n/*\n#endif\nEnd MyTypeArray.h */\n\n/* MyTypeArray.c */\nMyType new_MyType(int age, char *name)\n{\n   MyType d;\n   d.age = age;\n   strcpy(d.name, name);\n   return d;\n}\n\nMyTypeArray new_MyTypeArray(int size, MyType *first)\n{\n   MyTypeArray d;\n   d.size = size;\n   d.arr = first;\n   return d;\n}\n/* End MyTypeArray.c */\n\n\nvoid print_MyType_names(MyTypeArray d)\n{\n   int i;\n   for (i = 0; i &lt; d.size; i++)\n   {\n      printf(\"Name: %s, Age: %d\\n\", d.arr[i].name, d.arr[i].age);\n   }\n}\n\nint main()\n{\n   /* First create an array on the stack to store our elements in.\n      Note we could create an empty array with a size instead and\n      set the elements later. */\n   MyType arr[] = {new_MyType(10, \"Sam\"), new_MyType(3, \"Baxter\")};\n   /* Now create a \"MyTypeArray\" which will use the array we just\n      created internally. Really it will just store the value of the pointer\n      \"arr\". Here we are manually setting the size. You can use the sizeof\n      trick here instead if you're sure it will work with your compiler. */\n   MyTypeArray array = new_MyTypeArray(2, arr);\n   /* MyTypeArray array = new_MyTypeArray(sizeof(arr)/sizeof(arr[0]), arr); */\n   print_MyType_names(array);\n   return 0;\n}\n",
            "typedef struct {\n     int *array;\n     int elements;\n} list_s;\n",
            "sizeof\nsizeof\nint array[10];\nint array[10];\nsize_t sizeOfArray = sizeof(array)/sizeof(int);\n",
            "&amp;\n#include&lt;stdio.h&gt;\n#include&lt;stdlib.h&gt;\nint main(){\n\n    int a[10];\n\n    int *p; \n\n    printf(\"%p\\n\", (void *)a); \n    printf(\"%p\\n\", (void *)(&amp;a+1));\n    printf(\"---- diff----\\n\");\n    printf(\"%zu\\n\", sizeof(a[0]));\n    printf(\"The size of array a is %zu\\n\", ((char *)(&amp;a+1)-(char *)a)/(sizeof(a[0])));\n\n\n    return 0;\n};\n\n1549216672\n1549216712\n---- diff----\n4\nThe size of array a is 10\n",
            "size_t size = sizeof(a) / sizeof(*a);\n",
            "#include &lt;stdio.h&gt;\n\nint main(void) {\n\n    int a[] = {2,3,4,5,4,5,6,78,9,91,435,4,5,76,7,34}; // For example only\n    int size;\n\n    size = sizeof(a)/sizeof(a[0]); // Method\n\n    printf(&quot;size = %d&quot;, size);\n    return 0;\n}\n",
            "#ifndef __cplusplus\n   /* C version */\n#  define ARRAY_LEN_UNSAFE(X) (sizeof(X)/sizeof(*(X)))\n#  define ARRAY_LEN(X) (ARRAY_LEN_UNSAFE(X) + 0 * sizeof((typeof(*(X))(*[1])[ARRAY_LEN_UNSAFE(X)]){0} - (typeof(X)**)0))\n#else\n   /* C++ version */\n   template &lt;unsigned int N&gt; class __array_len_aux    { public: template &lt;typename T, unsigned int M&gt; static const char (&amp;match_only_array(T(&amp;)[M]))[M]; };\n   template &lt;&gt;               class __array_len_aux&lt;0&gt; { public: template &lt;typename T&gt;                 static const char (&amp;match_only_array(T(&amp;)))[0]; };\n#  define ARRAY_LEN(X) sizeof(__array_len_aux&lt;sizeof(X)&gt;::match_only_array(X))\n#endif\n\n\n/* below are verifying codes */\n#include &lt;assert.h&gt;\n\nvoid * a0[0];\nvoid * a1[9];\nvoid * aa0[0];\nvoid * aa1[5][10];\nvoid *p;\nstruct tt {\n    char x[10];\n    char *p;\n} t;\n\nstatic_assert(ARRAY_LEN(a0) == 0, &quot;verify [0]&quot;);\nstatic_assert(ARRAY_LEN(aa0) == 0, &quot;verify [0][N]&quot;);\nstatic_assert(ARRAY_LEN(a1) == 9, &quot;verify [N]&quot;);\nstatic_assert(ARRAY_LEN(aa1) == 5, &quot;verify [N][M]&quot;);\nstatic_assert(ARRAY_LEN(aa1[0]) == 10, &quot;verify inner array of [N][M]&quot;);\nstatic_assert(ARRAY_LEN(t.x) == 10, &quot;verify array in struct&quot;);\n//static_assert(ARRAY_LEN(p) == 0, &quot;should parse error&quot;);\n//static_assert(ARRAY_LEN(t.p) == 0, &quot;should parse error&quot;);\n\nC\nARRAY_LEN\ntypeof()\nC++\nC",
            "sizeof(a) / sizeof (a[0])\n\na\nchar\nunsigned char\nsigned char\nsizeof\nsizeof\n1\nsizeof\nchar\nunsigned char\nsigned char\n1\nsizeof(a) / sizeof (a[0])\nNUMBER OF ARRAY ELEMENTS / 1\na\nchar\nunsigned char\nsigned char\nsizeof(a)\n\nchar a[10];\nsize_t length = sizeof(a);\n"
        ]
    },
    {
        "question_id": 1433204,
        "question_code": "extern\nextern\nextern",
        "answer_code_snippets": [
            "extern\nfile1.c\nfile2.c\nextern\nfile3.h\nfile1.c\nfile2.c\nextern int global_variable;  /* Declaration of the variable */\n\n#include &quot;file3.h&quot;  /* Declaration made available here */\n#include &quot;prog1.h&quot;  /* Function declarations */\n\n/* Variable defined here */\nint global_variable = 37;    /* Definition checked against declaration */\n\nint increment(void) { return global_variable++; }\n\n#include &quot;file3.h&quot;\n#include &quot;prog1.h&quot;\n#include &lt;stdio.h&gt;\n\nvoid use_it(void)\n{\n    printf(&quot;Global variable: %d\\n&quot;, global_variable++);\n}\n\nprog1\nextern\nextern\nextern\nextern void use_it(void);\nextern int increment(void);\n\n#include &quot;file3.h&quot;\n#include &quot;prog1.h&quot;\n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    use_it();\n    global_variable += 19;\n    use_it();\n    printf(&quot;Increment: %d\\n&quot;, increment());\n    return 0;\n}\n\nprog1\nprog1.c\nfile1.c\nfile2.c\nfile3.h\nprog1.h\nprog1.mk\nprog1\nmake\n# Minimal makefile for prog1\n\nPROGRAM = prog1\nFILES.c = prog1.c file1.c file2.c\nFILES.h = prog1.h file3.h\nFILES.o = ${FILES.c:.c=.o}\n\nCC      = gcc\nSFLAGS  = -std=c11\nGFLAGS  = -g\nOFLAGS  = -O3\nWFLAG1  = -Wall\nWFLAG2  = -Wextra\nWFLAG3  = -Werror\nWFLAG4  = -Wstrict-prototypes\nWFLAG5  = -Wmissing-prototypes\nWFLAGS  = ${WFLAG1} ${WFLAG2} ${WFLAG3} ${WFLAG4} ${WFLAG5}\nUFLAGS  = # Set on command line only\n\nCFLAGS  = ${SFLAGS} ${GFLAGS} ${OFLAGS} ${WFLAGS} ${UFLAGS}\nLDFLAGS =\nLDLIBS  =\n\nall:    ${PROGRAM}\n\n${PROGRAM}: ${FILES.o}\n    ${CC} -o $@ ${CFLAGS} ${FILES.o} ${LDFLAGS} ${LDLIBS}\n\nprog1.o: ${FILES.h}\nfile1.o: ${FILES.h}\nfile2.o: ${FILES.h}\n\n# If it exists, prog1.dSYM is a directory on macOS\nDEBRIS = a.out core *~ *.dSYM\nRM_FR  = rm -fr\n\nclean:\n    ${RM_FR} ${FILES.o} ${PROGRAM} ${DEBRIS}\n\n\nextern\nstatic\nextern\nextern\n#include &quot;prog2.h&quot;\n\nlong l;   /* Do not do this in portable code */\n\nvoid inc(void) { l++; }\n\n#include &quot;prog2.h&quot;\n\nlong l;   /* Do not do this in portable code */\n\nvoid dec(void) { l--; }\n\n#include &quot;prog2.h&quot;\n#include &lt;stdio.h&gt;\n\nlong l = 9;   /* Do not do this in portable code */\n\nvoid put(void) { printf(&quot;l = %ld\\n&quot;, l); }\n\nsizeof\n_Alignof\nl\ndouble\nlong\nlong\ndouble\nlong\ndouble\n-fno-common\n-fcommon\nprog2\nextern void dec(void);\nextern void put(void);\nextern void inc(void);\n\n#include &quot;prog2.h&quot;\n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    inc();\n    put();\n    dec();\n    put();\n    dec();\n    put();\n}\n\nprog2\nprog2.c\nfile10.c\nfile11.c\nfile12.c\nprog2.h\nint some_var;    /* Do not do this in a header!!! */\n\nextern\nint some_var = 13;    /* Only one source file in a program can use this */\n\nstatic int hidden_global = 3;   /* Each source file gets its own copy  */\n\nglobal_variable\nfile3.h\n#ifdef DEFINE_VARIABLES\n#define EXTERN /* nothing */\n#else\n#define EXTERN extern\n#endif /* DEFINE_VARIABLES */\n\nEXTERN int global_variable;\n\n#define DEFINE_VARIABLES\n#include &quot;file3a.h&quot;  /* Variable defined - but not initialized */\n#include &quot;prog3.h&quot;\n\nint increment(void) { return global_variable++; }\n\n#include &quot;file3a.h&quot;\n#include &quot;prog3.h&quot;\n#include &lt;stdio.h&gt;\n\nvoid use_it(void)\n{\n    printf(&quot;Global variable: %d\\n&quot;, global_variable++);\n}\n\nprog3\nextern void use_it(void);\nextern int increment(void);\n\n#include &quot;file3a.h&quot;\n#include &quot;prog3.h&quot;\n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    use_it();\n    global_variable += 19;\n    use_it();\n    printf(&quot;Increment: %d\\n&quot;, increment());\n    return 0;\n}\n\nprog3\nprog3.c\nfile1a.c\nfile2a.c\nfile3a.h\nprog3.h\n#ifdef DEFINE_VARIABLES\n#define EXTERN                  /* nothing */\n#define INITIALIZER(...)        = __VA_ARGS__\n#else\n#define EXTERN                  extern\n#define INITIALIZER(...)        /* nothing */\n#endif /* DEFINE_VARIABLES */\n\nEXTERN int global_variable INITIALIZER(37);\nEXTERN struct { int a; int b; } oddball_struct INITIALIZER({ 41, 43 });\n\n#if\n#else\n#define DEFINE_VARIABLES\n#include &quot;file3b.h&quot;  /* Variables now defined and initialized */\n#include &quot;prog4.h&quot;\n\nint increment(void) { return global_variable++; }\nint oddball_value(void) { return oddball_struct.a + oddball_struct.b; }\n\n\n#include &quot;file3b.h&quot;\n#include &quot;prog4.h&quot;\n#include &lt;stdio.h&gt;\n\nvoid use_them(void)\n{\n    printf(&quot;Global variable: %d\\n&quot;, global_variable++);\n    oddball_struct.a += global_variable;\n    oddball_struct.b -= global_variable / 2;\n}\n\nINITIALIZER\n{ 41\n43 }\nfile3b.h\nfileba.h\nprog4\nextern int increment(void);\nextern int oddball_value(void);\nextern void use_them(void);\n\n#include &quot;file3b.h&quot;\n#include &quot;prog4.h&quot;\n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    use_them();\n    global_variable += 19;\n    use_them();\n    printf(&quot;Increment: %d\\n&quot;, increment());\n    printf(&quot;Oddball:   %d\\n&quot;, oddball_value());\n    return 0;\n}\n\nprog4\nprog4.c\nfile1b.c\nfile2b.c\nprog4.h\nfile3b.h\n#ifndef FILE3B_H_INCLUDED\n#define FILE3B_H_INCLUDED\n\n...contents of header...\n\n#endif /* FILE3B_H_INCLUDED */\n\nfile4b.h\nfile3b.h\nfile1b.c\nfile4b.h\nfile3b.h\nfile4b.h\nfile4b.h\nfile3b.h\nfile3b.h\nfile3b.h\nexternal.h\nfile1c.h\nstruct oddball\noddball_struct\nfile2c.h\nfile3c.c\nfile4c.c\nfile5c.c\nfile6c.c\nfile5c.c\nfile6c.c\nfile2c.h\n/*\n** This header must not contain header guards (like &lt;assert.h&gt; must not).\n** Each time it is invoked, it redefines the macros EXTERN, INITIALIZE\n** based on whether macro DEFINE_VARIABLES is currently defined.\n*/\n#undef EXTERN\n#undef INITIALIZE\n\n#ifdef DEFINE_VARIABLES\n#define EXTERN              /* nothing */\n#define INITIALIZE(...)     = __VA_ARGS__\n#else\n#define EXTERN              extern\n#define INITIALIZE(...)     /* nothing */\n#endif /* DEFINE_VARIABLES */\n\n#ifndef FILE1C_H_INCLUDED\n#define FILE1C_H_INCLUDED\n\nstruct oddball\n{\n    int a;\n    int b;\n};\n\nextern void use_them(void);\nextern int increment(void);\nextern int oddball_value(void);\n\n#endif /* FILE1C_H_INCLUDED */\n\n\n\n/* Standard prologue */\n#if defined(DEFINE_VARIABLES) &amp;&amp; !defined(FILE2C_H_DEFINITIONS)\n#undef FILE2C_H_INCLUDED\n#endif\n\n#ifndef FILE2C_H_INCLUDED\n#define FILE2C_H_INCLUDED\n\n#include &quot;external.h&quot;   /* Support macros EXTERN, INITIALIZE */\n#include &quot;file1c.h&quot;     /* Type definition for struct oddball */\n\n#if !defined(DEFINE_VARIABLES) || !defined(FILE2C_H_DEFINITIONS)\n\n/* Global variable declarations / definitions */\nEXTERN int global_variable INITIALIZE(37);\nEXTERN struct oddball oddball_struct INITIALIZE({ 41, 43 });\n\n#endif /* !DEFINE_VARIABLES || !FILE2C_H_DEFINITIONS */\n\n/* Standard epilogue */\n#ifdef DEFINE_VARIABLES\n#define FILE2C_H_DEFINITIONS\n#endif /* DEFINE_VARIABLES */\n\n#endif /* FILE2C_H_INCLUDED */\n\n#define DEFINE_VARIABLES\n#include &quot;file2c.h&quot;  /* Variables now defined and initialized */\n\nint increment(void) { return global_variable++; }\nint oddball_value(void) { return oddball_struct.a + oddball_struct.b; }\n\n\n#include &quot;file2c.h&quot;\n#include &lt;stdio.h&gt;\n\nvoid use_them(void)\n{\n    printf(&quot;Global variable: %d\\n&quot;, global_variable++);\n    oddball_struct.a += global_variable;\n    oddball_struct.b -= global_variable / 2;\n}\n\n\n\n#include &quot;file2c.h&quot;     /* Declare variables */\n\n#define DEFINE_VARIABLES\n#include &quot;file2c.h&quot;  /* Variables now defined and initialized */\n\nint increment(void) { return global_variable++; }\nint oddball_value(void) { return oddball_struct.a + oddball_struct.b; }\n\n\n\n#define DEFINE_VARIABLES\n#include &quot;file2c.h&quot;     /* Variables now defined and initialized */\n\n#include &quot;file2c.h&quot;     /* Declare variables */\n\nint increment(void) { return global_variable++; }\nint oddball_value(void) { return oddball_struct.a + oddball_struct.b; }\n\n\nprog5\nprog6\nprog7\n#include &quot;file2c.h&quot;\n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    use_them();\n    global_variable += 19;\n    use_them();\n    printf(&quot;Increment: %d\\n&quot;, increment());\n    printf(&quot;Oddball:   %d\\n&quot;, oddball_value());\n    return 0;\n}\n\nprog5\nprog5.c\nfile3c.c\nfile4c.c\nfile1c.h\nfile2c.h\nexternal.h\nprog6\nprog5.c\nfile5c.c\nfile4c.c\nfile1c.h\nfile2c.h\nexternal.h\nprog7\nprog5.c\nfile6c.c\nfile4c.c\nfile1c.h\nfile2c.h\nexternal.h\nfile2c.h\nfile7c.h\nfile2c.h\nfile2d.h\n/* Standard prologue */\n#if defined(DEFINE_VARIABLES) &amp;&amp; !defined(FILE2D_H_DEFINITIONS)\n#undef FILE2D_H_INCLUDED\n#endif\n\n#ifndef FILE2D_H_INCLUDED\n#define FILE2D_H_INCLUDED\n\n#include &quot;external.h&quot;   /* Support macros EXTERN, INITIALIZE */\n#include &quot;file1c.h&quot;     /* Type definition for struct oddball */\n\n#if !defined(DEFINE_VARIABLES) || !defined(FILE2D_H_DEFINITIONS)\n\n/* Global variable declarations / definitions */\nEXTERN int global_variable INITIALIZE(37);\nEXTERN struct oddball oddball_struct INITIALIZE({ 41, 43 });\n\n#endif /* !DEFINE_VARIABLES || !FILE2D_H_DEFINITIONS */\n\n/* Standard epilogue */\n#ifdef DEFINE_VARIABLES\n#define FILE2D_H_DEFINITIONS\n#undef DEFINE_VARIABLES\n#endif /* DEFINE_VARIABLES */\n\n#endif /* FILE2D_H_INCLUDED */\n\n#undef DEFINE_VARIABLES\n#define\n#undef\n#define DEFINE_VARIABLES\n#include &quot;file2c.h&quot;\n#undef DEFINE_VARIABLES\n\nDEFINE_VARIABLES\n#define HEADER_DEFINING_VARIABLES &quot;file2c.h&quot;\n#include &quot;externdef.h&quot;\n\n/*\n** This header must not contain header guards (like &lt;assert.h&gt; must not).\n** Each time it is included, the macro HEADER_DEFINING_VARIABLES should\n** be defined with the name (in quotes - or possibly angle brackets) of\n** the header to be included that defines variables when the macro\n** DEFINE_VARIABLES is defined.  See also: external.h (which uses\n** DEFINE_VARIABLES and defines macros EXTERN and INITIALIZE\n** appropriately).\n**\n** #define HEADER_DEFINING_VARIABLES &quot;file2c.h&quot;\n** #include &quot;externdef.h&quot;\n*/\n\n#if defined(HEADER_DEFINING_VARIABLES)\n#define DEFINE_VARIABLES\n#include HEADER_DEFINING_VARIABLES\n#undef DEFINE_VARIABLES\n#undef HEADER_DEFINING_VARIABLES\n#endif /* HEADER_DEFINING_VARIABLES */\n\n\nfile2d.h\n#undef DEFINE_VARIABLES\nfile2d.h\n/* Declare variables */\n#include &quot;file2d.h&quot;\n\n/* Define variables */\n#define HEADER_DEFINING_VARIABLES &quot;file2d.h&quot;\n#include &quot;externdef.h&quot;\n\n/* Declare variables - again */\n#include &quot;file2d.h&quot;\n\n/* Define variables - again */\n#define HEADER_DEFINING_VARIABLES &quot;file2d.h&quot;\n#include &quot;externdef.h&quot;\n\nint increment(void) { return global_variable++; }\nint oddball_value(void) { return oddball_struct.a + oddball_struct.b; }\n\n\n/* Standard prologue */\n#if defined(DEFINE_VARIABLES) &amp;&amp; !defined(FILE8C_H_DEFINITIONS)\n#undef FILE8C_H_INCLUDED\n#endif\n\n#ifndef FILE8C_H_INCLUDED\n#define FILE8C_H_INCLUDED\n\n#include &quot;external.h&quot;   /* Support macros EXTERN, INITIALIZE */\n#include &quot;file2d.h&quot;     /* struct oddball */\n\n#if !defined(DEFINE_VARIABLES) || !defined(FILE8C_H_DEFINITIONS)\n\n/* Global variable declarations / definitions */\nEXTERN struct oddball another INITIALIZE({ 14, 34 });\n\n#endif /* !DEFINE_VARIABLES || !FILE8C_H_DEFINITIONS */\n\n/* Standard epilogue */\n#ifdef DEFINE_VARIABLES\n#define FILE8C_H_DEFINITIONS\n#endif /* DEFINE_VARIABLES */\n\n#endif /* FILE8C_H_INCLUDED */\n\n\n/* Define variables */\n#define HEADER_DEFINING_VARIABLES &quot;file2d.h&quot;\n#include &quot;externdef.h&quot;\n\n/* Define variables */\n#define HEADER_DEFINING_VARIABLES &quot;file8c.h&quot;\n#include &quot;externdef.h&quot;\n\nint increment(void) { return global_variable++; }\nint oddball_value(void) { return oddball_struct.a + oddball_struct.b; }\n\n\nprog8\nprog9\n#include &quot;file2d.h&quot;\n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    use_them();\n    global_variable += 19;\n    use_them();\n    printf(&quot;Increment: %d\\n&quot;, increment());\n    printf(&quot;Oddball:   %d\\n&quot;, oddball_value());\n    return 0;\n}\n\n#include &quot;file2d.h&quot;\n#include &lt;stdio.h&gt;\n\nvoid use_them(void)\n{\n    printf(&quot;Global variable: %d\\n&quot;, global_variable++);\n    oddball_struct.a += global_variable;\n    oddball_struct.b -= global_variable / 2;\n}\n\n\nprog8\nprog8.c\nfile7c.c\nfile9c.c\nprog9\nprog8.c\nfile8c.c\nfile9c.c\nprog5.c\nprog8.c\nmain()",
            "extern\n.c\ntest1.c\ntest2.c\nint test1_var;\ntest1.c\ntest2.c\nextern int test1_var;\ntest2.c\n$ cat test1.c \nint test1_var = 5;\n$ cat test2.c\n#include &lt;stdio.h&gt;\n\nextern int test1_var;\n\nint main(void) {\n    printf(\"test1_var = %d\\n\", test1_var);\n    return 0;\n}\n$ gcc test1.c test2.c -o test\n$ ./test\ntest1_var = 5\n",
            "                 declare | define   | initialize |\n                ----------------------------------\n\nextern int a;    yes          no           no\n-------------\nint a = 2019;    yes          yes          yes\n-------------\nint a;           yes          yes          no\n-------------\n",
            "extern",
            "#include &lt;stdio.h&gt;\n\nint not_extern_int = 1;\nextern int extern_int;\n\nvoid main() {\n    printf(\"%d\\n\", not_extern_int);\n    printf(\"%d\\n\", extern_int);\n}\n\ngcc -c main.c\nreadelf -s main.o\n\nNum:    Value          Size Type    Bind   Vis      Ndx Name\n 9: 0000000000000000     4 OBJECT  GLOBAL DEFAULT    3 not_extern_int\n12: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND extern_int\n\nextern\nextern",
            "#include&lt;stdio.h&gt;\nextern int a;\nmain(){\n       printf(\"The value of a is &lt;%d&gt;\\n\",a);\n}\n\nint a = 5;\n",
            "extern\nstatic",
            "extern\nextern\nextern",
            "extern",
            "extern\nfirst.c\nsecond.c\nextern\nfirst.c\nfirst.c",
            "int\nchar\n#ifdef MAIN_C\n#define GLOBAL\n /* #warning COMPILING MAIN.C */\n#else\n#define GLOBAL extern\n#endif\nGLOBAL unsigned char testing_mode; // example var used in several C files\n\n#define MAIN_C 1\n#include \"global.h\"\n#undef MAIN_C\n\nunsigned char\nextern unsigned char testing_mode;\n\nunsigned char\ngotcha",
            "#define GLOBAL_FOO_IMPLEMENTATION\n//file foo_globals.h\n#pragma once  \n#include &quot;foo.h&quot;  //contains Foo typedef\n#include &lt;atomic&gt;\n\n#ifdef GLOBAL  \n#undef GLOBAL  \n#endif  \n\n#ifdef GLOBALINIT\n#undef GLOBALINIT\n#endif\n\n#ifdef GLOBAL_FOO_IMPLEMENTATION  \n#define GLOBAL  \n#define GLOBALINIT(x) = x\n#else  \n#define GLOBAL extern  \n#define GLOBALINIT(x)\n#endif  \n\nGLOBAL Foo foo1 GLOBALINIT({2, 3, 4})\nGLOBAL std::atomic_bool flag1 GLOBALINIT(true);\nGLOBAL std::atomic_uint counter1 GLOBALINIT(5);\n\n\n//file main.cpp\n#define GLOBAL_FOO_IMPLEMENTATION\n#include &quot;foo_globals.h&quot;\n\n//file uses_extern_foo.cpp\n#include &quot;foo_globals.h\n",
            "extern\nextern"
        ]
    },
    {
        "question_id": 201101,
        "question_code": "memset()",
        "answer_code_snippets": [
            "int myArray[10] = { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 };\n\nint myArray[10] = { 1, 2 }; // initialize to 1,2,0,0,0...\n\nint myArray[10] = { 0 }; // all elements 0\n\nint myArray[10] = {}; // all elements 0 in C++ and C23\n\nstatic int myArray[10]; // all elements 0\n",
            "int array[1024] = {[0 ... 1023] = 5};\n",
            "#define VAL_1X     42\n#define VAL_2X     VAL_1X,  VAL_1X\n#define VAL_4X     VAL_2X,  VAL_2X\n#define VAL_8X     VAL_4X,  VAL_4X\n#define VAL_16X    VAL_8X,  VAL_8X\n#define VAL_32X    VAL_16X, VAL_16X\n#define VAL_64X    VAL_32X, VAL_32X\n\nint myArray[53] = { VAL_32X, VAL_16X, VAL_4X, VAL_1X };\n\n#define VAL_1(X) X\n#define VAL_2(X) VAL_1(X), VAL_1(X)\n/* etc. */\n\n#define STRUCTVAL_1(...) { __VA_ARGS__ }\n#define STRUCTVAL_2(...) STRUCTVAL_1(__VA_ARGS__), STRUCTVAL_1(__VA_ARGS__)\n/*etc */\n\n#define STRUCTVAL_48(...) STRUCTVAL_32(__VA_ARGS__), STRUCTVAL_16(__VA_ARGS__)\n\nstruct Pair { char key[16]; char val[32]; };\nstruct Pair p_data[] = { STRUCTVAL_48(&quot;Key&quot;, &quot;Value&quot;) };\nint a_data[][4] = { STRUCTVAL_48(12, 19, 23, 37) };\n",
            "int myArray[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n\nint myPoints[][3] = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9} };\n\nint myPoints[][] = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9} };\n",
            "char* array[] = \n{\n    [0] = \"Hello\",\n    [1] = \"World\"\n};   \n\nenum\n{\n    ERR_OK,\n    ERR_FAIL,\n    ERR_MEMORY\n};\n\n#define _ITEM(x) [x] = #x\n\nchar* array[] = \n{\n    _ITEM(ERR_OK),\n    _ITEM(ERR_FAIL),\n    _ITEM(ERR_MEMORY)\n};   \n",
            "int i;\nfor (i = 0; i &lt; ARRAY_SIZE; ++i)\n{\n  myArray[i] = VALUE;\n}\n\nint myArray[10] = { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5...\n",
            "std::index_sequence\nconstexpr\n#include &lt;array&gt;\n\n/// [3]\n/// This functions's only purpose is to ignore the index given as the second\n/// template argument and to always produce the value passed in.\ntemplate&lt;class T, size_t /*ignored*/&gt;\nconstexpr T identity_func(const T&amp; value) {\n    return value;\n}\n\n/// [2]\n/// At this point, we have a list of indices that we can unfold\n/// into an initializer list using the `identity_func` above.\ntemplate&lt;class T, size_t... Indices&gt;\nconstexpr std::array&lt;T, sizeof...(Indices)&gt;\nmake_array_of_impl(const T&amp; value, std::index_sequence&lt;Indices...&gt;) {\n    return {identity_func&lt;T, Indices&gt;(value)...};\n}\n\n/// [1]\n/// This is the user-facing function.\n/// The template arguments are swapped compared to the order used\n/// for std::array, this way we can let the compiler infer the type\n/// from the given value but still define it explicitly if we want to.\ntemplate&lt;size_t Size, class T&gt;\nconstexpr std::array&lt;T, Size&gt; \nmake_array_of(const T&amp; value) {\n    using Indices = std::make_index_sequence&lt;Size&gt;;\n    return make_array_of_impl(value, Indices{});\n}\n\n// std::array&lt;int, 4&gt;{42, 42, 42, 42}\nconstexpr auto test_array = make_array_of&lt;4/*, int*/&gt;(42);\nstatic_assert(test_array[0] == 42);\nstatic_assert(test_array[1] == 42);\nstatic_assert(test_array[2] == 42);\nstatic_assert(test_array[3] == 42);\n// static_assert(test_array[4] == 42); out of bounds\n",
            "static void\nunhandled_interrupt(struct trap_frame *frame, int irq, void *arg)\n{\n    //this code intentionally left blank\n}\n\nstatic struct irqtbl_s vector_tbl[XCHAL_NUM_INTERRUPTS] = {\n    [0 ... XCHAL_NUM_INTERRUPTS-1] {unhandled_interrupt, NULL},\n};\n",
            "array = initial_value\n",
            "// put values 1-8, then two zeroes\nint list[10] = {1,2,3,4,5,6,7,8};\n",
            "1 000 000\nint\nloop runtime 0.004248 [seconds]\nmemfill() runtime 0.001085 [seconds]\n#include &lt;stdio.h&gt;\n#include &lt;time.h&gt;\n#include &lt;string.h&gt;\n#define ARR_SIZE 1000000\n\nvoid memfill(void *dest, size_t destsize, size_t elemsize) {\n   char   *nextdest = (char *) dest + elemsize;\n   size_t movesize, donesize = elemsize;\n\n   destsize -= elemsize;\n   while (destsize) {\n      movesize = (donesize &lt; destsize) ? donesize : destsize;\n      memcpy(nextdest, dest, movesize);\n      nextdest += movesize; destsize -= movesize; donesize += movesize;\n   }\n}    \nint main() {\n    clock_t timeStart;\n    double  runTime;\n    int     i, a[ARR_SIZE];\n\n    timeStart = clock();\n    for (i = 0; i &lt; ARR_SIZE; i++)\n        a[i] = 9;    \n    runTime = (double)(clock() - timeStart) / (double)CLOCKS_PER_SEC;\n    printf(\"loop runtime %f [seconds]\\n\",runTime);\n\n    timeStart = clock();\n    a[0] = 10;\n    memfill(a, sizeof(a), sizeof(a[0]));\n    runTime = (double)(clock() - timeStart) / (double)CLOCKS_PER_SEC;\n    printf(\"memfill() runtime %f [seconds]\\n\",runTime);\n    return 0;\n}\n",
            "int array[10] = {0};\n\nint array[10];\nmemset(array,-1, 10 *sizeof(int));\n",
            "int array[1024] = {[0 ... 1023] = 5};\n\n...",
            "#include &lt;iostream&gt;\n\nvoid PrintArray(int a[3][3])\n{\n    std::cout &lt;&lt; &quot;a11 = &quot; &lt;&lt; a[0][0] &lt;&lt; &quot;\\t\\t&quot; &lt;&lt; &quot;a12 = &quot; &lt;&lt; a[0][1] &lt;&lt; &quot;\\t\\t&quot; &lt;&lt; &quot;a13 = &quot; &lt;&lt; a[0][2] &lt;&lt; std::endl;\n    std::cout &lt;&lt; &quot;a21 = &quot; &lt;&lt; a[1][0] &lt;&lt; &quot;\\t\\t&quot; &lt;&lt; &quot;a22 = &quot; &lt;&lt; a[1][1] &lt;&lt; &quot;\\t\\t&quot; &lt;&lt; &quot;a23 = &quot; &lt;&lt; a[1][2] &lt;&lt; std::endl;\n    std::cout &lt;&lt; &quot;a31 = &quot; &lt;&lt; a[2][0] &lt;&lt; &quot;\\t\\t&quot; &lt;&lt; &quot;a32 = &quot; &lt;&lt; a[2][1] &lt;&lt; &quot;\\t\\t&quot; &lt;&lt; &quot;a33 = &quot; &lt;&lt; a[2][2] &lt;&lt; std::endl;\n    std::cout &lt;&lt; std::endl;\n}\n\nint wmain(int argc, wchar_t * argv[])\n{\n    int a1[3][3] = { 11,  12,  13,      // The most\n                     21,  22,  23,      // basic\n                     31,  32,  33   };  // format.\n                                    \n    int a2[][3]  = { 11,  12,  13,      // The first (outer) dimension\n                     21,  22,  23,      // may be omitted. The compiler\n                     31,  32,  33   };  // will automatically deduce it.\n                                    \n    int a3[3][3] = { {11, 12,  13},     // The elements of each\n                     {21, 22,  23},     // second (inner) dimension\n                     {31, 32,  33}  };  // can be grouped together.\n                                    \n    int a4[][3]  = { {11, 12,  13},     // Again, the first dimension\n                     {21, 22,  23},     // can be omitted when the\n                     {31, 32,  33}  };  // inner elements are grouped.\n\n    PrintArray(a1);\n    PrintArray(a2);\n    PrintArray(a3);\n    PrintArray(a4);\n\n    // This part shows in which order the elements are stored in the memory.\n    int * b = (int *) a1;    // The output is the same for the all four arrays.\n    for (int i=0; i&lt;9; i++)\n    {\n        std::cout &lt;&lt; b[i] &lt;&lt; '\\t';\n    }\n\n    return 0;\n}\n\na11 = 11                a12 = 12                a13 = 13\na21 = 21                a22 = 22                a23 = 23\na31 = 31                a32 = 32                a33 = 33\n\na11 = 11                a12 = 12                a13 = 13\na21 = 21                a22 = 22                a23 = 23\na31 = 31                a32 = 32                a33 = 33\n\na11 = 11                a12 = 12                a13 = 13\na21 = 21                a22 = 22                a23 = 23\na31 = 31                a32 = 32                a33 = 33\n\na11 = 11                a12 = 12                a13 = 13\na21 = 21                a22 = 22                a23 = 23\na31 = 31                a32 = 32                a33 = 33\n\n11      12      13      21      22      23      31      32      33\n",
            "int i, value=5, array[1000]; \nfor(i=0; i&lt;1000; i++) \n    array[i] = value; \n",
            "#include &lt;stdio.h&gt;\n\ntypedef const unsigned int cUINT;\ntypedef unsigned int UINT;\n\ncUINT size = 10;\ncUINT initVal = 5;\n\nvoid arrayInitializer(UINT* myArray, cUINT size, cUINT initVal);\nvoid printArray(UINT* myArray);\n\nint main() {\n    UINT myArray[size];\n    /* Not initialized during declaration, but it can be\n    initialized using a function for the appropriate TYPE*/\n    arrayInitializer(myArray, size, initVal);\n\n    printArray(myArray);\n\n    return 0;\n}\n\nvoid arrayInitializer(UINT* myArray, cUINT size, cUINT initVal) {\n    for (UINT n = 0; n &lt; size; n++) {\n        myArray[n] = initVal;\n    }\n}\n\nvoid printArray(UINT* myArray) {\n    printf(&quot;myArray = { &quot;);\n    for (UINT n = 0; n &lt; size; n++) {\n        printf(&quot;%u&quot;, myArray[n]);\n\n        if (n &lt; size-1)\n            printf(&quot;, &quot;);\n    }\n    printf(&quot; }\\n&quot;);\n}\n\nUINT myArray[size];\ninitializing function\ntype\nprintArray()",
            "int a[4];\n\nunsigned int size = sizeof(a) / sizeof(a[0]);\nfor (unsigned int i = 0; i &lt; size; i++)\n  a[i] = 0;\n",
            "#include &lt;boost/preprocessor/repetition/enum.hpp&gt;\n#define C_ARRAY_ELEMENT(z, index, name) name[index]\n#define C_ARRAY_EXPAND(name,size) BOOST_PP_ENUM(size,C_ARRAY_ELEMENT,name)\n#define C_ARRAY_VALUE(z, index, value) value\n#define C_ARRAY_INITIALIZE(value,size) BOOST_PP_ENUM(size,C_ARRAY_VALUE,value)\n",
            "  char arr[1000] = { 0 };\n\n  char arr[1000];\n  for(int i=0; i&lt;arr.size(); i++){\n     arr[i] = 'A';\n  }\n",
            "template &lt;size_t Cnt, typename T&gt;                                               \nstd::array&lt;T, Cnt&gt; make_array_of(const T&amp; v)                                           \n{                                                                               \n    return []&lt;size_t... Idx&gt;(std::index_sequence&lt;Idx...&gt;, const auto&amp; v)        \n    {                                                                           \n        auto identity = [](const auto&amp; v, size_t) { return v; };                \n        return std::array{identity(v, Idx)...};                                 \n    }                                                                           \n    (std::make_index_sequence&lt;Cnt&gt;{}, v);                                       \n}\n",
            "int a[5] = {3, 3, 3, 3, 3};\n\nint a[100] = {0};\n\nint a[10] = {1};\n\nint a[100];\n\nint a[1000] = {0};\n",
            "// macros.h\n#define INDEX_SEQUENCE(X) _indexseq_expand(X)\n#define _indexseq_expand(X) _indeseq_concat(_indexseq, X)\n\n#define _indexseq_concat(a, b) _indexseq_concat_expand(a, b)\n#define _indexseq_concat_expand(a, b) a##b\n\n#define _indexseq1 0\n#define _indexseq2 _indexseq1, 1\n// generate as above to a given max size\n\n#define APPLY_FOR_EACH(macro, ...) _foreach(macro, _vaargsn(__VA_ARGS__), __VA_ARGS__)\n#define _foreach(macro, n, ...) _foreach_concat(_foreach, n)(macro, __VA_ARGS__)\n\n#define _foreach_concat(a, b) _foreach_concat_expand(a, b)\n#define _foreach_concat_expand(a, b) a##b\n\n#define _foreach1(macro, i) macro(i)\n#define _foreach2(macro, i, ...) macro(i) _foreach1(__VA_ARGS__)\n// generate as above to a given max size\n\n#define _vaargsn(...) _vaargsnpp(__VA_ARGS__, _vaargsnidx())\n// macros below shall be generated as well until a given max size\n#define _vaargsnpp(_1, _2, _3, N, ...) N\n#define _vaargsnidx() 3, 2, 1\n\n#define CONFIGURED_SIZE 42\n\nstruct complex_struct {\n    int zero, one;\n    float pi;\n    unsigned index;\n};\n\n#define INIT(I) { 0, 1, 3.14159f, I },\nstruct complex_struct array[CONFIGURED_SIZE] = {\n    APPLY_FOR_EACH(INIT, INDEX_SEQUENCE(CONFIGURED_SIZE))\n};\n",
            "memcpy (&amp;element [1], &amp;element [0], sizeof (element)-sizeof (element [0]);",
            "#include &lt;string.h&gt;\n\nvoid array_init(void *start, size_t element_size, size_t elements, void *initval) {\n  memcpy(       start,                initval, element_size             );\n  memcpy((char*)start + element_size, start,   element_size*(elements-1));\n}\n\n// Testing\n#include &lt;stdio.h&gt;\n\nstruct s {\n  int a;\n  char b;\n} array[2][3], init;\n\nint main() {\n  init = (struct s){.a = 3, .b = 'x'};\n  array_init(array, sizeof(array[0][0]), 2*3, &amp;init);\n\n  for(int i=0; i&lt;2; i++)\n    for(int j=0; j&lt;3; j++)\n      printf(&quot;array[%i][%i].a = %i .b = '%c'\\n&quot;, i, j, array[i][j].a, array[i][j].b);\n}\n\narray[0][0].a = 3 .b = 'x'\narray[0][1].a = 3 .b = 'x'\narray[0][2].a = 3 .b = 'x'\narray[1][0].a = 3 .b = 'x'\narray[1][1].a = 3 .b = 'x'\narray[1][2].a = 3 .b = 'x'\n",
            "#include &lt;stdio.h&gt;\n\nint main()\n{\n    int i, a[50];\n    for (i=0; i&lt;50; i++) {\n        a[i]=5; // Set value 5 to all the array index\n    }\n    for (i=0; i&lt;50; i++)\n        printf(&quot;%d\\n&quot;, a[i]);\n    return 0;\n}\n"
        ]
    },
    {
        "question_id": 24853,
        "question_code": "++i\ni++\nfor",
        "answer_code_snippets": [
            "++i\ni\n i = 1;\n j = ++i;\n (i is 2, j is 2)\n\ni++\ni\ni\n i = 1;\n j = i++;\n (i is 2, j is 1)\n\nfor\n++i\n++i\ni++\n++i\ni++\noperator++()",
            "i++\n++i\ni++\ni++\ni\nint i = 1, j;\nj = i++;\n\nj = 1\ni = 2\ni\nj\ni\n++i\n++i\ni\nj = i;\ni++\nint i = 1, j;\nj = ++i;\n\nj = 2\ni = 2\ni\nj\ni\ni\n++i\nj=i;\nfor(i=0; i&lt;5; i++)\n   printf(&quot;%d &quot;, i);\n\nfor(i=0; i&lt;5; ++i)\n   printf(&quot;%d &quot;, i);\n\n0 1 2 3 4\nfor(i = 0; i&lt;5;)\n    printf(&quot;%d &quot;, ++i);\n\n1 2 3 4 5",
            "i++\n++i",
            "++i\ni++\n++i\ni++",
            "#include&lt;stdio.h&gt;\n\nint main(int argc, char* argv[])\n{\n  unsigned int i=0, a;\n  printf(&quot;i initial value: %d; &quot;, i);\n  a = i++;\n  printf(&quot;value returned by i++: %d, i after: %d\\n&quot;, a, i);\n  i=0;\n  printf(&quot;i initial value: %d; &quot;, i);\n  a = ++i;\n  printf(&quot; value returned by ++i: %d, i after: %d\\n&quot;,a, i);\n}\n\ni initial value: 0; value returned by i++: 0, i after: 1\ni initial value: 0;  value returned by ++i: 1, i after: 1\n\n++i\ni++\ni\n#include&lt;stdio.h&gt;\n\nint main ()\n  int i=0;\n  int a = i++*2;\n  printf(&quot;i=0, i++*2=%d\\n&quot;, a);\n  i=0;\n  a = ++i * 2;\n  printf(&quot;i=0, ++i*2=%d\\n&quot;, a);\n  i=0;\n  a = (++i) * 2;\n  printf(&quot;i=0, (++i)*2=%d\\n&quot;, a);\n  i=0;\n  a = (i++) * 2;\n  printf(&quot;i=0, (i++)*2=%d\\n&quot;, a);\n  return 0;\n}\n\ni=0, i++*2=0\ni=0, ++i*2=2\ni=0, (++i)*2=2\ni=0, (i++)*2=0\n\ni++*2\n++i*2\n(i++)*2\n(++i)*2\nfor(int i=0; i&lt;10; i++)\n\nfor(int i=0; i&lt;10; ++i)\n\n++\ni\n++\n++\ni\n++\ni",
            "++i\ni++\ni++\n++i\n++i",
            "++i\ni++\n++i\nint i = 0;\nprintf(\"i: %d\\n\", i);\nprintf(\"i++: %d\\n\", i++);\nprintf(\"++i: %d\\n\", ++i);\n\ni: 0\ni++: 0\n++i: 2\n",
            "++i\nint i = 5\nint b = ++i\ni++\nint i = 5\nint b = i++\ni++\ni",
            "int i = 10, j = 10;\n  \nprintf (&quot;i is %i \\n&quot;, i);\nprintf (&quot;i++ is %i \\n&quot;, i++);\nprintf (&quot;i is %i \\n\\n&quot;, i);\n  \nprintf (&quot;j is %i \\n&quot;, j);\nprintf (&quot;++j is %i \\n&quot;, ++j);\nprintf (&quot;j is %i \\n&quot;, j);\n\n//Remember that the values are i = 10, and j = 10\n\ni is 10 \ni++ is 10     //Assigns (print out), then increments\ni is 11 \n\nj is 10 \n++j is 11    //Increments, then assigns (print out)\nj is 11 \n\nint i, j;\n\nfor (i = 0; i &lt;= 3; i++)\n    printf (&quot; &gt; iteration #%i&quot;, i);\n\nprintf (&quot;\\n&quot;);\n\nfor (j = 0; j &lt;= 3; ++j)\n    printf (&quot; &gt; iteration #%i&quot;, j);\n\n&gt; iteration #0 &gt; iteration #1 &gt; iteration #2 &gt; iteration #3\n&gt; iteration #0 &gt; iteration #1 &gt; iteration #2 &gt; iteration #3 \n",
            "int  i;\nint  j;\n\ni = 1;\nj = ++i;    // i is now 2, j is also 2\nj = i++;    // i is now 3, j is 2\n",
            "++i\ni++\nfunction(i++)\nfunction(++i)\nfunction(++i)\ni\nfunction(i++)\ni\ni\nint i=4;\nprintf(\"%d\\n\",pow(++i,2));//it prints 25 and i is 5 now\ni=4;\nprintf(\"%d\",pow(i++,2));//it prints 16 i is 5 now\n",
            "int j = 0;\nSystem.out.println(j); // 0\nSystem.out.println(j++); // 0. post-increment. It means after this line executes j increments.\n\nint k = 0;\nSystem.out.println(k); // 0\nSystem.out.println(++k); // 1. pre increment. It means it increments first and then the line executes\n\nint m = 0;\nif((m == 0 || m++ == 0) &amp;&amp; (m++ == 1)) { // False\n    // In the OR condition, if the first line is already true\n    // then the compiler doesn't check the rest. It is a\n    // technique of compiler optimization\n    System.out.println(&quot;post-increment &quot; + m);\n}\n\nint n = 0;\nif((n == 0 || n++ == 0) &amp;&amp; (++n == 1)) { // True\n    System.out.println(&quot;pre-increment &quot; + n); // 1\n}\n\nSystem.out.println(&quot;In Array&quot;);\nint[] a = { 55, 11, 15, 20, 25 };\nint ii, jj, kk = 1, mm;\nii = ++a[1]; // ii = 12. a[1] = a[1] + 1\nSystem.out.println(a[1]); // 12\n\njj = a[1]++; // 12\nSystem.out.println(a[1]); // a[1] = 13\n\nmm = a[1]; // 13\nSystem.out.printf(&quot;\\n%d %d %d\\n&quot;, ii, jj, mm); // 12, 12, 13\n\nfor (int val: a) {\n     System.out.print(&quot; &quot; + val); // 55, 13, 15, 20, 25\n}\n\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n\n    int x = 10;\n    int* p = &amp;x;\n\n    std::cout &lt;&lt; &quot;address = &quot; &lt;&lt; p &lt;&lt;&quot;\\n&quot;; // Prints the address of x\n    std::cout &lt;&lt; &quot;address = &quot; &lt;&lt; p &lt;&lt;&quot;\\n&quot;; // Prints (the address of x) + sizeof(int)\n    std::cout &lt;&lt; &quot;address = &quot; &lt;&lt; &amp;x &lt;&lt;&quot;\\n&quot;; // Prints the address of x\n\n    std::cout &lt;&lt; &quot;address = &quot; &lt;&lt; ++&amp;x &lt;&lt; &quot;\\n&quot;; // Error. The reference can't reassign, because it is fixed (immutable).\n}\n",
            "int i = 1;\nint j = i++;\n\nj\n1\nint i = 1;\nint j = ++i;\n\nj\n2\ni\n2",
            "for (int i = 0; i != X; ++i) ...\n",
            "i =1\n1,2,3,4,n\ni =1\n2,3,4,5,n",
            "int i, j, k, l;\ni = 1; //initialize int i with 1\nj = i+1; //add 1 with i and set that as the value of j. i is still 1\nk = i++; //k gets the current value of i, after that i is incremented. So here i is 2, but k is 1\nl = ++i; // i is incremented first and then returned. So the value of i is 3 and so does l.\ncout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; j &lt;&lt; ' ' &lt;&lt; k &lt;&lt; ' '&lt;&lt; l &lt;&lt; endl;\nreturn 0;\n",
            "// case 1\n\ni++;\n\n/* you can think as,\n * i;\n * i= i+1;\n */\n\n\n\n// case 2\n\n++i;\n\n/* you can think as,\n * i = i+i;\n * i;\n */\n",
            "++\n++\nclass Int {\n    private:\n        int i;\n\n    public:\n        Int(int i)\n        {\n            this-&gt;i = i;\n        }\n\n        // Overloading the prefix operator\n        Int&amp; operator++()\n        {\n            ++i;\n            // returned value should be a reference to *this\n            return *this;\n        }\n\n        // Overloading the postfix operator\n        Int operator++(int)\n        {\n            // returned value should be a copy of the object before increment\n            Int obj = *this;\n            ++i;\n            return obj;\n        }\n};\n"
        ]
    },
    {
        "question_id": 19210935,
        "question_code": "linux\n1\n#include &lt;stdio.h&gt;\nint main(void)\n{       \n    int linux = 5;\n    return 0;\n}\n\n$ gcc -E test.c\n....\nint main(void)\n{\n    int 1 = 5;\n    return 0;\n}\n\n#define linux\nstdio.h",
        "answer_code_snippets": [
            "unix\nvax\n#ifdef\nunix\nunix\nlinux\nint linux = 5;\ngcc -std=c90 -pedantic ... # or -std=c89 or -ansi\ngcc -std=c99 -pedantic\ngcc -std=c11 -pedantic\n\nunix\nlinux\n__linux__\nunix\nmain() { printf(&amp;unix[&quot;\\021%six\\012\\0&quot;],(unix)[&quot;have&quot;]+&quot;fun&quot;-0x60);}\n\n&quot;unix&quot;",
            "-dM\n-std=gnu99\n-std=c99\n$ cpp --std=c89 -dM &lt; /dev/null | grep linux\n#define __linux 1\n#define __linux__ 1\n#define __gnu_linux__ 1\n\n$ cpp --std=gnu89 -dM &lt; /dev/null | grep linux\n#define __linux 1\n#define __linux__ 1\n#define __gnu_linux__ 1\n#define linux 1\n\n$ cpp --std=c99 -dM &lt; /dev/null | grep linux\n#define __linux 1\n#define __linux__ 1\n#define __gnu_linux__ 1\n\n$ cpp --std=gnu99 -dM &lt; /dev/null | grep linux\n#define __linux 1\n#define __linux__ 1\n#define __gnu_linux__ 1\n#define linux 1\n\n#define unix\nc11\ngnu11\n-std=gnu89\ncpp",
            "linux\ncp /dev/null emptyfile.c\ngcc -E -dM emptyfile.c\n\n/dev/null\n#define __DBL_MIN_EXP__ (-1021)\n#define __UINT_LEAST16_MAX__ 65535\n#define __ATOMIC_ACQUIRE 2\n#define __FLT_MIN__ 1.17549435082228750797e-38F\n#define __UINT_LEAST8_TYPE__ unsigned char\n#define __INTMAX_C(c) c ## L\n#define __CHAR_BIT__ 8\n#define __UINT8_MAX__ 255\n#define __WINT_MAX__ 2147483647\n#define __ORDER_LITTLE_ENDIAN__ 1234\n#define __SIZE_MAX__ 18446744073709551615UL\n#define __WCHAR_MAX__ 2147483647\n#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1 1\n#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2 1\n#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4 1\n#define __DBL_DENORM_MIN__ ((double)4.94065645841246544177e-324L)\n#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8 1\n#define __GCC_ATOMIC_CHAR_LOCK_FREE 2\n#define __FLT_EVAL_METHOD__ 0\n#define __GCC_ATOMIC_CHAR32_T_LOCK_FREE 2\n#define __x86_64 1\n#define __UINT_FAST64_MAX__ 18446744073709551615ULL\n#define __SIG_ATOMIC_TYPE__ int\n#define __DBL_MIN_10_EXP__ (-307)\n#define __FINITE_MATH_ONLY__ 0\n#define __GNUC_PATCHLEVEL__ 1\n#define __UINT_FAST8_MAX__ 255\n#define __DEC64_MAX_EXP__ 385\n#define __INT8_C(c) c\n#define __UINT_LEAST64_MAX__ 18446744073709551615ULL\n#define __SHRT_MAX__ 32767\n#define __LDBL_MAX__ 1.18973149535723176502e+4932L\n#define __UINT_LEAST8_MAX__ 255\n#define __GCC_ATOMIC_BOOL_LOCK_FREE 2\n#define __APPLE_CC__ 1\n#define __UINTMAX_TYPE__ long unsigned int\n#define __DEC32_EPSILON__ 1E-6DF\n#define __UINT32_MAX__ 4294967295U\n#define __LDBL_MAX_EXP__ 16384\n#define __WINT_MIN__ (-__WINT_MAX__ - 1)\n#define __SCHAR_MAX__ 127\n#define __WCHAR_MIN__ (-__WCHAR_MAX__ - 1)\n#define __INT64_C(c) c ## LL\n#define __DBL_DIG__ 15\n#define __GCC_ATOMIC_POINTER_LOCK_FREE 2\n#define __SIZEOF_INT__ 4\n#define __SIZEOF_POINTER__ 8\n#define __USER_LABEL_PREFIX__ _\n#define __STDC_HOSTED__ 1\n#define __LDBL_HAS_INFINITY__ 1\n#define __FLT_EPSILON__ 1.19209289550781250000e-7F\n#define __LDBL_MIN__ 3.36210314311209350626e-4932L\n#define __DEC32_MAX__ 9.999999E96DF\n#define __strong \n#define __INT32_MAX__ 2147483647\n#define __SIZEOF_LONG__ 8\n#define __APPLE__ 1\n#define __UINT16_C(c) c\n#define __DECIMAL_DIG__ 21\n#define __LDBL_HAS_QUIET_NAN__ 1\n#define __DYNAMIC__ 1\n#define __GNUC__ 4\n#define __MMX__ 1\n#define __FLT_HAS_DENORM__ 1\n#define __SIZEOF_LONG_DOUBLE__ 16\n#define __BIGGEST_ALIGNMENT__ 16\n#define __DBL_MAX__ ((double)1.79769313486231570815e+308L)\n#define __INT_FAST32_MAX__ 2147483647\n#define __DBL_HAS_INFINITY__ 1\n#define __DEC32_MIN_EXP__ (-94)\n#define __INT_FAST16_TYPE__ short int\n#define __LDBL_HAS_DENORM__ 1\n#define __DEC128_MAX__ 9.999999999999999999999999999999999E6144DL\n#define __INT_LEAST32_MAX__ 2147483647\n#define __DEC32_MIN__ 1E-95DF\n#define __weak \n#define __DBL_MAX_EXP__ 1024\n#define __DEC128_EPSILON__ 1E-33DL\n#define __SSE2_MATH__ 1\n#define __ATOMIC_HLE_RELEASE 131072\n#define __PTRDIFF_MAX__ 9223372036854775807L\n#define __amd64 1\n#define __tune_core2__ 1\n#define __ATOMIC_HLE_ACQUIRE 65536\n#define __LONG_LONG_MAX__ 9223372036854775807LL\n#define __SIZEOF_SIZE_T__ 8\n#define __SIZEOF_WINT_T__ 4\n#define __GXX_ABI_VERSION 1002\n#define __FLT_MIN_EXP__ (-125)\n#define __INT_FAST64_TYPE__ long long int\n#define __DBL_MIN__ ((double)2.22507385850720138309e-308L)\n#define __LP64__ 1\n#define __DEC128_MIN__ 1E-6143DL\n#define __REGISTER_PREFIX__ \n#define __UINT16_MAX__ 65535\n#define __DBL_HAS_DENORM__ 1\n#define __UINT8_TYPE__ unsigned char\n#define __NO_INLINE__ 1\n#define __FLT_MANT_DIG__ 24\n#define __VERSION__ \"4.8.1\"\n#define __UINT64_C(c) c ## ULL\n#define __GCC_ATOMIC_INT_LOCK_FREE 2\n#define __FLOAT_WORD_ORDER__ __ORDER_LITTLE_ENDIAN__\n#define __INT32_C(c) c\n#define __DEC64_EPSILON__ 1E-15DD\n#define __ORDER_PDP_ENDIAN__ 3412\n#define __DEC128_MIN_EXP__ (-6142)\n#define __INT_FAST32_TYPE__ int\n#define __UINT_LEAST16_TYPE__ short unsigned int\n#define __INT16_MAX__ 32767\n#define __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ 1080\n#define __SIZE_TYPE__ long unsigned int\n#define __UINT64_MAX__ 18446744073709551615ULL\n#define __INT8_TYPE__ signed char\n#define __FLT_RADIX__ 2\n#define __INT_LEAST16_TYPE__ short int\n#define __LDBL_EPSILON__ 1.08420217248550443401e-19L\n#define __UINTMAX_C(c) c ## UL\n#define __SSE_MATH__ 1\n#define __k8 1\n#define __SIG_ATOMIC_MAX__ 2147483647\n#define __GCC_ATOMIC_WCHAR_T_LOCK_FREE 2\n#define __SIZEOF_PTRDIFF_T__ 8\n#define __x86_64__ 1\n#define __DEC32_SUBNORMAL_MIN__ 0.000001E-95DF\n#define __INT_FAST16_MAX__ 32767\n#define __UINT_FAST32_MAX__ 4294967295U\n#define __UINT_LEAST64_TYPE__ long long unsigned int\n#define __FLT_HAS_QUIET_NAN__ 1\n#define __FLT_MAX_10_EXP__ 38\n#define __LONG_MAX__ 9223372036854775807L\n#define __DEC128_SUBNORMAL_MIN__ 0.000000000000000000000000000000001E-6143DL\n#define __FLT_HAS_INFINITY__ 1\n#define __UINT_FAST16_TYPE__ short unsigned int\n#define __DEC64_MAX__ 9.999999999999999E384DD\n#define __CHAR16_TYPE__ short unsigned int\n#define __PRAGMA_REDEFINE_EXTNAME 1\n#define __INT_LEAST16_MAX__ 32767\n#define __DEC64_MANT_DIG__ 16\n#define __INT64_MAX__ 9223372036854775807LL\n#define __UINT_LEAST32_MAX__ 4294967295U\n#define __GCC_ATOMIC_LONG_LOCK_FREE 2\n#define __INT_LEAST64_TYPE__ long long int\n#define __INT16_TYPE__ short int\n#define __INT_LEAST8_TYPE__ signed char\n#define __DEC32_MAX_EXP__ 97\n#define __INT_FAST8_MAX__ 127\n#define __INTPTR_MAX__ 9223372036854775807L\n#define __LITTLE_ENDIAN__ 1\n#define __SSE2__ 1\n#define __LDBL_MANT_DIG__ 64\n#define __CONSTANT_CFSTRINGS__ 1\n#define __DBL_HAS_QUIET_NAN__ 1\n#define __SIG_ATOMIC_MIN__ (-__SIG_ATOMIC_MAX__ - 1)\n#define __code_model_small__ 1\n#define __k8__ 1\n#define __INTPTR_TYPE__ long int\n#define __UINT16_TYPE__ short unsigned int\n#define __WCHAR_TYPE__ int\n#define __SIZEOF_FLOAT__ 4\n#define __pic__ 2\n#define __UINTPTR_MAX__ 18446744073709551615UL\n#define __DEC64_MIN_EXP__ (-382)\n#define __INT_FAST64_MAX__ 9223372036854775807LL\n#define __GCC_ATOMIC_TEST_AND_SET_TRUEVAL 1\n#define __FLT_DIG__ 6\n#define __UINT_FAST64_TYPE__ long long unsigned int\n#define __INT_MAX__ 2147483647\n#define __MACH__ 1\n#define __amd64__ 1\n#define __INT64_TYPE__ long long int\n#define __FLT_MAX_EXP__ 128\n#define __ORDER_BIG_ENDIAN__ 4321\n#define __DBL_MANT_DIG__ 53\n#define __INT_LEAST64_MAX__ 9223372036854775807LL\n#define __GCC_ATOMIC_CHAR16_T_LOCK_FREE 2\n#define __DEC64_MIN__ 1E-383DD\n#define __WINT_TYPE__ int\n#define __UINT_LEAST32_TYPE__ unsigned int\n#define __SIZEOF_SHORT__ 2\n#define __SSE__ 1\n#define __LDBL_MIN_EXP__ (-16381)\n#define __INT_LEAST8_MAX__ 127\n#define __SIZEOF_INT128__ 16\n#define __LDBL_MAX_10_EXP__ 4932\n#define __ATOMIC_RELAXED 0\n#define __DBL_EPSILON__ ((double)2.22044604925031308085e-16L)\n#define _LP64 1\n#define __UINT8_C(c) c\n#define __INT_LEAST32_TYPE__ int\n#define __SIZEOF_WCHAR_T__ 4\n#define __UINT64_TYPE__ long long unsigned int\n#define __INT_FAST8_TYPE__ signed char\n#define __DBL_DECIMAL_DIG__ 17\n#define __FXSR__ 1\n#define __DEC_EVAL_METHOD__ 2\n#define __UINT32_C(c) c ## U\n#define __INTMAX_MAX__ 9223372036854775807L\n#define __BYTE_ORDER__ __ORDER_LITTLE_ENDIAN__\n#define __FLT_DENORM_MIN__ 1.40129846432481707092e-45F\n#define __INT8_MAX__ 127\n#define __PIC__ 2\n#define __UINT_FAST32_TYPE__ unsigned int\n#define __CHAR32_TYPE__ unsigned int\n#define __FLT_MAX__ 3.40282346638528859812e+38F\n#define __INT32_TYPE__ int\n#define __SIZEOF_DOUBLE__ 8\n#define __FLT_MIN_10_EXP__ (-37)\n#define __INTMAX_TYPE__ long int\n#define __DEC128_MAX_EXP__ 6145\n#define __ATOMIC_CONSUME 1\n#define __GNUC_MINOR__ 8\n#define __UINTMAX_MAX__ 18446744073709551615UL\n#define __DEC32_MANT_DIG__ 7\n#define __DBL_MAX_10_EXP__ 308\n#define __LDBL_DENORM_MIN__ 3.64519953188247460253e-4951L\n#define __INT16_C(c) c\n#define __STDC__ 1\n#define __PTRDIFF_TYPE__ long int\n#define __ATOMIC_SEQ_CST 5\n#define __UINT32_TYPE__ unsigned int\n#define __UINTPTR_TYPE__ long unsigned int\n#define __DEC64_SUBNORMAL_MIN__ 0.000000000000001E-383DD\n#define __DEC128_MANT_DIG__ 34\n#define __LDBL_MIN_10_EXP__ (-4931)\n#define __SIZEOF_LONG_LONG__ 8\n#define __GCC_ATOMIC_LLONG_LOCK_FREE 2\n#define __LDBL_DIG__ 18\n#define __FLT_DECIMAL_DIG__ 9\n#define __UINT_FAST16_MAX__ 65535\n#define __GNUC_GNU_INLINE__ 1\n#define __GCC_ATOMIC_SHORT_LOCK_FREE 2\n#define __SSE3__ 1\n#define __UINT_FAST8_TYPE__ unsigned char\n#define __ATOMIC_ACQ_REL 4\n#define __ATOMIC_RELEASE 3\n\n#include &lt;stdio.h&gt;",
            "info gcc\n-ansi\n-std=c90\n-std=c++98\nasm\ntypeof\n//\ninline\n-ansi",
            "gcc -dM -E - &lt; /dev/null\n\n    #define _LP64 1\n#define _STDC_PREDEF_H 1\n#define __ATOMIC_ACQUIRE 2\n#define __ATOMIC_ACQ_REL 4\n#define __ATOMIC_CONSUME 1\n#define __ATOMIC_HLE_ACQUIRE 65536\n#define __ATOMIC_HLE_RELEASE 131072\n#define __ATOMIC_RELAXED 0\n#define __ATOMIC_RELEASE 3\n#define __ATOMIC_SEQ_CST 5\n#define __BIGGEST_ALIGNMENT__ 16\n#define __BYTE_ORDER__ __ORDER_LITTLE_ENDIAN__\n#define __CHAR16_TYPE__ short unsigned int\n#define __CHAR32_TYPE__ unsigned int\n#define __CHAR_BIT__ 8\n#define __DBL_DECIMAL_DIG__ 17\n#define __DBL_DENORM_MIN__ ((double)4.94065645841246544177e-324L)\n#define __DBL_DIG__ 15\n#define __DBL_EPSILON__ ((double)2.22044604925031308085e-16L)\n#define __DBL_HAS_DENORM__ 1\n#define __DBL_HAS_INFINITY__ 1\n#define __DBL_HAS_QUIET_NAN__ 1\n#define __DBL_MANT_DIG__ 53\n#define __DBL_MAX_10_EXP__ 308\n#define __DBL_MAX_EXP__ 1024\n#define __DBL_MAX__ ((double)1.79769313486231570815e+308L)\n#define __DBL_MIN_10_EXP__ (-307)\n#define __DBL_MIN_EXP__ (-1021)\n#define __DBL_MIN__ ((double)2.22507385850720138309e-308L)\n#define __DEC128_EPSILON__ 1E-33DL\n#define __DEC128_MANT_DIG__ 34\n#define __DEC128_MAX_EXP__ 6145\n#define __DEC128_MAX__ 9.999999999999999999999999999999999E6144DL\n#define __DEC128_MIN_EXP__ (-6142)\n#define __DEC128_MIN__ 1E-6143DL\n#define __DEC128_SUBNORMAL_MIN__ 0.000000000000000000000000000000001E-6143DL\n#define __DEC32_EPSILON__ 1E-6DF\n#define __DEC32_MANT_DIG__ 7\n#define __DEC32_MAX_EXP__ 97\n#define __DEC32_MAX__ 9.999999E96DF\n#define __DEC32_MIN_EXP__ (-94)\n#define __DEC32_MIN__ 1E-95DF\n#define __DEC32_SUBNORMAL_MIN__ 0.000001E-95DF\n#define __DEC64_EPSILON__ 1E-15DD\n#define __DEC64_MANT_DIG__ 16\n#define __DEC64_MAX_EXP__ 385\n#define __DEC64_MAX__ 9.999999999999999E384DD\n#define __DEC64_MIN_EXP__ (-382)\n#define __DEC64_MIN__ 1E-383DD\n#define __DEC64_SUBNORMAL_MIN__ 0.000000000000001E-383DD\n#define __DECIMAL_BID_FORMAT__ 1\n#define __DECIMAL_DIG__ 21\n#define __DEC_EVAL_METHOD__ 2\n#define __ELF__ 1\n#define __FINITE_MATH_ONLY__ 0\n#define __FLOAT_WORD_ORDER__ __ORDER_LITTLE_ENDIAN__\n#define __FLT_DECIMAL_DIG__ 9\n#define __FLT_DENORM_MIN__ 1.40129846432481707092e-45F\n#define __FLT_DIG__ 6\n#define __FLT_EPSILON__ 1.19209289550781250000e-7F\n#define __FLT_EVAL_METHOD__ 0\n#define __FLT_HAS_DENORM__ 1\n#define __FLT_HAS_INFINITY__ 1\n#define __FLT_HAS_QUIET_NAN__ 1\n#define __FLT_MANT_DIG__ 24\n#define __FLT_MAX_10_EXP__ 38\n#define __FLT_MAX_EXP__ 128\n#define __FLT_MAX__ 3.40282346638528859812e+38F\n#define __FLT_MIN_10_EXP__ (-37)\n#define __FLT_MIN_EXP__ (-125)\n#define __FLT_MIN__ 1.17549435082228750797e-38F\n#define __FLT_RADIX__ 2\n#define __FXSR__ 1\n#define __GCC_ASM_FLAG_OUTPUTS__ 1\n#define __GCC_ATOMIC_BOOL_LOCK_FREE 2\n#define __GCC_ATOMIC_CHAR16_T_LOCK_FREE 2\n#define __GCC_ATOMIC_CHAR32_T_LOCK_FREE 2\n#define __GCC_ATOMIC_CHAR_LOCK_FREE 2\n#define __GCC_ATOMIC_INT_LOCK_FREE 2\n#define __GCC_ATOMIC_LLONG_LOCK_FREE 2\n#define __GCC_ATOMIC_LONG_LOCK_FREE 2\n#define __GCC_ATOMIC_POINTER_LOCK_FREE 2\n#define __GCC_ATOMIC_SHORT_LOCK_FREE 2\n#define __GCC_ATOMIC_TEST_AND_SET_TRUEVAL 1\n#define __GCC_ATOMIC_WCHAR_T_LOCK_FREE 2\n#define __GCC_HAVE_DWARF2_CFI_ASM 1\n#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1 1\n#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2 1\n#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4 1\n#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8 1\n#define __GCC_IEC_559 2\n#define __GCC_IEC_559_COMPLEX 2\n#define __GNUC_MINOR__ 3\n#define __GNUC_PATCHLEVEL__ 0\n#define __GNUC_STDC_INLINE__ 1\n#define __GNUC__ 6\n#define __GXX_ABI_VERSION 1010\n#define __INT16_C(c) c\n#define __INT16_MAX__ 0x7fff\n#define __INT16_TYPE__ short int\n#define __INT32_C(c) c\n#define __INT32_MAX__ 0x7fffffff\n#define __INT32_TYPE__ int\n#define __INT64_C(c) c ## L\n#define __INT64_MAX__ 0x7fffffffffffffffL\n#define __INT64_TYPE__ long int\n#define __INT8_C(c) c\n#define __INT8_MAX__ 0x7f\n#define __INT8_TYPE__ signed char\n#define __INTMAX_C(c) c ## L\n#define __INTMAX_MAX__ 0x7fffffffffffffffL\n#define __INTMAX_TYPE__ long int\n#define __INTPTR_MAX__ 0x7fffffffffffffffL\n#define __INTPTR_TYPE__ long int\n#define __INT_FAST16_MAX__ 0x7fffffffffffffffL\n#define __INT_FAST16_TYPE__ long int\n#define __INT_FAST32_MAX__ 0x7fffffffffffffffL\n#define __INT_FAST32_TYPE__ long int\n#define __INT_FAST64_MAX__ 0x7fffffffffffffffL\n#define __INT_FAST64_TYPE__ long int\n#define __INT_FAST8_MAX__ 0x7f\n#define __INT_FAST8_TYPE__ signed char\n#define __INT_LEAST16_MAX__ 0x7fff\n#define __INT_LEAST16_TYPE__ short int\n#define __INT_LEAST32_MAX__ 0x7fffffff\n#define __INT_LEAST32_TYPE__ int\n#define __INT_LEAST64_MAX__ 0x7fffffffffffffffL\n#define __INT_LEAST64_TYPE__ long int\n#define __INT_LEAST8_MAX__ 0x7f\n#define __INT_LEAST8_TYPE__ signed char\n#define __INT_MAX__ 0x7fffffff\n#define __LDBL_DENORM_MIN__ 3.64519953188247460253e-4951L\n#define __LDBL_DIG__ 18\n#define __LDBL_EPSILON__ 1.08420217248550443401e-19L\n#define __LDBL_HAS_DENORM__ 1\n#define __LDBL_HAS_INFINITY__ 1\n#define __LDBL_HAS_QUIET_NAN__ 1\n#define __LDBL_MANT_DIG__ 64\n#define __LDBL_MAX_10_EXP__ 4932\n#define __LDBL_MAX_EXP__ 16384\n#define __LDBL_MAX__ 1.18973149535723176502e+4932L\n#define __LDBL_MIN_10_EXP__ (-4931)\n#define __LDBL_MIN_EXP__ (-16381)\n#define __LDBL_MIN__ 3.36210314311209350626e-4932L\n#define __LONG_LONG_MAX__ 0x7fffffffffffffffLL\n#define __LONG_MAX__ 0x7fffffffffffffffL\n#define __LP64__ 1\n#define __MMX__ 1\n#define __NO_INLINE__ 1\n#define __ORDER_BIG_ENDIAN__ 4321\n#define __ORDER_LITTLE_ENDIAN__ 1234\n#define __ORDER_PDP_ENDIAN__ 3412\n#define __PIC__ 2\n#define __PIE__ 2\n#define __PRAGMA_REDEFINE_EXTNAME 1\n#define __PTRDIFF_MAX__ 0x7fffffffffffffffL\n#define __PTRDIFF_TYPE__ long int\n#define __REGISTER_PREFIX__ \n#define __SCHAR_MAX__ 0x7f\n#define __SEG_FS 1\n#define __SEG_GS 1\n#define __SHRT_MAX__ 0x7fff\n#define __SIG_ATOMIC_MAX__ 0x7fffffff\n#define __SIG_ATOMIC_MIN__ (-__SIG_ATOMIC_MAX__ - 1)\n#define __SIG_ATOMIC_TYPE__ int\n#define __SIZEOF_DOUBLE__ 8\n#define __SIZEOF_FLOAT128__ 16\n#define __SIZEOF_FLOAT80__ 16\n#define __SIZEOF_FLOAT__ 4\n#define __SIZEOF_INT128__ 16\n#define __SIZEOF_INT__ 4\n#define __SIZEOF_LONG_DOUBLE__ 16\n#define __SIZEOF_LONG_LONG__ 8\n#define __SIZEOF_LONG__ 8\n#define __SIZEOF_POINTER__ 8\n#define __SIZEOF_PTRDIFF_T__ 8\n#define __SIZEOF_SHORT__ 2\n#define __SIZEOF_SIZE_T__ 8\n#define __SIZEOF_WCHAR_T__ 4\n#define __SIZEOF_WINT_T__ 4\n#define __SIZE_MAX__ 0xffffffffffffffffUL\n#define __SIZE_TYPE__ long unsigned int\n#define __SSE2_MATH__ 1\n#define __SSE2__ 1\n#define __SSE_MATH__ 1\n#define __SSE__ 1\n#define __SSP_STRONG__ 3\n#define __STDC_HOSTED__ 1\n#define __STDC_IEC_559_COMPLEX__ 1\n#define __STDC_IEC_559__ 1\n#define __STDC_ISO_10646__ 201605L\n#define __STDC_NO_THREADS__ 1\n#define __STDC_UTF_16__ 1\n#define __STDC_UTF_32__ 1\n#define __STDC_VERSION__ 201112L\n#define __STDC__ 1\n#define __UINT16_C(c) c\n#define __UINT16_MAX__ 0xffff\n#define __UINT16_TYPE__ short unsigned int\n#define __UINT32_C(c) c ## U\n#define __UINT32_MAX__ 0xffffffffU\n#define __UINT32_TYPE__ unsigned int\n#define __UINT64_C(c) c ## UL\n#define __UINT64_MAX__ 0xffffffffffffffffUL\n#define __UINT64_TYPE__ long unsigned int\n#define __UINT8_C(c) c\n#define __UINT8_MAX__ 0xff\n#define __UINT8_TYPE__ unsigned char\n#define __UINTMAX_C(c) c ## UL\n#define __UINTMAX_MAX__ 0xffffffffffffffffUL\n#define __UINTMAX_TYPE__ long unsigned int\n#define __UINTPTR_MAX__ 0xffffffffffffffffUL\n#define __UINTPTR_TYPE__ long unsigned int\n#define __UINT_FAST16_MAX__ 0xffffffffffffffffUL\n#define __UINT_FAST16_TYPE__ long unsigned int\n#define __UINT_FAST32_MAX__ 0xffffffffffffffffUL\n#define __UINT_FAST32_TYPE__ long unsigned int\n#define __UINT_FAST64_MAX__ 0xffffffffffffffffUL\n#define __UINT_FAST64_TYPE__ long unsigned int\n#define __UINT_FAST8_MAX__ 0xff\n#define __UINT_FAST8_TYPE__ unsigned char\n#define __UINT_LEAST16_MAX__ 0xffff\n#define __UINT_LEAST16_TYPE__ short unsigned int\n#define __UINT_LEAST32_MAX__ 0xffffffffU\n#define __UINT_LEAST32_TYPE__ unsigned int\n#define __UINT_LEAST64_MAX__ 0xffffffffffffffffUL\n#define __UINT_LEAST64_TYPE__ long unsigned int\n#define __UINT_LEAST8_MAX__ 0xff\n#define __UINT_LEAST8_TYPE__ unsigned char\n#define __USER_LABEL_PREFIX__ \n#define __VERSION__ \"6.3.0 20170406\"\n#define __WCHAR_MAX__ 0x7fffffff\n#define __WCHAR_MIN__ (-__WCHAR_MAX__ - 1)\n#define __WCHAR_TYPE__ int\n#define __WINT_MAX__ 0xffffffffU\n#define __WINT_MIN__ 0U\n#define __WINT_TYPE__ unsigned int\n#define __amd64 1\n#define __amd64__ 1\n#define __code_model_small__ 1\n#define __gnu_linux__ 1\n#define __has_include(STR) __has_include__(STR)\n#define __has_include_next(STR) __has_include_next__(STR)\n#define __k8 1\n#define __k8__ 1\n#define __linux 1\n#define __linux__ 1\n#define __pic__ 2\n#define __pie__ 2\n#define __unix 1\n#define __unix__ 1\n#define __x86_64 1\n#define __x86_64__ 1\n#define linux 1\n#define unix 1\n"
        ]
    },
    {
        "question_id": 1410563,
        "question_code": "",
        "answer_code_snippets": [
            "extern int bar;\nextern int g(int, int);\ndouble f(int, double); // extern can be omitted for function declarations\nclass foo; // no extern allowed for type declarations\n\nint bar;\nint g(int lhs, int rhs) {return lhs*rhs;}\ndouble f(int i, double d) {return i+d;}\nclass foo {};\n\ndouble f(int, double);\ndouble f(int, double);\nextern double f(int, double); // the same as the two above\nextern double f(int, double);\n\nstruct x;\nstruct x {};",
            "void sqrt(double);  // declares sqrt\n\nstruct X\n{\n    int a;         // defines a\n    static int b;  // declares b\n};\n\nclass Y;\n\nextern\nextern const int i = 0;  // defines i\nextern int j;  // declares j\nextern \"C\"\n{\n    void foo();  // declares foo\n}\n\ntypedef\nusing\ntypedef long LONG_32;  // declares LONG_32\nusing namespace std;   // declares std\n",
            "T t;\n\nT\ntypedef void T();\nT t; // declaration of function \"t\"\n\nstruct X { \n  T t; // declaration of function \"t\".\n};\n\ntypedef int T;\nT t; // definition of object \"t\".\n\ntemplate &lt;typename T&gt;\nstruct X { \n  static int member; // declaration\n};\n\ntemplate&lt;typename T&gt;\nint X&lt;T&gt;::member; // definition\n\ntemplate&lt;&gt;\nint X&lt;bool&gt;::member; // declaration!\n\nX&lt;bool&gt;\nX&lt;bool&gt;::member\ntemplate&lt;&gt;\nint X&lt;bool&gt;::member = 1; // definition, belongs into a .cpp file.\n",
            "typedef int myint;",
            "extern int a; \nstruct _tagExample { int a; int b; }; \nint myFunc (int a, int b);\n\nint a; \nint b = 0; \nint myFunc (int a, int b) { return a + b; } \nstruct _tagExample example; \n",
            "enum X : int;\ntemplate&lt;typename T&gt; class MyArray;\nint add(int x, int y);\nusing IntVector = std::vector&lt;int&gt;;\nstatic_assert(sizeof(int) == 4, &quot;Yikes!&quot;)\n;\nint add(int x, int y);\nextern int a;\nextern &quot;C&quot; { ... };\nclass C { static int x; };\nstruct Point;\ntypedef int Int;\nusing std::cout;\nusing namespace NS;\n// except one all these are definitions\nint a;                                  // defines a\nextern const int c = 1;                 // defines c\nint f(int x) { return x + a; }          // defines f and defines x\nstruct S { int a; int b; };             // defines S, S::a, and S::b\nstruct X {                              // defines X\n    int x;                              // defines non-static data member x\n    static int y;                       // DECLARES static data member y\n    X(): x(0) { }                       // defines a constructor of X\n};\nint X::y = 1;                           // defines X::y\nenum { up , down };                     // defines up and down\nnamespace N { int d; }                  // defines N and N::d\nnamespace N1 = N;                       // defines N1\nX anX;                                  // defines anX\n\n\n// all these are declarations\nextern int a;                           // declares a\nextern const int c;                     // declares c\nint f(int);                             // declares f\nstruct S;                               // declares S\ntypedef int Int;                        // declares Int\nextern X anotherX;                      // declares anotherX\nusing N::d;                             // declares N::d\n\n\n// specific to C++11 - these are not from the standard\nenum X : int;                           // declares X with int as the underlying type\nusing IntVector = std::vector&lt;int&gt;;     // declares IntVector as an alias to std::vector&lt;int&gt;\nstatic_assert(X::y == 1, &quot;Oops!&quot;);      // declares a static_assert which can render the program ill-formed or have no effect like an empty declaration, depending on the result of expr\ntemplate &lt;class T&gt; class C;             // declares template class C\n;                                       // declares nothing\n",
            "extern int a;      // Declaration \nint a;             // Definition\na = 10             // Initialization\nint b = 10;        // Definition &amp; Initialization\n\nint a;\nfloat b;\ndouble c;\n\nint fun(int a,int b); \n\nint b=fun(x,y,z);\n\n#include &lt;stdio.h&gt;\nvoid print(int a)\n{\n     printf(\"%d\",a);\n}\nmain()\n{\n    print(5);\n}\n\n #include &lt;stdio.h&gt;\n void print(int a); // In this case this is essential\n main()\n {\n    print(5);\n }\n void print(int a)\n {\n     printf(\"%d\",a);\n }\n\nvoid print(int a)\n{\n    printf(\"%d\",a);\n}\n",
            "// declaration\nint sum(int, int);\n\nsum\nint\nint\n// definition\nint sum(int x, int y)\n{\n    return x + y;\n}\n",
            "void  myfunction(); //this is simple declaration\n\nvoid myfunction()\n{\n some statement;    \n}\n",
            "int sampleFunc(); // function\nextern int car;  // variable\n\nint sampleFunc() {} // function\nint car; // variable\n\nint car = 0; // variable\n",
            "int f(int x); // function declaration (I know f exists)\n\nint f(int x) { return 2*x; } // declaration and definition\n",
            "uint8_t   ui8 = 5;  |   movb    $0x5,-0x45(%rbp)\nint         i = 5;  |   movl    $0x5,-0x3c(%rbp)\nuint32_t ui32 = 5;  |   movl    $0x5,-0x38(%rbp)\nuint64_t ui64 = 5;  |   movq    $0x5,-0x10(%rbp)\ndouble   doub = 5;  |   movsd   0x328(%rip),%xmm0        # 0x400a20\n                        movsd   %xmm0,-0x8(%rbp)\n\nui8 = 5;   |   movb    $0x5,-0x45(%rbp)\ni = 5;     |   movl    $0x5,-0x3c(%rbp)\nui32 = 5;  |   movl    $0x5,-0x38(%rbp)\nui64 = 5;  |   movq    $0x5,-0x10(%rbp)\ndoub = 5;  |   movsd   0x328(%rip),%xmm0        # 0x400a20\n               movsd   %xmm0,-0x8(%rbp)\n\nuint def;                  |  no instructions\nprintf(\"some stuff...\");   |  [...] callq   0x400450 &lt;printf@plt&gt;\ndef=5;                     |  movb    $0x5,-0x45(%rbp)\n",
            "int a;                       // defines a\nextern const int c = 1;      // defines c\nint f(int x) { return x+a; } // defines f and defines x\nstruct S { int a; int b; };  // defines S, S::a, and S::b\nstruct X {                   // defines X\n    int x;                   // defines non-static data member x\n    static int y;            // DECLARES static data member y\n    X(): x(0) { }            // defines a constructor of X\n};\nint X::y = 1;                // defines X::y\nenum { up, down };           // defines up and down\nnamespace N { int d; }       // defines N and N::d\nnamespace N1 = N;            // defines N1\nX anX;                       // defines anX\n\nextern int a;                 // declares a\nextern const int c;           // declares c\nint f(int);                   // declares f\nstruct S;                     // declares S\ntypedef int Int;              // declares Int\nextern X anotherX;            // declares anotherX\nusing N::d;                   // declares d\n",
            "int sp;\ndouble val[MAXVAL]\n\nsp\nval\nextern int sp;\nextern double val[];\n\nsp\nint\nval\ndouble\nextern",
            "int i;\n\nint max(int, int);\n\ni = 20;\n\nint max(int a, int b)\n{\n   if(a&gt;b)   return a;\n   return b;  \n}\n\nint i=20;\n\nint max(int a, int b)\n{\n    if(a&gt;b)   return a;\n    return b;    \n} \n\ni\nfunction max()"
        ]
    }
]