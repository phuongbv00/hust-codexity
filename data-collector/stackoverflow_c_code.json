[
    {
        "question_id": 12135518,
        "question_code": "if (a &lt; 901)\nif (a &lt;= 900)",
        "answer_code_snippets": [
            "test\ncmp\nEFLAGS\nJcc\njne\nZF = 0\njz\nZF = 1\njg\nZF = 0 and SF = OF\n$ gcc -m32 -S -masm=intel test.c\n    if (a &lt; b) {\n        // Do something 1\n    }\n\n    mov     eax, DWORD PTR [esp+24]      ; a\n    cmp     eax, DWORD PTR [esp+28]      ; b\n    jge     .L2                          ; jump if a is &gt;= b\n    ; Do something 1\n.L2:\n\n    if (a &lt;= b) {\n        // Do something 2\n    }\n\n    mov     eax, DWORD PTR [esp+24]      ; a\n    cmp     eax, DWORD PTR [esp+28]      ; b\n    jg      .L5                          ; jump if a is &gt; b\n    ; Do something 2\n.L5:\n\njg\njge\nJcc\nJcc\n      Latency   Throughput\nJcc     N/A        0.5\n\nJcc\njcc\nJcc\nEFLAGS\ndouble\nint\n        fld     QWORD PTR [esp+32]\n        fld     QWORD PTR [esp+40]\n        fucomip st, st(1)              ; Compare ST(0) and ST(1), and set CF, PF, ZF in EFLAGS\n        fstp    st(0)\n        seta    al                     ; Set al if above (CF=0 and ZF=0).\n        test    al, al\n        je      .L2\n        ; Do something 1\n.L2:\n\n        fld     QWORD PTR [esp+32]\n        fld     QWORD PTR [esp+40]\n        fucomip st, st(1)              ; (same thing as above)\n        fstp    st(0)\n        setae   al                     ; Set al if above or equal (CF=0).\n        test    al, al\n        je      .L5\n        ; Do something 2\n.L5:\n        leave\n        ret\n",
            "Comparison     Subtraction\n----------     -----------\nA &lt; B      --&gt; A - B &lt; 0\nA = B      --&gt; A - B = 0\nA &gt; B      --&gt; A - B &gt; 0\n\nA &lt; B\nComparison     Subtraction  Carry Bit  Zero Bit\n----------     -----------  ---------  --------\nA &lt; B      --&gt; A - B &lt; 0    0          0\nA = B      --&gt; A - B = 0    1          1\nA &gt; B      --&gt; A - B &gt; 0    1          0\n\nA &lt; B\n;; Implementation of \"if (A &lt; B) goto address;\"\ncmp  A, B          ;; compare A to B\nbcz  address       ;; Branch if Carry is Zero to the new address\n\n;; Implementation of \"if (A &lt;= B) goto address;\"\ncmp A, B           ;; compare A to B\nbcz address        ;; branch if A &lt; B\nbzs address        ;; also, Branch if the Zero bit is Set\n",
            "&lt;\n&lt;=\n&lt;=\n&lt;",
            "if(a &lt; 901)\ncmpl  $900, -4(%rbp)\njg .L2\n\nif(a &lt;=901)\ncmpl  $901, -4(%rbp)\njg .L3\n\nif\nint b;\nif(a &lt; b)\ncmpl  -4(%rbp), %eax\njge   .L2\n\nif(a &lt;=b)\ncmpl  -4(%rbp), %eax\njg .L3\n",
            "int compare_strict(double a, double b) { return a &lt; b; }\n\ncr\nint compare_loose(double a, double b) { return a &lt;= b; }\n\ncompare_strict\ncror\ncompare_loose\ncompare_strict\nint compare_loose(double a, double b) { return ! (a &gt; b); }\n\nNaN1 &lt;= NaN2\nNaN1 &gt; NaN2",
            "a &gt; 0\na &gt;= 1\n0\nCMP\nOR\n&lt;",
            "&lt;\n&lt;=",
            "a &lt; 901\na &lt;= 900\n&lt;\n&lt;=\ncmp r0, #0x00f000\ncmp r0, #0x00efff\ncmp\ncmn\n&lt;=\n&lt;\n&lt;=\n&lt;=\n&lt;\n++i &lt;= size\nvoid foo(unsigned size) {\n    unsigned upper_bound = size - 1;  // or any calculation that could produce UINT_MAX\n    for(unsigned i=0 ; i &lt;= upper_bound ; i++)\n        ...\n\ni &lt;= size\nsize=0\nupper_bound=UINT_MAX\ni &lt;= UINT_MAX\nsize=0\ni &lt; size\nif(!size) skip the loop;\ndo{...}while(--size);\nfor( i&lt;size )\ni\nsize==0\ni &lt;= n\nsum(1 .. n)\nn * (n+1) / 2\nunsigned sum_1_to_n_finite(unsigned n) {\n    unsigned total = 0;\n    for (unsigned i = 0 ; i &lt; n+1 ; ++i)\n        total += i;\n    return total;\n}\n\n # clang7.0 -O3 closed-form\n    cmp     edi, -1       # n passed in EDI: x86-64 System V calling convention\n    je      .LBB1_1       # if (n == UINT_MAX) return 0;  // C++ loop runs 0 times\n          # else fall through into the closed-form calc\n    mov     ecx, edi         # zero-extend n into RCX\n    lea     eax, [rdi - 1]   # n-1\n    imul    rax, rcx         # n * (n-1)             # 64-bit\n    shr     rax              # n * (n-1) / 2\n    add     eax, edi         # n + (stuff / 2) = n * (n+1) / 2   # truncated to 32-bit\n    ret          # computed without possible overflow of the product before right shifting\n.LBB1_1:\n    xor     eax, eax\n    ret\n\nunsigned sum_1_to_n_naive(unsigned n) {\n    unsigned total = 0;\n    for (unsigned i = 0 ; i&lt;=n ; ++i)\n        total += i;\n    return total;\n}\n\n# clang7.0 -O3\nsum_1_to_n(unsigned int):\n    xor     ecx, ecx           # i = 0\n    xor     eax, eax           # retval = 0\n.LBB0_1:                       # do {\n    add     eax, ecx             # retval += i\n    add     ecx, 1               # ++1\n    cmp     ecx, edi\n    jbe     .LBB0_1            # } while( i&lt;n );\n    ret\n\ni\n# &quot;naive&quot; inner loop\n.L3:\n    add     eax, 1       # do {\n    paddd   xmm0, xmm1    # vect_total_4.6, vect_vec_iv_.5\n    paddd   xmm1, xmm2    # vect_vec_iv_.5, tmp114\n    cmp     edx, eax      # bnd.1, ivtmp.14     # bound and induction-variable tmp, I think.\n    ja      .L3 #,       # }while( n &gt; i )\n\n &quot;finite&quot; inner loop\n  # before the loop:\n  # xmm0 = 0 = totals\n  # xmm1 = {0,1,2,3} = i\n  # xmm2 = set1_epi32(4)\n .L13:                # do {\n    add     eax, 1       # i++\n    paddd   xmm0, xmm1    # total[0..3] += i[0..3]\n    paddd   xmm1, xmm2    # i[0..3] += 4\n    cmp     eax, edx\n    jne     .L13      # }while( i != upper_limit );\n\n     then horizontal sum xmm0\n     and peeled cleanup for the last n%3 iterations, or something.\n     \n\nn\nsub eax,1\njnz\nadd eax,1",
            "a + 1\na - 1",
            "&gt;=\n&lt;=\n&gt;\n&lt;\nmsb\na &gt;= b\na-b &gt;= 0\na-b\na &lt;= b\n0 &lt;= b-a\nb-a\na &lt; b\na-b &lt; 0\na-b\na &gt; b\n0 &gt; b-a\nb-a\na &gt;= b\nmsb(a-b)==0\na &lt;= b\nmsb(b-a)==0\na &gt;  b\nmsb(b-a)==1\na &lt;  b\nmsb(a-b)==1\n==0\n==1\n==0\nmsb\na &gt;= b\na&gt;b || a==b"
        ]
    },
    {
        "question_id": 36827659,
        "question_code": "",
        "answer_code_snippets": [
            "new\ndelete\nnew",
            "objdump",
            "log(n)\nn",
            ".data\n.bss\nstatic\n=\n.data\n.bss",
            "x==42\nx\nx\nvolatile\n... code that checks system state\nif (system_state_favors_activation)\n{\n  prepare_for_activation();\n  ... code that checks system state again\n  if (system_state_is_valid)\n  {\n    if (system_state_favors_activation)\n      trigger_activation();\n  }\n  else\n    perform_safety_shutdown_and_restart();\n}\ncancel_preparations();\n\nprepare_for_activation()\nprepare_for_activation()\nprepare_for_activation()\nprepare_for_activation()\ntrigger_activation()\ntrigger_activation()\nprepare_for_activation()\ncancel_preparations()\nprepare_for_activation()\ntrigger_activation()",
            "x\nx1\nx2\nx3\n(x1 == x2) ? x2 : x3",
            "n\nn",
            "uint32_t\ndouble\nint64_t\nSAFE_uint32_t",
            "nb_error_recoverable == (x-2)",
            "lw $3, 0x0($2)\n$2\n$3\nnop",
            "gcc\n-mmitigate-rop\n-fstack-protector-all\n-Â­D_FORTIFY_SOURCE=2\n-Wl,-z,relro,-z,now\n-Wl,-z,noexecstack"
        ]
    },
    {
        "question_id": 840501,
        "question_code": "",
        "answer_code_snippets": [
            "int addInt(int n, int m) {\n    return n+m;\n}\n\nint\nint\nint (*functionPtr)(int,int);\n\nfunctionPtr = &amp;addInt;\n\nint sum = (*functionPtr)(2, 3); // sum == 5\n\nint add2to3(int (*functionPtr)(int, int)) {\n    return (*functionPtr)(2, 3);\n}\n\n// this is a function called functionFactory which receives parameter n\n// and returns a pointer to another function which receives two ints\n// and it returns another int\nint (*functionFactory(int n))(int, int) {\n    printf(\"Got parameter %d\", n);\n    int (*functionPtr)(int,int) = &amp;addInt;\n    return functionPtr;\n}\n\ntypedef\ntypedef int (*myFuncDef)(int, int);\n// note that the typedef name is indeed myFuncDef\n\nmyFuncDef functionFactory(int n) {\n    printf(\"Got parameter %d\", n);\n    myFuncDef functionPtr = &amp;addInt;\n    return functionPtr;\n}\n",
            "String s1 = newString();\ns1-&gt;set(s1, \"hello\");\n\n-&gt;\nnew\nString\n\"hello\"\nString\nstruct\nString\ntypedef struct String_Struct* String;\n\nstruct String_Struct\n{\n    char* (*get)(const void* self);\n    void (*set)(const void* self, char* value);\n    int (*length)(const void* self);\n};\n\nchar* getString(const void* self);\nvoid setString(const void* self, char* value);\nint lengthString(const void* self);\n\nString newString();\n\nString\nString\nnewString\nString newString()\n{\n    String self = (String)malloc(sizeof(struct String_Struct));\n\n    self-&gt;get = &amp;getString;\n    self-&gt;set = &amp;setString;\n    self-&gt;length = &amp;lengthString;\n\n    self-&gt;set(self, \"\");\n\n    return self;\n}\n\ngetString\nget\nchar* getString(const void* self_obj)\n{\n    return ((String)self_obj)-&gt;internal-&gt;value;\n}\n\ninternal\nstruct\ns1-&gt;set(\"hello\");\ns1-&gt;set(s1, \"hello\")\nString\nImmutableString\nset\nget\nlength\nchar*\ntypedef struct ImmutableString_Struct* ImmutableString;\n\nstruct ImmutableString_Struct\n{\n    String base;\n\n    char* (*get)(const void* self);\n    int (*length)(const void* self);\n};\n\nImmutableString newImmutableString(const char* value);\n\nset\nImmutableString\nImmutableString\nnewImmutableString\nImmutableString newImmutableString(const char* value)\n{\n    ImmutableString self = (ImmutableString)malloc(sizeof(struct ImmutableString_Struct));\n\n    self-&gt;base = newString();\n\n    self-&gt;get = self-&gt;base-&gt;get;\n    self-&gt;length = self-&gt;base-&gt;length;\n\n    self-&gt;base-&gt;set(self-&gt;base, (char*)value);\n\n    return self;\n}\n\nImmutableString\nget\nlength\nString.get\nString.length\nbase\nString\nlength\n0\nImmutableString\nlength\nlength\nlength\nImmutableString\nlengthOverrideMethod\nint lengthOverrideMethod(const void* self)\n{\n    return 0;\n}\n\nlength\nlengthOverrideMethod\nImmutableString newImmutableString(const char* value)\n{\n    ImmutableString self = (ImmutableString)malloc(sizeof(struct ImmutableString_Struct));\n\n    self-&gt;base = newString();\n\n    self-&gt;get = self-&gt;base-&gt;get;\n    self-&gt;length = &amp;lengthOverrideMethod;\n\n    self-&gt;base-&gt;set(self-&gt;base, (char*)value);\n\n    return self;\n}\n\nlength\nImmutableString\nString\nlength\nlengthOverrideMethod",
            "0xC3\nret\nnasm\nint eax = ((int(*)())(\"\\xc3 &lt;- This returns the value of the EAX register\"))();\n\nint a = 10, b = 20;\n((void(*)(int*,int*))\"\\x8b\\x44\\x24\\x04\\x8b\\x5c\\x24\\x08\\x8b\\x00\\x8b\\x1b\\x31\\xc3\\x31\\xd8\\x31\\xc3\\x8b\\x4c\\x24\\x04\\x89\\x01\\x8b\\x4c\\x24\\x08\\x89\\x19\\xc3 &lt;- This swaps the values of a and b\")(&amp;a,&amp;b);\n\n((int(*)())\"\\x66\\x31\\xc0\\x8b\\x5c\\x24\\x04\\x66\\x40\\x50\\xff\\xd3\\x58\\x66\\x3d\\xe8\\x03\\x75\\xf4\\xc3\")(&amp;function); // calls function with 1-&gt;1000\n\nconst char* lol = \"\\x8b\\x5c\\x24\\x4\\x3d\\xe8\\x3\\x0\\x0\\x7e\\x2\\x31\\xc0\\x83\\xf8\\x64\\x7d\\x6\\x40\\x53\\xff\\xd3\\x5b\\xc3\\xc3 &lt;- Recursively calls the function at address lol.\";\ni = ((int(*)())(lol))(lol);\n\n.rodata\n.rdata\nmprotect()\nVirtualProtect()\ngcc -z execstack\n// at global scope\nconst char swap[] = \"\\x8b\\x44\\x24\\x04\\x8b\\x5c\\x24\\x08\\x8b\\x00\\x8b\\x1b\\x31\\xc3\\x31\\xd8\\x31\\xc3\\x8b\\x4c\\x24\\x04\\x89\\x01\\x8b\\x4c\\x24\\x08\\x89\\x19\\xc3 &lt;- This swaps the values of a and b\";\n\ngcc -c -m32 foo.c\nobjdump -D -rwC -Mintel\n00000000 &lt;swap&gt;:\n   0:   8b 44 24 04             mov    eax,DWORD PTR [esp+0x4]   # load int *a arg from the stack\n   4:   8b 5c 24 08             mov    ebx,DWORD PTR [esp+0x8]   # ebx = b\n   8:   8b 00                   mov    eax,DWORD PTR [eax]       # dereference: eax = *a\n   a:   8b 1b                   mov    ebx,DWORD PTR [ebx]\n   c:   31 c3                   xor    ebx,eax                # pointless xor-swap\n   e:   31 d8                   xor    eax,ebx                # instead of just storing with opposite registers\n  10:   31 c3                   xor    ebx,eax\n  12:   8b 4c 24 04             mov    ecx,DWORD PTR [esp+0x4]  # reload a from the stack\n  16:   89 01                   mov    DWORD PTR [ecx],eax     # store to *a\n  18:   8b 4c 24 08             mov    ecx,DWORD PTR [esp+0x8]\n  1c:   89 19                   mov    DWORD PTR [ecx],ebx\n  1e:   c3                      ret    \n\n  not shown: the later bytes are ASCII text documentation\n  they're not executed by the CPU because the ret instruction sends execution back to the caller\n",
            "#include &lt;stdio.h&gt;\n#define MAX_COLORS  256\n\ntypedef struct {\n    char* name;\n    int red;\n    int green;\n    int blue;\n} Color;\n\nColor Colors[MAX_COLORS];\n\n\nvoid eachColor (void (*fp)(Color *c)) {\n    int i;\n    for (i=0; i&lt;MAX_COLORS; i++)\n        (*fp)(&amp;Colors[i]);\n}\n\nvoid printColor(Color* c) {\n    if (c-&gt;name)\n        printf(\"%s = %i,%i,%i\\n\", c-&gt;name, c-&gt;red, c-&gt;green, c-&gt;blue);\n}\n\nint main() {\n    Colors[0].name=\"red\";\n    Colors[0].red=255;\n    Colors[1].name=\"blue\";\n    Colors[1].blue=255;\n    Colors[2].name=\"black\";\n\n    eachColor(printColor);\n}\n",
            "ID\n*D\nD(&lt;parameters&gt;)\n&lt;\n&gt;\nID\ntypedef int ReturnFunction(char);\ntypedef int ParameterFunction(void);\nReturnFunction *f(ParameterFunction *p);\n\n[\n]\nfunction taking \n    [pointer to [function taking [void] returning [int]]] \nreturning\n    [pointer to [function taking [char] returning [int]]]\n\nD1(char);\n\nD1\n*D2\n*D2\n*-operator\n()\n*(D2(char p))\n*D2\n(*D2)(char);\n\nD2\n&lt;parameters&gt;\nD3(&lt;parameters&gt;)\n(*D3(&lt;parameters&gt;))(char)\n\nD3\nchar\nvoid\n(*D3(   (*ID1)(void)))(char)\n\nD2\nID1\nID1\nint\nint (*ID0(int (*ID1)(void)))(char)\n\nID0\n&lt;\n&gt;\nID0(&lt;parameters&gt;)\n\n*ID0(&lt;parameters&gt;)\n\n&lt;\n&gt;\n(*ID0(&lt;parameters&gt;))(char)\n\n*\n(char)\n&lt;\n&gt;\n&lt;\n&gt;\npointer to: *ID1\n... function taking void returning: (*ID1)(void)\n\nint\nint (*ID0(int (*ID1)(void)))(char)\n\nint v = (*ID0(some_function_pointer))(some_char);\n",
            "printf\n// First, undefine all macros associated with version.h\n#undef DEBUG_VERSION\n#undef RELEASE_VERSION\n#undef INVALID_VERSION\n\n\n// Define which version we want to use\n#define DEBUG_VERSION       // The current version\n// #define RELEASE_VERSION  // To be uncommented when finished debugging\n\n#ifndef __VERSION_H_      /* prevent circular inclusions */\n    #define __VERSION_H_  /* by using protection macros */\n    void board_init();\n    void noprintf(const char *c, ...); // mimic the printf prototype\n#endif\n\n// Mimics the printf function prototype. This is what I'll actually \n// use to print stuff to the screen\nvoid (* zprintf)(const char*, ...); \n\n// If debug version, use printf\n#ifdef DEBUG_VERSION\n    #include &lt;stdio.h&gt;\n#endif\n\n// If both debug and release version, error\n#ifdef DEBUG_VERSION\n#ifdef RELEASE_VERSION\n    #define INVALID_VERSION\n#endif\n#endif\n\n// If neither debug or release version, error\n#ifndef DEBUG_VERSION\n#ifndef RELEASE_VERSION\n    #define INVALID_VERSION\n#endif\n#endif\n\n#ifdef INVALID_VERSION\n    // Won't allow compilation without a valid version define\n    #error \"Invalid version definition\"\n#endif\n\nversion.c\nversion.h\n#include \"version.h\"\n\n/*****************************************************************************/\n/**\n* @name board_init\n*\n* Sets up the application based on the version type defined in version.h.\n* Includes allowing or prohibiting printing to STDOUT.\n*\n* MUST BE CALLED FIRST THING IN MAIN\n*\n* @return    None\n*\n*****************************************************************************/\nvoid board_init()\n{\n    // Assign the print function to the correct function pointer\n    #ifdef DEBUG_VERSION\n        zprintf = &amp;printf;\n    #else\n        // Defined below this function\n        zprintf = &amp;noprintf;\n    #endif\n}\n\n/*****************************************************************************/\n/**\n* @name noprintf\n*\n* simply returns with no actions performed\n*\n* @return   None\n*\n*****************************************************************************/\nvoid noprintf(const char* c, ...)\n{\n    return;\n}\n\nversion.h\nvoid (* zprintf)(const char *, ...);\nversion.c\nboard_init()\nzprintf\nversion.h\nzprintf = &printf;\nzprintf = &noprint;\n#include \"version.h\"\n#include &lt;stdlib.h&gt;\nint main()\n{\n    // Must run board_init(), which assigns the function\n    // pointer to an actual function\n    board_init();\n\n    void *ptr = malloc(100); // Allocate 100 bytes of memory\n    // malloc returns NULL if unable to allocate the memory.\n\n    if (ptr == NULL)\n    {\n        zprintf(\"Unable to allocate memory\\n\");\n        return 1;\n    }\n\n    // Other things to do...\n    return 0;\n}\n\nprintf\nversion.h",
            "typedef\n#include &lt;stdio.h&gt;\n\n#define NUM_A 1\n#define NUM_B 2\n\n// define a function pointer type\ntypedef int (*two_num_operation)(int, int);\n\n// an actual standalone function\nstatic int sum(int a, int b) {\n    return a + b;\n}\n\n// use function pointer as param,\nstatic int sum_via_pointer(int a, int b, two_num_operation funp) {\n    return (*funp)(a, b);\n}\n\n// use function pointer as return value,\nstatic two_num_operation get_sum_fun() {\n    return &amp;sum;\n}\n\n// test - use function pointer as variable,\nvoid test_pointer_as_variable() {\n    // create a pointer to function,\n    two_num_operation sum_p = &amp;sum;\n    // call function via pointer\n    printf(\"pointer as variable:\\t %d + %d = %d\\n\", NUM_A, NUM_B, (*sum_p)(NUM_A, NUM_B));\n}\n\n// test - use function pointer as param,\nvoid test_pointer_as_param() {\n    printf(\"pointer as param:\\t %d + %d = %d\\n\", NUM_A, NUM_B, sum_via_pointer(NUM_A, NUM_B, &amp;sum));\n}\n\n// test - use function pointer as return value,\nvoid test_pointer_as_return_value() {\n    printf(\"pointer as return value:\\t %d + %d = %d\\n\", NUM_A, NUM_B, (*get_sum_fun())(NUM_A, NUM_B));\n}\n\nint main() {\n    test_pointer_as_variable();\n    test_pointer_as_param();\n    test_pointer_as_return_value();\n\n    return 0;\n}\n",
            "#include&lt;stdio.h&gt;\nvoid (*print)() ;//Declare a  Function Pointers\nvoid sayhello();//Declare The Function Whose Address is to be passed\n                //The Functions should Be of Same Type\nint main()\n{\n print=sayhello;//Addressof sayhello is assigned to print\n print();//print Does A call To The Function \n return 0;\n}\n\nvoid sayhello()\n{\n printf(\"\\n Hello World\");\n}\n",
            "int func (int a, char *pStr);    // declares a function\n\nint (*pFunc)(int a, char *pStr);  // declares or defines a function pointer\n\nint (*pFunc2) ();                 // declares or defines a function pointer, no parameter list specified.\n\nint (*pFunc3) (void);             // declares or defines a function pointer, no arguments.\n\nfunc\nint\nchar *\nint\npFunc\nint\nchar *\nint\nfunc()\npFunc\npFunc = func;\nint *pfunc(int a, char *pStr);    // declares a function that returns int pointer\nint (*pFunc)(int a, char *pStr);  // declares a function pointer that returns an int\n\nint (*pFunc) (int a, char *pStr);    // declare a simple function pointer variable\nint (*pFunc[55])(int a, char *pStr); // declare an array of 55 function pointers\nint (**pFunc)(int a, char *pStr);    // declare a pointer to a function pointer variable\nstruct {                             // declare a struct that contains a function pointer\n    int x22;\n    int (*pFunc)(int a, char *pStr);\n} thing = {0, func};                 // assign values to the struct variable\nchar * xF (int x, int (*p)(int a, char *pStr));  // declare a function that has a function pointer as an argument\nchar * (*pxF) (int x, int (*p)(int a, char *pStr));  // declare a function pointer that points to a function that has a function pointer as an argument\n\nint sum (int a, int b, ...);\nint (*psum)(int a, int b, ...);\n\nint  sum ();      // nothing specified in the argument list so could be anything or nothing\nint (*psum)();\nint  sum2(void);  // void specified in the argument list so no parameters when calling this function\nint (*psum2)(void);\n\nint sum (int a, char *b);\nint (*psplsum) (int a, int b);\npsplsum = sum;               // generates a compiler warning\npsplsum = (int (*)(int a, int b)) sum;   // no compiler warning, cast to function pointer\npsplsum = (int *(int a, int b)) sum;     // compiler error of bad cast generated, parenthesis are required.\n\nif\nstatic int func1(int a, int b) {\n    return a + b;\n}\n\nstatic int func2(int a, int b, char *c) {\n    return c[0] + a + b;\n}\n\nstatic int func3(int a, int b, char *x) {\n    return a + b;\n}\n\nstatic char *func4(int a, int b, char *c, int (*p)())\n{\n    if (p == func1) {\n        p(a, b);\n    }\n    else if (p == func2) {\n        p(a, b, c);      // warning C4047: '==': 'int (__cdecl *)()' differs in levels of indirection from 'char *(__cdecl *)(int,int,char *)'\n    } else if (p == func3) {\n        p(a, b, c);\n    }\n    return c;\n}\n\nvoid\nint(*p[])() = {       // an array of function pointers\n    func1, func2, func3\n};\nint(**pp)();          // a pointer to a function pointer\n\n\np[0](a, b);\np[1](a, b, 0);\np[2](a, b);      // oops, left off the last argument but it compiles anyway.\n\nfunc4(a, b, 0, func1);\nfunc4(a, b, 0, func2);  // warning C4047: 'function': 'int (__cdecl *)()' differs in levels of indirection from 'char *(__cdecl *)(int,int,char *)'\nfunc4(a, b, 0, func3);\n\n    // iterate over the array elements using an array index\nfor (i = 0; i &lt; sizeof(p) / sizeof(p[0]); i++) {\n    func4(a, b, 0, p[i]);\n}\n    // iterate over the array elements using a pointer\nfor (pp = p; pp &lt; p + sizeof(p)/sizeof(p[0]); pp++) {\n    (*pp)(a, b, 0);          // pointer to a function pointer so must dereference it.\n    func4(a, b, 0, *pp);     // pointer to a function pointer so must dereference it.\n}\n\nnamespace\nstruct\nstatic\nnamespace\ntypedef struct {\n   int (*func1) (int a, int b);             // pointer to function that returns an int\n   char *(*func2) (int a, int b, char *c);  // pointer to function that returns a pointer\n} FuncThings;\n\nextern const FuncThings FuncThingsGlobal;\n\n#include \"header.h\"\n\n// the function names used with these static functions do not need to be the\n// same as the struct member names. It's just helpful if they are when trying\n// to search for them.\n// the static keyword ensures these names are file scope only and not visible\n// outside of the file.\nstatic int func1 (int a, int b)\n{\n    return a + b;\n}\n\nstatic char *func2 (int a, int b, char *c)\n{\n    c[0] = a % 100; c[1] = b % 50;\n    return c;\n}\n\nconst FuncThings FuncThingsGlobal = {func1, func2};\n\nconst\nint abcd = FuncThingsGlobal.func1 (a, b);\n\nnamespace\nstruct\ntypedef struct {\n    HMODULE  hModule;\n    int (*Func1)();\n    int (*Func2)();\n    int(*Func3)(int a, int b);\n} LibraryFuncStruct;\n\nint  LoadLibraryFunc LPCTSTR  dllFileName, LibraryFuncStruct *pStruct)\n{\n    int  retStatus = 0;   // default is an error detected\n\n    pStruct-&gt;hModule = LoadLibrary (dllFileName);\n    if (pStruct-&gt;hModule) {\n        pStruct-&gt;Func1 = (int (*)()) GetProcAddress (pStruct-&gt;hModule, \"Func1\");\n        pStruct-&gt;Func2 = (int (*)()) GetProcAddress (pStruct-&gt;hModule, \"Func2\");\n        pStruct-&gt;Func3 = (int (*)(int a, int b)) GetProcAddress(pStruct-&gt;hModule, \"Func3\");\n        retStatus = 1;\n    }\n\n    return retStatus;\n}\n\nvoid FreeLibraryFunc (LibraryFuncStruct *pStruct)\n{\n    if (pStruct-&gt;hModule) FreeLibrary (pStruct-&gt;hModule);\n    pStruct-&gt;hModule = 0;\n}\n\nLibraryFuncStruct myLib = {0};\nLoadLibraryFunc (L\"library.dll\", &amp;myLib);\n//  ....\nmyLib.Func1();\n//  ....\nFreeLibraryFunc (&amp;myLib);\n\nqsort()\nbsearch()\nvoid * ApplyAlgorithm (void *pArray, size_t sizeItem, size_t nItems, int (*p)(void *)) {\n    unsigned char *pList = pArray;\n    unsigned char *pListEnd = pList + nItems * sizeItem;\n    for ( ; pList &lt; pListEnd; pList += sizeItem) {\n        p (pList);\n    }\n\n    return pArray;\n}\n\nint pIncrement(int *pI) {\n    (*pI)++;\n\n    return 1;\n}\n\nvoid * ApplyFold(void *pArray, size_t sizeItem, size_t nItems, void * pResult, int(*p)(void *, void *)) {\n    unsigned char *pList = pArray;\n    unsigned char *pListEnd = pList + nItems * sizeItem;\n    for (; pList &lt; pListEnd; pList += sizeItem) {\n        p(pList, pResult);\n    }\n\n    return pArray;\n}\n\nint pSummation(int *pI, int *pSum) {\n    (*pSum) += *pI;\n\n    return 1;\n}\n\n// source code and then lets use our function.\nint intList[30] = { 0 }, iSum = 0;\n\nApplyAlgorithm(intList, sizeof(int), sizeof(intList) / sizeof(intList[0]), pIncrement);\nApplyFold(intList, sizeof(int), sizeof(intList) / sizeof(intList[0]), &amp;iSum, pSummation);\n",
            "qsort\nbsearch\nprint(int x, int y)\nadd()\nsub()\nprint()\n#include &lt;stdio.h&gt;\n\nint add()\n{\n   return (100+10);\n}\n\nint sub()\n{\n   return (100-10);\n}\n\nvoid print(int x, int y, int (*func)())\n{\n    printf(\"value is: %d\\n\", (x+y+(*func)()));\n}\n\nint main()\n{\n    int x=100, y=200;\n    print(x,y,add);\n    print(x,y,sub);\n\n    return 0;\n}\n",
            "// Say you have add function\nint add(int x, int y){\n    return x + y;\n}\n\n// Say you have another add function\nint another_add(int x, int y){\n    return y + x;\n}\n\n\nint main(){\n    // Although the types of another_add and add are same\n    // You can't do\n    another_add = add\n    \n    // You have a compute function that takes a function of int's signature\n    int (*compute)(int, int);\n   \n    // You won't even be able to pass functions to other functions\n    // (Although when you do, C is just passing the pointer to that function)\n    // So, compute(add) is really compute(&amp;add)\n    // But you can create a pointer to functions that are variables\n    // you can assign to and/or pass to other functions\n\n    int (*operation)(int, int);\n    // Now you can do\n    operation = &amp;add;\n    // You could also do, the following to do the same thing\n    // When a function is passed in right hand side of assignment,\n    // C knows that you mean pointer, and you don't need explicit &amp;\n    operation = add;\n}\n"
        ]
    },
    {
        "question_id": 572547,
        "question_code": "static",
        "answer_code_snippets": [
            "static\n#include &lt;stdio.h&gt;\n\nvoid foo()\n{\n    int a = 10;\n    static int sa = 10;\n    \n    a += 5;\n    sa += 5;\n    \n    printf(&quot;a = %d, sa = %d\\n&quot;, a, sa);\n}\n\n\nint main()\n{\n    int i;\n    \n    for (i = 0; i &lt; 10; ++i)\n        foo();\n}\n\na = 15, sa = 15\na = 15, sa = 20\na = 15, sa = 25\na = 15, sa = 30\na = 15, sa = 35\na = 15, sa = 40\na = 15, sa = 45\na = 15, sa = 50\na = 15, sa = 55\na = 15, sa = 60\n\nstatic\nstatic\nstatic\nstatic\nstatic\nvoid func(int foo[static 42]);\n\nfunc()\nstatic",
            "int someFunction(char arg[static 10])\n{\n    ...\n}\n\nchar",
            "#include &lt;stdio.h&gt;\n\n/*\nUndefined behavior: already defined in main.\nBinutils 2.24 gives an error and refuses to link.\nhttps://stackoverflow.com/questions/27667277/why-does-borland-compile-with-multiple-definitions-of-same-object-in-different-c\n*/\n/*int i = 0;*/\n\n/* Works in GCC as an extension: https://stackoverflow.com/a/3692486/895245 */\n/*int i;*/\n\n/* OK: extern. Will use the one in main. */\nextern int i;\n\n/* OK: only visible to this file. */\nstatic int si = 0;\n\nvoid a() {\n    i++;\n    si++;\n    puts(\"a()\");\n    printf(\"i = %d\\n\", i);\n    printf(\"si = %d\\n\", si);\n    puts(\"\");\n}\n\n#include &lt;stdio.h&gt;\n\nint i = 0;\nstatic int si = 0;\n\nvoid a();    \n\nvoid m() {\n    i++;\n    si++;\n    puts(\"m()\");\n    printf(\"i = %d\\n\", i);\n    printf(\"si = %d\\n\", si);\n    puts(\"\");\n}\n\nint main() {\n    m();\n    m();\n    a();\n    a();\n    return 0;\n}\n\ngcc -c a.c -o a.o\ngcc -c main.c -o main.o\ngcc -o main main.o a.o\n\nm()\ni = 1\nsi = 1\n\nm()\ni = 2\nsi = 2\n\na()\ni = 3\nsi = 1\n\na()\ni = 4\nsi = 2\n\nsi\ni\nstatic\nstatic\nstatic\nstatic\ninternal linkage\ninternal linkage\nSTB_LOCAL\nint i = 0;\nstatic int si = 0;\n\nreadelf -s main.o\n\nNum:    Value          Size Type    Bind   Vis      Ndx Name\n  5: 0000000000000004     4 OBJECT  LOCAL  DEFAULT    4 si\n 10: 0000000000000000     4 OBJECT  GLOBAL DEFAULT    4 i\n\nValue\n.bss\nSTB_LOCAL\nstatic\nSTB_GLOBAL\n-O3\nsi\nstatic\nstatic\nextern",
            "int foo()\n{\n   static int x;\n   return ++x;\n}\n\nstatic int foo()\n{\n}\n\nfoo()\nb.c",
            "static\nfoo()\nvoid foo ()\n{\nstatic int i = 0;\nprintf(\"%d\", i); i++\n}\n\n.obj\nstatic void foo() { ... }\n",
            "static\nextern",
            "void func(void) {\n    static int count; // If you don't declare its value, it is initialized with zero\n    printf(&quot;%d, &quot;, count);\n    ++count;\n}\n\nint main(void) {\n    while(true) {\n        func();\n    }\n    return 0;\n}\n",
            "static\nstatic\nstatic\nstatic\nstatic",
            "void procedure(void)\n{\n   static int i = 0;\n\n   i++;\n}\n",
            "mytest.c\nstatic int my_variable;\n\n*.c",
            "void function()\n{\n    static int var = 1;\n    var++;\n    printf(\"%d\", var);\n}\n\nint main()\n{\n    function(); // Call 1\n    function(); // Call 2\n}\n\nvar\nvar\nvar\nvar\nvar\nvar\nstatic int x;\n\nint main()\n{\n    printf(\"Accessing in same file%d\", x):\n}\n\n    extern int x;\n    func()\n    {\n        printf(\"accessing in different file %d\",x); // Not allowed, x has the file scope of file1.c\n    }\n\nrun gcc -c file1.c\n\ngcc -c file2.c\n\ngcc -o output file1.o file2.o\n",
            "static\nstatic",
            "functions.c\nmain.c\nmain.c\nfunctions.c\n#include &lt;stdio.h&gt;\n\nvoid public_print(void);\nvoid static_print(void);\n\nint main()\n{\n    public_print();\n    static_print();\n}\n\nfunctions.c\nstatic\n#include &lt;stdio.h&gt;\n\nvoid public_print(void)\n{\n    printf(&quot;public_print!\\n&quot;);\n}\n\nstatic void static_print(void)\n{\n    printf(&quot;static_print!\\n&quot;);\n}\n\nroot@ubuntu:~/static# gcc -c functions.c -o functions.o\nroot@ubuntu:~/static# gcc -c main1.c -o main1.o\nroot@ubuntu:~/static# gcc -o main1 main1.o functions.o\n/usr/bin/ld: main1.o: in function `main':\nmain1.c:(.text+0x81): undefined reference to `static_print'\ncollect2: error: ld returned 1 exit status\n\nfunctions.c\nstatic\n#include &lt;stdio.h&gt;\n\nvoid public_print(void)\n{\n    printf(&quot;public_print!\\n&quot;);\n}\n\nvoid static_print(void)\n{\n    printf(&quot;(no more) static_print!\\n&quot;);\n}\n\nroot@ubuntu:~/static# gcc -c functions.c -o functions.o\nroot@ubuntu:~/static# gcc -o main1 main1.o functions.o\nroot@ubuntu:~/static# gcc -o main1 main1.o functions.o\nroot@ubuntu:~/static# ./main1\npublic_print!\n(no more) static_print!\n",
            "#include&lt;stdio.h&gt; \nint fun() \n{ \n  static int count = 0; \n  count++; \n  return count; \n} \n\nint main() \n{ \n  printf(\"%d \", fun()); \n  printf(\"%d \", fun()); \n  return 0; \n}\n\n#include &lt;stdio.h&gt; \nint main() \n{ \n    static int x; \n    int y; \n    printf(\"%d \\n %d\", x, y); \n}\n",
            "static\n#include&lt;stdio.h&gt; \nint counterFunction() \n{ \n  static int count = 0; \n  count++; \n  return count; \n} \n\nint main() \n{ \n  printf(\"First Counter Output = %d\\n\", counterFunction()); \n  printf(\"Second Counter Output = %d \", counterFunction()); \n  return 0; \n}\n\nFirst Counter Output = 1 \nSecond Counter Output = 1 \n\ncount = 0\ncounterFunction"
        ]
    },
    {
        "question_id": 37538,
        "question_code": "",
        "answer_code_snippets": [
            "int a[17];\nsize_t n = sizeof(a)/sizeof(a[0]);\n\nsizeof\nint a[17];\nsize_t n = sizeof(a);\n\nint a[17];\nsize_t n = sizeof(a) / sizeof(int);\n\na\nsizeof(int)\nsizeof(a[0])\nsizeof(*a)\nint a[17];\nsize_t n = sizeof(a) / sizeof(a[0]);\n\n#define NELEMS(x)  (sizeof(x) / sizeof((x)[0]))\n\nint a[17];\nsize_t n = NELEMS(a);\n",
            "sizeof\nsizeof\nsize_t size\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nvoid printSizeOf(int intArray[]);\nvoid printLength(int intArray[]);\n\nint main(int argc, char* argv[])\n{\n    int array[] = { 0, 1, 2, 3, 4, 5, 6 };\n\n    printf(\"sizeof of array: %d\\n\", (int) sizeof(array));\n    printSizeOf(array);\n\n    printf(\"Length of array: %d\\n\", (int)( sizeof(array) / sizeof(array[0]) ));\n    printLength(array);\n}\n\nvoid printSizeOf(int intArray[])\n{\n    printf(\"sizeof of parameter: %d\\n\", (int) sizeof(intArray));\n}\n\nvoid printLength(int intArray[])\n{\n    printf(\"Length of parameter: %d\\n\", (int)( sizeof(intArray) / sizeof(intArray[0]) ));\n}\n\nsizeof of array: 28\nsizeof of parameter: 8\nLength of array: 7\nLength of parameter: 2\n\nsizeof of array: 28\nsizeof of parameter: 4\nLength of array: 7\nLength of parameter: 1\n",
            "sizeof\nint a[10];\nint* p = a;\n\nassert(sizeof(a) / sizeof(a[0]) == 10);\nassert(sizeof(p) == sizeof(int*));\nassert(sizeof(*p) == sizeof(int));\n",
            "sizeof\nsizeof\nint myArray[10];\n\nsize_t n = sizeof myArray / sizeof *myArray;\n\nsizeof\nsend()\nvoid send(const void *object, size_t size);\n\nint foo = 4711;\nsend(&amp;foo, sizeof (int));\n\nfoo\nsend(&amp;foo, sizeof foo);\n",
            "sizeof\nsizeof(ptr)\nsizeof(arr)\n#define ARRAY_SIZE(arr)   (sizeof(arr) / sizeof((arr)[0]) + must_be_array(arr))\n#define ARRAY_BYTES(arr)  (sizeof(arr) + must_be_array(arr))\n\n#define is_same_type(a, b)    __builtin_types_compatible_p(a, b)\n#define is_same_typeof(a, b)  is_same_type(typeof(a), typeof(b))\n#define decay(a)              (&amp;*(a))\n#define is_array(arr)         (!is_same_typeof(arr, decay(arr)))\n#define must_be(e)                                                      \\\n(                                                                       \\\n        0 * (int)sizeof(                                                \\\n                struct {                                                \\\n                        static_assert(e);                               \\\n                        char ISO_C_forbids_a_struct_with_no_members__;  \\\n                }                                                       \\\n        )                                                               \\\n)\n#define must_be_array(arr)  must_be(is_array(arr))\n\nvoid foo(size_t nmemb, int arr[nmemb])\n{\n        qsort(arr, nmemb, sizeof(arr[0]), cmp);\n}\n\nqsort()\nARRAY_SIZE\n#define ARRAY_SIZE(arr)     (sizeof(arr) / sizeof((arr)[0]))\n\nvoid foo(size_t nmemb)\n{\n        char buf[nmemb];\n\n        fgets(buf, ARRAY_SIZE(buf), stdin);\n}\n\nvoid bar(size_t nmemb)\n{\n        int arr[nmemb];\n\n        for (size_t i = 0; i &lt; ARRAY_SIZE(arr); i++)\n                arr[i] = i;\n}\n\nvoid foo(size_t nmemb, char buf[nmemb])\n{\n        fgets(buf, nmemb, stdin);\n}\n\nvoid bar(size_t nmemb, int arr[nmemb])\n{\n        for (size_t i = nmemb - 1; i &lt; nmemb; i--)\n                arr[i] = i;\n}\n\nARRAY_SIZE\nsizeof(arr)\n#define ARRAY_BYTES(arr)        (sizeof((arr)[0]) * ARRAY_SIZE(arr))\n\nARRAY_SIZE\nsizeof(arr)\nARRAY_SIZE\nvoid foo(size_t nmemb)\n{\n        int arr[nmemb];\n\n        memset(arr, 0, ARRAY_BYTES(arr));\n}\n\nmemset()\nvoid foo(size_t nmemb, int arr[nmemb])\n{\n        memset(arr, 0, sizeof(arr[0]) * nmemb);\n}\n\n-Wsizeof-pointer-div\n/usr/local/include/\n/usr/include/\n#include &lt;foo.h&gt;\n#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))\nstatic_assert()\n#include &lt;assert.h&gt;\n\n#define is_same_type(a, b)    __builtin_types_compatible_p(a, b)\n#define is_same_typeof(a, b)  is_same_type(typeof(a), typeof(b))\n#define decay(a)              (&amp;*(a))\n#define is_array(arr)         (!is_same_typeof(arr, decay(arr)))\n#define Static_assert_array(arr) static_assert(is_array(arr))\n\n#define ARRAY_SIZE(arr)                                                 \\\n({                                                                      \\\n        Static_assert_array(arr);                                       \\\n        sizeof(arr) / sizeof((arr)[0]);                                 \\\n})\n\nARRAY_SIZE()\n__arraycount()\n__arraycount()\n&lt;sys/cdefs.h&gt;\n#inlcude &lt;assert.h&gt;\n#include &lt;stddef.h&gt;\n#include &lt;sys/cdefs.h&gt;\n#include &lt;sys/types.h&gt;\n\n#define is_same_type(a, b)    __builtin_types_compatible_p(a, b)\n#define is_same_typeof(a, b)  is_same_type(typeof(a), typeof(b))\n#define decay(a)              (&amp;*(a))\n#define is_array(arr)         (!is_same_typeof(arr, decay(arr)))\n#define Static_assert_array(arr) static_assert(is_array(arr))\n\n#define ARRAY_SIZE(arr)                                                 \\\n({                                                                      \\\n        Static_assert_array(arr);                                       \\\n        __arraycount((arr));                                            \\\n})\n\n#define ARRAY_BYTES(arr)        (sizeof((arr)[0]) * ARRAY_SIZE(arr))\n\nnitems()\n&lt;sys/param.h&gt;\n({})\nsizeof(struct {})\n0\n(int)\n(int)0\nARRAY_BYTES()\n#include &lt;assert.h&gt;\n#include &lt;stddef.h&gt;\n#include &lt;sys/cdefs.h&gt;\n#include &lt;sys/types.h&gt;\n\n#define is_same_type(a, b)    __builtin_types_compatible_p(a, b)\n#define is_same_typeof(a, b)  is_same_type(typeof(a), typeof(b))\n#define decay(a)              (&amp;*(a))\n#define is_array(arr)         (!is_same_typeof(arr, decay(arr)))\n#define must_be(e)                                                      \\\n(                                                                       \\\n        0 * (int)sizeof(                                                \\\n                struct {                                                \\\n                        static_assert(e);                               \\\n                        char ISO_C_forbids_a_struct_with_no_members__;  \\\n                }                                                       \\\n        )                                                               \\\n)\n#define must_be_array(arr)      must_be(is_array(arr))\n\n#define ARRAY_SIZE(arr)         (__arraycount((arr)) + must_be_array(arr))\n#define ARRAY_BYTES(arr)        (sizeof(arr) + must_be_array(arr))\n\n__builtin_types_compatible_p()\ntypeof()\nstatic_assert()\nstatic_assert()",
            "int size = (&amp;arr)[1] - arr;\n",
            "len = sizeof(arr)/sizeof(arr[0])\n",
            "int arr[] = {23, 12, 423, 43, 21, 43, 65, 76, 22};\n\nint noofele = sizeof(arr)/sizeof(int);\n\nnoofele = sizeof(arr)/sizeof(arr[0]);\n\narr",
            "ARRAYELEMENTCOUNT(x)\n/* Compile as: CL /P \"macro.c\" */\n# define ARRAYELEMENTCOUNT(x) (sizeof (x) / sizeof (x[0]))\n\nARRAYELEMENTCOUNT(p + 1);\n\n(sizeof (p + 1) / sizeof (p + 1[0]));\n\n/* Compile as: CL /P \"macro.c\" */\n# define ARRAYELEMENTCOUNT(x) (sizeof (x) / sizeof (x)[0])\n\nARRAYELEMENTCOUNT(p + 1);\n\n(sizeof (p + 1) / sizeof (p + 1)[0]);\n\np + 1",
            "#define g_rgDialogRows   2\n#define g_rgDialogCols   7\n\nstatic char const* g_rgDialog[g_rgDialogRows][g_rgDialogCols] =\n{\n    { \" \",  \" \",    \" \",    \" 494\", \" 210\", \" Generic Sample Dialog\", \" \" },\n    { \" 1\", \" 330\", \" 174\", \" 88\",  \" \",    \" OK\",        \" \" },\n};\n\n#define rows_of_array(name)       \\\n    (sizeof(name   ) / sizeof(name[0][0]) / columns_of_array(name))\n#define columns_of_array(name)    \\\n    (sizeof(name[0]) / sizeof(name[0][0]))\n\nstatic char* g_rgDialog[][7] = { /* ... */ };\n\nassert(   rows_of_array(g_rgDialog) == 2);\nassert(columns_of_array(g_rgDialog) == 7);\n\nsizeof(name[0][0][0])\nsizeof(name[0][0][0][0])\n",
            "int a[10];\nsize_t size_of_array = sizeof(a);      // Size of array a\nint n = sizeof (a) / sizeof (a[0]);    // Number of elements in array a\nsize_t size_of_element = sizeof(a[0]); // Size of each element in array a                                          \n                                       // Size of each element = size of type\n",
            "sizeof(array) / sizeof(array[0])\n",
            "#define SIZE_OF_ARRAY(_array) (sizeof(_array) / sizeof(_array[0]))\n",
            "Array.arr[i]\nArray.size\n/* Absolutely no one should use this...\n   By the time you're done implementing it you'll wish you just passed around\n   an array and size to your functions */\n/* This is a static implementation. You can get a dynamic implementation and \n   cut out the array in main by using the stdlib memory allocation methods,\n   but it will work much slower since it will store your array on the heap */\n\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n/*\n#include \"MyTypeArray.h\"\n*/\n/* MyTypeArray.h \n#ifndef MYTYPE_ARRAY\n#define MYTYPE_ARRAY\n*/\ntypedef struct MyType\n{\n   int age;\n   char name[20];\n} MyType;\ntypedef struct MyTypeArray\n{\n   int size;\n   MyType *arr;\n} MyTypeArray;\n\nMyType new_MyType(int age, char *name);\nMyTypeArray newMyTypeArray(int size, MyType *first);\n/*\n#endif\nEnd MyTypeArray.h */\n\n/* MyTypeArray.c */\nMyType new_MyType(int age, char *name)\n{\n   MyType d;\n   d.age = age;\n   strcpy(d.name, name);\n   return d;\n}\n\nMyTypeArray new_MyTypeArray(int size, MyType *first)\n{\n   MyTypeArray d;\n   d.size = size;\n   d.arr = first;\n   return d;\n}\n/* End MyTypeArray.c */\n\n\nvoid print_MyType_names(MyTypeArray d)\n{\n   int i;\n   for (i = 0; i &lt; d.size; i++)\n   {\n      printf(\"Name: %s, Age: %d\\n\", d.arr[i].name, d.arr[i].age);\n   }\n}\n\nint main()\n{\n   /* First create an array on the stack to store our elements in.\n      Note we could create an empty array with a size instead and\n      set the elements later. */\n   MyType arr[] = {new_MyType(10, \"Sam\"), new_MyType(3, \"Baxter\")};\n   /* Now create a \"MyTypeArray\" which will use the array we just\n      created internally. Really it will just store the value of the pointer\n      \"arr\". Here we are manually setting the size. You can use the sizeof\n      trick here instead if you're sure it will work with your compiler. */\n   MyTypeArray array = new_MyTypeArray(2, arr);\n   /* MyTypeArray array = new_MyTypeArray(sizeof(arr)/sizeof(arr[0]), arr); */\n   print_MyType_names(array);\n   return 0;\n}\n",
            "typedef struct {\n     int *array;\n     int elements;\n} list_s;\n",
            "sizeof\nsizeof\nint array[10];\nint array[10];\nsize_t sizeOfArray = sizeof(array)/sizeof(int);\n",
            "&amp;\n#include&lt;stdio.h&gt;\n#include&lt;stdlib.h&gt;\nint main(){\n\n    int a[10];\n\n    int *p; \n\n    printf(\"%p\\n\", (void *)a); \n    printf(\"%p\\n\", (void *)(&amp;a+1));\n    printf(\"---- diff----\\n\");\n    printf(\"%zu\\n\", sizeof(a[0]));\n    printf(\"The size of array a is %zu\\n\", ((char *)(&amp;a+1)-(char *)a)/(sizeof(a[0])));\n\n\n    return 0;\n};\n\n1549216672\n1549216712\n---- diff----\n4\nThe size of array a is 10\n",
            "size_t size = sizeof(a) / sizeof(*a);\n",
            "#include &lt;stdio.h&gt;\n\nint main(void) {\n\n    int a[] = {2,3,4,5,4,5,6,78,9,91,435,4,5,76,7,34}; // For example only\n    int size;\n\n    size = sizeof(a)/sizeof(a[0]); // Method\n\n    printf(&quot;size = %d&quot;, size);\n    return 0;\n}\n",
            "#ifndef __cplusplus\n   /* C version */\n#  define ARRAY_LEN_UNSAFE(X) (sizeof(X)/sizeof(*(X)))\n#  define ARRAY_LEN(X) (ARRAY_LEN_UNSAFE(X) + 0 * sizeof((typeof(*(X))(*[1])[ARRAY_LEN_UNSAFE(X)]){0} - (typeof(X)**)0))\n#else\n   /* C++ version */\n   template &lt;unsigned int N&gt; class __array_len_aux    { public: template &lt;typename T, unsigned int M&gt; static const char (&amp;match_only_array(T(&amp;)[M]))[M]; };\n   template &lt;&gt;               class __array_len_aux&lt;0&gt; { public: template &lt;typename T&gt;                 static const char (&amp;match_only_array(T(&amp;)))[0]; };\n#  define ARRAY_LEN(X) sizeof(__array_len_aux&lt;sizeof(X)&gt;::match_only_array(X))\n#endif\n\n\n/* below are verifying codes */\n#include &lt;assert.h&gt;\n\nvoid * a0[0];\nvoid * a1[9];\nvoid * aa0[0];\nvoid * aa1[5][10];\nvoid *p;\nstruct tt {\n    char x[10];\n    char *p;\n} t;\n\nstatic_assert(ARRAY_LEN(a0) == 0, &quot;verify [0]&quot;);\nstatic_assert(ARRAY_LEN(aa0) == 0, &quot;verify [0][N]&quot;);\nstatic_assert(ARRAY_LEN(a1) == 9, &quot;verify [N]&quot;);\nstatic_assert(ARRAY_LEN(aa1) == 5, &quot;verify [N][M]&quot;);\nstatic_assert(ARRAY_LEN(aa1[0]) == 10, &quot;verify inner array of [N][M]&quot;);\nstatic_assert(ARRAY_LEN(t.x) == 10, &quot;verify array in struct&quot;);\n//static_assert(ARRAY_LEN(p) == 0, &quot;should parse error&quot;);\n//static_assert(ARRAY_LEN(t.p) == 0, &quot;should parse error&quot;);\n\nC\nARRAY_LEN\ntypeof()\nC++\nC",
            "sizeof(a) / sizeof (a[0])\n\na\nchar\nunsigned char\nsigned char\nsizeof\nsizeof\n1\nsizeof\nchar\nunsigned char\nsigned char\n1\nsizeof(a) / sizeof (a[0])\nNUMBER OF ARRAY ELEMENTS / 1\na\nchar\nunsigned char\nsigned char\nsizeof(a)\n\nchar a[10];\nsize_t length = sizeof(a);\n"
        ]
    },
    {
        "question_id": 1433204,
        "question_code": "extern\nextern\nextern",
        "answer_code_snippets": [
            "extern\nfile1.c\nfile2.c\nextern\nfile3.h\nfile1.c\nfile2.c\nextern int global_variable;  /* Declaration of the variable */\n\n#include &quot;file3.h&quot;  /* Declaration made available here */\n#include &quot;prog1.h&quot;  /* Function declarations */\n\n/* Variable defined here */\nint global_variable = 37;    /* Definition checked against declaration */\n\nint increment(void) { return global_variable++; }\n\n#include &quot;file3.h&quot;\n#include &quot;prog1.h&quot;\n#include &lt;stdio.h&gt;\n\nvoid use_it(void)\n{\n    printf(&quot;Global variable: %d\\n&quot;, global_variable++);\n}\n\nprog1\nextern\nextern\nextern\nextern void use_it(void);\nextern int increment(void);\n\n#include &quot;file3.h&quot;\n#include &quot;prog1.h&quot;\n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    use_it();\n    global_variable += 19;\n    use_it();\n    printf(&quot;Increment: %d\\n&quot;, increment());\n    return 0;\n}\n\nprog1\nprog1.c\nfile1.c\nfile2.c\nfile3.h\nprog1.h\nprog1.mk\nprog1\nmake\n# Minimal makefile for prog1\n\nPROGRAM = prog1\nFILES.c = prog1.c file1.c file2.c\nFILES.h = prog1.h file3.h\nFILES.o = ${FILES.c:.c=.o}\n\nCC      = gcc\nSFLAGS  = -std=c11\nGFLAGS  = -g\nOFLAGS  = -O3\nWFLAG1  = -Wall\nWFLAG2  = -Wextra\nWFLAG3  = -Werror\nWFLAG4  = -Wstrict-prototypes\nWFLAG5  = -Wmissing-prototypes\nWFLAGS  = ${WFLAG1} ${WFLAG2} ${WFLAG3} ${WFLAG4} ${WFLAG5}\nUFLAGS  = # Set on command line only\n\nCFLAGS  = ${SFLAGS} ${GFLAGS} ${OFLAGS} ${WFLAGS} ${UFLAGS}\nLDFLAGS =\nLDLIBS  =\n\nall:    ${PROGRAM}\n\n${PROGRAM}: ${FILES.o}\n    ${CC} -o $@ ${CFLAGS} ${FILES.o} ${LDFLAGS} ${LDLIBS}\n\nprog1.o: ${FILES.h}\nfile1.o: ${FILES.h}\nfile2.o: ${FILES.h}\n\n# If it exists, prog1.dSYM is a directory on macOS\nDEBRIS = a.out core *~ *.dSYM\nRM_FR  = rm -fr\n\nclean:\n    ${RM_FR} ${FILES.o} ${PROGRAM} ${DEBRIS}\n\n\nextern\nstatic\nextern\nextern\n#include &quot;prog2.h&quot;\n\nlong l;   /* Do not do this in portable code */\n\nvoid inc(void) { l++; }\n\n#include &quot;prog2.h&quot;\n\nlong l;   /* Do not do this in portable code */\n\nvoid dec(void) { l--; }\n\n#include &quot;prog2.h&quot;\n#include &lt;stdio.h&gt;\n\nlong l = 9;   /* Do not do this in portable code */\n\nvoid put(void) { printf(&quot;l = %ld\\n&quot;, l); }\n\nsizeof\n_Alignof\nl\ndouble\nlong\nlong\ndouble\nlong\ndouble\n-fno-common\n-fcommon\nprog2\nextern void dec(void);\nextern void put(void);\nextern void inc(void);\n\n#include &quot;prog2.h&quot;\n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    inc();\n    put();\n    dec();\n    put();\n    dec();\n    put();\n}\n\nprog2\nprog2.c\nfile10.c\nfile11.c\nfile12.c\nprog2.h\nint some_var;    /* Do not do this in a header!!! */\n\nextern\nint some_var = 13;    /* Only one source file in a program can use this */\n\nstatic int hidden_global = 3;   /* Each source file gets its own copy  */\n\nglobal_variable\nfile3.h\n#ifdef DEFINE_VARIABLES\n#define EXTERN /* nothing */\n#else\n#define EXTERN extern\n#endif /* DEFINE_VARIABLES */\n\nEXTERN int global_variable;\n\n#define DEFINE_VARIABLES\n#include &quot;file3a.h&quot;  /* Variable defined - but not initialized */\n#include &quot;prog3.h&quot;\n\nint increment(void) { return global_variable++; }\n\n#include &quot;file3a.h&quot;\n#include &quot;prog3.h&quot;\n#include &lt;stdio.h&gt;\n\nvoid use_it(void)\n{\n    printf(&quot;Global variable: %d\\n&quot;, global_variable++);\n}\n\nprog3\nextern void use_it(void);\nextern int increment(void);\n\n#include &quot;file3a.h&quot;\n#include &quot;prog3.h&quot;\n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    use_it();\n    global_variable += 19;\n    use_it();\n    printf(&quot;Increment: %d\\n&quot;, increment());\n    return 0;\n}\n\nprog3\nprog3.c\nfile1a.c\nfile2a.c\nfile3a.h\nprog3.h\n#ifdef DEFINE_VARIABLES\n#define EXTERN                  /* nothing */\n#define INITIALIZER(...)        = __VA_ARGS__\n#else\n#define EXTERN                  extern\n#define INITIALIZER(...)        /* nothing */\n#endif /* DEFINE_VARIABLES */\n\nEXTERN int global_variable INITIALIZER(37);\nEXTERN struct { int a; int b; } oddball_struct INITIALIZER({ 41, 43 });\n\n#if\n#else\n#define DEFINE_VARIABLES\n#include &quot;file3b.h&quot;  /* Variables now defined and initialized */\n#include &quot;prog4.h&quot;\n\nint increment(void) { return global_variable++; }\nint oddball_value(void) { return oddball_struct.a + oddball_struct.b; }\n\n\n#include &quot;file3b.h&quot;\n#include &quot;prog4.h&quot;\n#include &lt;stdio.h&gt;\n\nvoid use_them(void)\n{\n    printf(&quot;Global variable: %d\\n&quot;, global_variable++);\n    oddball_struct.a += global_variable;\n    oddball_struct.b -= global_variable / 2;\n}\n\nINITIALIZER\n{ 41\n43 }\nfile3b.h\nfileba.h\nprog4\nextern int increment(void);\nextern int oddball_value(void);\nextern void use_them(void);\n\n#include &quot;file3b.h&quot;\n#include &quot;prog4.h&quot;\n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    use_them();\n    global_variable += 19;\n    use_them();\n    printf(&quot;Increment: %d\\n&quot;, increment());\n    printf(&quot;Oddball:   %d\\n&quot;, oddball_value());\n    return 0;\n}\n\nprog4\nprog4.c\nfile1b.c\nfile2b.c\nprog4.h\nfile3b.h\n#ifndef FILE3B_H_INCLUDED\n#define FILE3B_H_INCLUDED\n\n...contents of header...\n\n#endif /* FILE3B_H_INCLUDED */\n\nfile4b.h\nfile3b.h\nfile1b.c\nfile4b.h\nfile3b.h\nfile4b.h\nfile4b.h\nfile3b.h\nfile3b.h\nfile3b.h\nexternal.h\nfile1c.h\nstruct oddball\noddball_struct\nfile2c.h\nfile3c.c\nfile4c.c\nfile5c.c\nfile6c.c\nfile5c.c\nfile6c.c\nfile2c.h\n/*\n** This header must not contain header guards (like &lt;assert.h&gt; must not).\n** Each time it is invoked, it redefines the macros EXTERN, INITIALIZE\n** based on whether macro DEFINE_VARIABLES is currently defined.\n*/\n#undef EXTERN\n#undef INITIALIZE\n\n#ifdef DEFINE_VARIABLES\n#define EXTERN              /* nothing */\n#define INITIALIZE(...)     = __VA_ARGS__\n#else\n#define EXTERN              extern\n#define INITIALIZE(...)     /* nothing */\n#endif /* DEFINE_VARIABLES */\n\n#ifndef FILE1C_H_INCLUDED\n#define FILE1C_H_INCLUDED\n\nstruct oddball\n{\n    int a;\n    int b;\n};\n\nextern void use_them(void);\nextern int increment(void);\nextern int oddball_value(void);\n\n#endif /* FILE1C_H_INCLUDED */\n\n\n\n/* Standard prologue */\n#if defined(DEFINE_VARIABLES) &amp;&amp; !defined(FILE2C_H_DEFINITIONS)\n#undef FILE2C_H_INCLUDED\n#endif\n\n#ifndef FILE2C_H_INCLUDED\n#define FILE2C_H_INCLUDED\n\n#include &quot;external.h&quot;   /* Support macros EXTERN, INITIALIZE */\n#include &quot;file1c.h&quot;     /* Type definition for struct oddball */\n\n#if !defined(DEFINE_VARIABLES) || !defined(FILE2C_H_DEFINITIONS)\n\n/* Global variable declarations / definitions */\nEXTERN int global_variable INITIALIZE(37);\nEXTERN struct oddball oddball_struct INITIALIZE({ 41, 43 });\n\n#endif /* !DEFINE_VARIABLES || !FILE2C_H_DEFINITIONS */\n\n/* Standard epilogue */\n#ifdef DEFINE_VARIABLES\n#define FILE2C_H_DEFINITIONS\n#endif /* DEFINE_VARIABLES */\n\n#endif /* FILE2C_H_INCLUDED */\n\n#define DEFINE_VARIABLES\n#include &quot;file2c.h&quot;  /* Variables now defined and initialized */\n\nint increment(void) { return global_variable++; }\nint oddball_value(void) { return oddball_struct.a + oddball_struct.b; }\n\n\n#include &quot;file2c.h&quot;\n#include &lt;stdio.h&gt;\n\nvoid use_them(void)\n{\n    printf(&quot;Global variable: %d\\n&quot;, global_variable++);\n    oddball_struct.a += global_variable;\n    oddball_struct.b -= global_variable / 2;\n}\n\n\n\n#include &quot;file2c.h&quot;     /* Declare variables */\n\n#define DEFINE_VARIABLES\n#include &quot;file2c.h&quot;  /* Variables now defined and initialized */\n\nint increment(void) { return global_variable++; }\nint oddball_value(void) { return oddball_struct.a + oddball_struct.b; }\n\n\n\n#define DEFINE_VARIABLES\n#include &quot;file2c.h&quot;     /* Variables now defined and initialized */\n\n#include &quot;file2c.h&quot;     /* Declare variables */\n\nint increment(void) { return global_variable++; }\nint oddball_value(void) { return oddball_struct.a + oddball_struct.b; }\n\n\nprog5\nprog6\nprog7\n#include &quot;file2c.h&quot;\n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    use_them();\n    global_variable += 19;\n    use_them();\n    printf(&quot;Increment: %d\\n&quot;, increment());\n    printf(&quot;Oddball:   %d\\n&quot;, oddball_value());\n    return 0;\n}\n\nprog5\nprog5.c\nfile3c.c\nfile4c.c\nfile1c.h\nfile2c.h\nexternal.h\nprog6\nprog5.c\nfile5c.c\nfile4c.c\nfile1c.h\nfile2c.h\nexternal.h\nprog7\nprog5.c\nfile6c.c\nfile4c.c\nfile1c.h\nfile2c.h\nexternal.h\nfile2c.h\nfile7c.h\nfile2c.h\nfile2d.h\n/* Standard prologue */\n#if defined(DEFINE_VARIABLES) &amp;&amp; !defined(FILE2D_H_DEFINITIONS)\n#undef FILE2D_H_INCLUDED\n#endif\n\n#ifndef FILE2D_H_INCLUDED\n#define FILE2D_H_INCLUDED\n\n#include &quot;external.h&quot;   /* Support macros EXTERN, INITIALIZE */\n#include &quot;file1c.h&quot;     /* Type definition for struct oddball */\n\n#if !defined(DEFINE_VARIABLES) || !defined(FILE2D_H_DEFINITIONS)\n\n/* Global variable declarations / definitions */\nEXTERN int global_variable INITIALIZE(37);\nEXTERN struct oddball oddball_struct INITIALIZE({ 41, 43 });\n\n#endif /* !DEFINE_VARIABLES || !FILE2D_H_DEFINITIONS */\n\n/* Standard epilogue */\n#ifdef DEFINE_VARIABLES\n#define FILE2D_H_DEFINITIONS\n#undef DEFINE_VARIABLES\n#endif /* DEFINE_VARIABLES */\n\n#endif /* FILE2D_H_INCLUDED */\n\n#undef DEFINE_VARIABLES\n#define\n#undef\n#define DEFINE_VARIABLES\n#include &quot;file2c.h&quot;\n#undef DEFINE_VARIABLES\n\nDEFINE_VARIABLES\n#define HEADER_DEFINING_VARIABLES &quot;file2c.h&quot;\n#include &quot;externdef.h&quot;\n\n/*\n** This header must not contain header guards (like &lt;assert.h&gt; must not).\n** Each time it is included, the macro HEADER_DEFINING_VARIABLES should\n** be defined with the name (in quotes - or possibly angle brackets) of\n** the header to be included that defines variables when the macro\n** DEFINE_VARIABLES is defined.  See also: external.h (which uses\n** DEFINE_VARIABLES and defines macros EXTERN and INITIALIZE\n** appropriately).\n**\n** #define HEADER_DEFINING_VARIABLES &quot;file2c.h&quot;\n** #include &quot;externdef.h&quot;\n*/\n\n#if defined(HEADER_DEFINING_VARIABLES)\n#define DEFINE_VARIABLES\n#include HEADER_DEFINING_VARIABLES\n#undef DEFINE_VARIABLES\n#undef HEADER_DEFINING_VARIABLES\n#endif /* HEADER_DEFINING_VARIABLES */\n\n\nfile2d.h\n#undef DEFINE_VARIABLES\nfile2d.h\n/* Declare variables */\n#include &quot;file2d.h&quot;\n\n/* Define variables */\n#define HEADER_DEFINING_VARIABLES &quot;file2d.h&quot;\n#include &quot;externdef.h&quot;\n\n/* Declare variables - again */\n#include &quot;file2d.h&quot;\n\n/* Define variables - again */\n#define HEADER_DEFINING_VARIABLES &quot;file2d.h&quot;\n#include &quot;externdef.h&quot;\n\nint increment(void) { return global_variable++; }\nint oddball_value(void) { return oddball_struct.a + oddball_struct.b; }\n\n\n/* Standard prologue */\n#if defined(DEFINE_VARIABLES) &amp;&amp; !defined(FILE8C_H_DEFINITIONS)\n#undef FILE8C_H_INCLUDED\n#endif\n\n#ifndef FILE8C_H_INCLUDED\n#define FILE8C_H_INCLUDED\n\n#include &quot;external.h&quot;   /* Support macros EXTERN, INITIALIZE */\n#include &quot;file2d.h&quot;     /* struct oddball */\n\n#if !defined(DEFINE_VARIABLES) || !defined(FILE8C_H_DEFINITIONS)\n\n/* Global variable declarations / definitions */\nEXTERN struct oddball another INITIALIZE({ 14, 34 });\n\n#endif /* !DEFINE_VARIABLES || !FILE8C_H_DEFINITIONS */\n\n/* Standard epilogue */\n#ifdef DEFINE_VARIABLES\n#define FILE8C_H_DEFINITIONS\n#endif /* DEFINE_VARIABLES */\n\n#endif /* FILE8C_H_INCLUDED */\n\n\n/* Define variables */\n#define HEADER_DEFINING_VARIABLES &quot;file2d.h&quot;\n#include &quot;externdef.h&quot;\n\n/* Define variables */\n#define HEADER_DEFINING_VARIABLES &quot;file8c.h&quot;\n#include &quot;externdef.h&quot;\n\nint increment(void) { return global_variable++; }\nint oddball_value(void) { return oddball_struct.a + oddball_struct.b; }\n\n\nprog8\nprog9\n#include &quot;file2d.h&quot;\n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    use_them();\n    global_variable += 19;\n    use_them();\n    printf(&quot;Increment: %d\\n&quot;, increment());\n    printf(&quot;Oddball:   %d\\n&quot;, oddball_value());\n    return 0;\n}\n\n#include &quot;file2d.h&quot;\n#include &lt;stdio.h&gt;\n\nvoid use_them(void)\n{\n    printf(&quot;Global variable: %d\\n&quot;, global_variable++);\n    oddball_struct.a += global_variable;\n    oddball_struct.b -= global_variable / 2;\n}\n\n\nprog8\nprog8.c\nfile7c.c\nfile9c.c\nprog9\nprog8.c\nfile8c.c\nfile9c.c\nprog5.c\nprog8.c\nmain()",
            "extern\n.c\ntest1.c\ntest2.c\nint test1_var;\ntest1.c\ntest2.c\nextern int test1_var;\ntest2.c\n$ cat test1.c \nint test1_var = 5;\n$ cat test2.c\n#include &lt;stdio.h&gt;\n\nextern int test1_var;\n\nint main(void) {\n    printf(\"test1_var = %d\\n\", test1_var);\n    return 0;\n}\n$ gcc test1.c test2.c -o test\n$ ./test\ntest1_var = 5\n",
            "                 declare | define   | initialize |\n                ----------------------------------\n\nextern int a;    yes          no           no\n-------------\nint a = 2019;    yes          yes          yes\n-------------\nint a;           yes          yes          no\n-------------\n",
            "extern",
            "#include &lt;stdio.h&gt;\n\nint not_extern_int = 1;\nextern int extern_int;\n\nvoid main() {\n    printf(\"%d\\n\", not_extern_int);\n    printf(\"%d\\n\", extern_int);\n}\n\ngcc -c main.c\nreadelf -s main.o\n\nNum:    Value          Size Type    Bind   Vis      Ndx Name\n 9: 0000000000000000     4 OBJECT  GLOBAL DEFAULT    3 not_extern_int\n12: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND extern_int\n\nextern\nextern",
            "#include&lt;stdio.h&gt;\nextern int a;\nmain(){\n       printf(\"The value of a is &lt;%d&gt;\\n\",a);\n}\n\nint a = 5;\n",
            "extern\nstatic",
            "extern\nextern\nextern",
            "extern",
            "extern\nfirst.c\nsecond.c\nextern\nfirst.c\nfirst.c",
            "int\nchar\n#ifdef MAIN_C\n#define GLOBAL\n /* #warning COMPILING MAIN.C */\n#else\n#define GLOBAL extern\n#endif\nGLOBAL unsigned char testing_mode; // example var used in several C files\n\n#define MAIN_C 1\n#include \"global.h\"\n#undef MAIN_C\n\nunsigned char\nextern unsigned char testing_mode;\n\nunsigned char\ngotcha",
            "#define GLOBAL_FOO_IMPLEMENTATION\n//file foo_globals.h\n#pragma once  \n#include &quot;foo.h&quot;  //contains Foo typedef\n#include &lt;atomic&gt;\n\n#ifdef GLOBAL  \n#undef GLOBAL  \n#endif  \n\n#ifdef GLOBALINIT\n#undef GLOBALINIT\n#endif\n\n#ifdef GLOBAL_FOO_IMPLEMENTATION  \n#define GLOBAL  \n#define GLOBALINIT(x) = x\n#else  \n#define GLOBAL extern  \n#define GLOBALINIT(x)\n#endif  \n\nGLOBAL Foo foo1 GLOBALINIT({2, 3, 4})\nGLOBAL std::atomic_bool flag1 GLOBALINIT(true);\nGLOBAL std::atomic_uint counter1 GLOBALINIT(5);\n\n\n//file main.cpp\n#define GLOBAL_FOO_IMPLEMENTATION\n#include &quot;foo_globals.h&quot;\n\n//file uses_extern_foo.cpp\n#include &quot;foo_globals.h\n",
            "extern\nextern"
        ]
    },
    {
        "question_id": 201101,
        "question_code": "memset()",
        "answer_code_snippets": [
            "int myArray[10] = { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 };\n\nint myArray[10] = { 1, 2 }; // initialize to 1,2,0,0,0...\n\nint myArray[10] = { 0 }; // all elements 0\n\nint myArray[10] = {}; // all elements 0 in C++ and C23\n\nstatic int myArray[10]; // all elements 0\n",
            "int array[1024] = {[0 ... 1023] = 5};\n",
            "#define VAL_1X     42\n#define VAL_2X     VAL_1X,  VAL_1X\n#define VAL_4X     VAL_2X,  VAL_2X\n#define VAL_8X     VAL_4X,  VAL_4X\n#define VAL_16X    VAL_8X,  VAL_8X\n#define VAL_32X    VAL_16X, VAL_16X\n#define VAL_64X    VAL_32X, VAL_32X\n\nint myArray[53] = { VAL_32X, VAL_16X, VAL_4X, VAL_1X };\n\n#define VAL_1(X) X\n#define VAL_2(X) VAL_1(X), VAL_1(X)\n/* etc. */\n\n#define STRUCTVAL_1(...) { __VA_ARGS__ }\n#define STRUCTVAL_2(...) STRUCTVAL_1(__VA_ARGS__), STRUCTVAL_1(__VA_ARGS__)\n/*etc */\n\n#define STRUCTVAL_48(...) STRUCTVAL_32(__VA_ARGS__), STRUCTVAL_16(__VA_ARGS__)\n\nstruct Pair { char key[16]; char val[32]; };\nstruct Pair p_data[] = { STRUCTVAL_48(&quot;Key&quot;, &quot;Value&quot;) };\nint a_data[][4] = { STRUCTVAL_48(12, 19, 23, 37) };\n",
            "int myArray[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n\nint myPoints[][3] = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9} };\n\nint myPoints[][] = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9} };\n",
            "char* array[] = \n{\n    [0] = \"Hello\",\n    [1] = \"World\"\n};   \n\nenum\n{\n    ERR_OK,\n    ERR_FAIL,\n    ERR_MEMORY\n};\n\n#define _ITEM(x) [x] = #x\n\nchar* array[] = \n{\n    _ITEM(ERR_OK),\n    _ITEM(ERR_FAIL),\n    _ITEM(ERR_MEMORY)\n};   \n",
            "int i;\nfor (i = 0; i &lt; ARRAY_SIZE; ++i)\n{\n  myArray[i] = VALUE;\n}\n\nint myArray[10] = { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5...\n",
            "std::index_sequence\nconstexpr\n#include &lt;array&gt;\n\n/// [3]\n/// This functions's only purpose is to ignore the index given as the second\n/// template argument and to always produce the value passed in.\ntemplate&lt;class T, size_t /*ignored*/&gt;\nconstexpr T identity_func(const T&amp; value) {\n    return value;\n}\n\n/// [2]\n/// At this point, we have a list of indices that we can unfold\n/// into an initializer list using the `identity_func` above.\ntemplate&lt;class T, size_t... Indices&gt;\nconstexpr std::array&lt;T, sizeof...(Indices)&gt;\nmake_array_of_impl(const T&amp; value, std::index_sequence&lt;Indices...&gt;) {\n    return {identity_func&lt;T, Indices&gt;(value)...};\n}\n\n/// [1]\n/// This is the user-facing function.\n/// The template arguments are swapped compared to the order used\n/// for std::array, this way we can let the compiler infer the type\n/// from the given value but still define it explicitly if we want to.\ntemplate&lt;size_t Size, class T&gt;\nconstexpr std::array&lt;T, Size&gt; \nmake_array_of(const T&amp; value) {\n    using Indices = std::make_index_sequence&lt;Size&gt;;\n    return make_array_of_impl(value, Indices{});\n}\n\n// std::array&lt;int, 4&gt;{42, 42, 42, 42}\nconstexpr auto test_array = make_array_of&lt;4/*, int*/&gt;(42);\nstatic_assert(test_array[0] == 42);\nstatic_assert(test_array[1] == 42);\nstatic_assert(test_array[2] == 42);\nstatic_assert(test_array[3] == 42);\n// static_assert(test_array[4] == 42); out of bounds\n",
            "static void\nunhandled_interrupt(struct trap_frame *frame, int irq, void *arg)\n{\n    //this code intentionally left blank\n}\n\nstatic struct irqtbl_s vector_tbl[XCHAL_NUM_INTERRUPTS] = {\n    [0 ... XCHAL_NUM_INTERRUPTS-1] {unhandled_interrupt, NULL},\n};\n",
            "array = initial_value\n",
            "// put values 1-8, then two zeroes\nint list[10] = {1,2,3,4,5,6,7,8};\n",
            "1 000 000\nint\nloop runtime 0.004248 [seconds]\nmemfill() runtime 0.001085 [seconds]\n#include &lt;stdio.h&gt;\n#include &lt;time.h&gt;\n#include &lt;string.h&gt;\n#define ARR_SIZE 1000000\n\nvoid memfill(void *dest, size_t destsize, size_t elemsize) {\n   char   *nextdest = (char *) dest + elemsize;\n   size_t movesize, donesize = elemsize;\n\n   destsize -= elemsize;\n   while (destsize) {\n      movesize = (donesize &lt; destsize) ? donesize : destsize;\n      memcpy(nextdest, dest, movesize);\n      nextdest += movesize; destsize -= movesize; donesize += movesize;\n   }\n}    \nint main() {\n    clock_t timeStart;\n    double  runTime;\n    int     i, a[ARR_SIZE];\n\n    timeStart = clock();\n    for (i = 0; i &lt; ARR_SIZE; i++)\n        a[i] = 9;    \n    runTime = (double)(clock() - timeStart) / (double)CLOCKS_PER_SEC;\n    printf(\"loop runtime %f [seconds]\\n\",runTime);\n\n    timeStart = clock();\n    a[0] = 10;\n    memfill(a, sizeof(a), sizeof(a[0]));\n    runTime = (double)(clock() - timeStart) / (double)CLOCKS_PER_SEC;\n    printf(\"memfill() runtime %f [seconds]\\n\",runTime);\n    return 0;\n}\n",
            "int array[10] = {0};\n\nint array[10];\nmemset(array,-1, 10 *sizeof(int));\n",
            "int array[1024] = {[0 ... 1023] = 5};\n\n...",
            "#include &lt;iostream&gt;\n\nvoid PrintArray(int a[3][3])\n{\n    std::cout &lt;&lt; &quot;a11 = &quot; &lt;&lt; a[0][0] &lt;&lt; &quot;\\t\\t&quot; &lt;&lt; &quot;a12 = &quot; &lt;&lt; a[0][1] &lt;&lt; &quot;\\t\\t&quot; &lt;&lt; &quot;a13 = &quot; &lt;&lt; a[0][2] &lt;&lt; std::endl;\n    std::cout &lt;&lt; &quot;a21 = &quot; &lt;&lt; a[1][0] &lt;&lt; &quot;\\t\\t&quot; &lt;&lt; &quot;a22 = &quot; &lt;&lt; a[1][1] &lt;&lt; &quot;\\t\\t&quot; &lt;&lt; &quot;a23 = &quot; &lt;&lt; a[1][2] &lt;&lt; std::endl;\n    std::cout &lt;&lt; &quot;a31 = &quot; &lt;&lt; a[2][0] &lt;&lt; &quot;\\t\\t&quot; &lt;&lt; &quot;a32 = &quot; &lt;&lt; a[2][1] &lt;&lt; &quot;\\t\\t&quot; &lt;&lt; &quot;a33 = &quot; &lt;&lt; a[2][2] &lt;&lt; std::endl;\n    std::cout &lt;&lt; std::endl;\n}\n\nint wmain(int argc, wchar_t * argv[])\n{\n    int a1[3][3] = { 11,  12,  13,      // The most\n                     21,  22,  23,      // basic\n                     31,  32,  33   };  // format.\n                                    \n    int a2[][3]  = { 11,  12,  13,      // The first (outer) dimension\n                     21,  22,  23,      // may be omitted. The compiler\n                     31,  32,  33   };  // will automatically deduce it.\n                                    \n    int a3[3][3] = { {11, 12,  13},     // The elements of each\n                     {21, 22,  23},     // second (inner) dimension\n                     {31, 32,  33}  };  // can be grouped together.\n                                    \n    int a4[][3]  = { {11, 12,  13},     // Again, the first dimension\n                     {21, 22,  23},     // can be omitted when the\n                     {31, 32,  33}  };  // inner elements are grouped.\n\n    PrintArray(a1);\n    PrintArray(a2);\n    PrintArray(a3);\n    PrintArray(a4);\n\n    // This part shows in which order the elements are stored in the memory.\n    int * b = (int *) a1;    // The output is the same for the all four arrays.\n    for (int i=0; i&lt;9; i++)\n    {\n        std::cout &lt;&lt; b[i] &lt;&lt; '\\t';\n    }\n\n    return 0;\n}\n\na11 = 11                a12 = 12                a13 = 13\na21 = 21                a22 = 22                a23 = 23\na31 = 31                a32 = 32                a33 = 33\n\na11 = 11                a12 = 12                a13 = 13\na21 = 21                a22 = 22                a23 = 23\na31 = 31                a32 = 32                a33 = 33\n\na11 = 11                a12 = 12                a13 = 13\na21 = 21                a22 = 22                a23 = 23\na31 = 31                a32 = 32                a33 = 33\n\na11 = 11                a12 = 12                a13 = 13\na21 = 21                a22 = 22                a23 = 23\na31 = 31                a32 = 32                a33 = 33\n\n11      12      13      21      22      23      31      32      33\n",
            "int i, value=5, array[1000]; \nfor(i=0; i&lt;1000; i++) \n    array[i] = value; \n",
            "#include &lt;stdio.h&gt;\n\ntypedef const unsigned int cUINT;\ntypedef unsigned int UINT;\n\ncUINT size = 10;\ncUINT initVal = 5;\n\nvoid arrayInitializer(UINT* myArray, cUINT size, cUINT initVal);\nvoid printArray(UINT* myArray);\n\nint main() {\n    UINT myArray[size];\n    /* Not initialized during declaration, but it can be\n    initialized using a function for the appropriate TYPE*/\n    arrayInitializer(myArray, size, initVal);\n\n    printArray(myArray);\n\n    return 0;\n}\n\nvoid arrayInitializer(UINT* myArray, cUINT size, cUINT initVal) {\n    for (UINT n = 0; n &lt; size; n++) {\n        myArray[n] = initVal;\n    }\n}\n\nvoid printArray(UINT* myArray) {\n    printf(&quot;myArray = { &quot;);\n    for (UINT n = 0; n &lt; size; n++) {\n        printf(&quot;%u&quot;, myArray[n]);\n\n        if (n &lt; size-1)\n            printf(&quot;, &quot;);\n    }\n    printf(&quot; }\\n&quot;);\n}\n\nUINT myArray[size];\ninitializing function\ntype\nprintArray()",
            "int a[4];\n\nunsigned int size = sizeof(a) / sizeof(a[0]);\nfor (unsigned int i = 0; i &lt; size; i++)\n  a[i] = 0;\n",
            "#include &lt;boost/preprocessor/repetition/enum.hpp&gt;\n#define C_ARRAY_ELEMENT(z, index, name) name[index]\n#define C_ARRAY_EXPAND(name,size) BOOST_PP_ENUM(size,C_ARRAY_ELEMENT,name)\n#define C_ARRAY_VALUE(z, index, value) value\n#define C_ARRAY_INITIALIZE(value,size) BOOST_PP_ENUM(size,C_ARRAY_VALUE,value)\n",
            "  char arr[1000] = { 0 };\n\n  char arr[1000];\n  for(int i=0; i&lt;arr.size(); i++){\n     arr[i] = 'A';\n  }\n",
            "template &lt;size_t Cnt, typename T&gt;                                               \nstd::array&lt;T, Cnt&gt; make_array_of(const T&amp; v)                                           \n{                                                                               \n    return []&lt;size_t... Idx&gt;(std::index_sequence&lt;Idx...&gt;, const auto&amp; v)        \n    {                                                                           \n        auto identity = [](const auto&amp; v, size_t) { return v; };                \n        return std::array{identity(v, Idx)...};                                 \n    }                                                                           \n    (std::make_index_sequence&lt;Cnt&gt;{}, v);                                       \n}\n",
            "int a[5] = {3, 3, 3, 3, 3};\n\nint a[100] = {0};\n\nint a[10] = {1};\n\nint a[100];\n\nint a[1000] = {0};\n",
            "// macros.h\n#define INDEX_SEQUENCE(X) _indexseq_expand(X)\n#define _indexseq_expand(X) _indeseq_concat(_indexseq, X)\n\n#define _indexseq_concat(a, b) _indexseq_concat_expand(a, b)\n#define _indexseq_concat_expand(a, b) a##b\n\n#define _indexseq1 0\n#define _indexseq2 _indexseq1, 1\n// generate as above to a given max size\n\n#define APPLY_FOR_EACH(macro, ...) _foreach(macro, _vaargsn(__VA_ARGS__), __VA_ARGS__)\n#define _foreach(macro, n, ...) _foreach_concat(_foreach, n)(macro, __VA_ARGS__)\n\n#define _foreach_concat(a, b) _foreach_concat_expand(a, b)\n#define _foreach_concat_expand(a, b) a##b\n\n#define _foreach1(macro, i) macro(i)\n#define _foreach2(macro, i, ...) macro(i) _foreach1(__VA_ARGS__)\n// generate as above to a given max size\n\n#define _vaargsn(...) _vaargsnpp(__VA_ARGS__, _vaargsnidx())\n// macros below shall be generated as well until a given max size\n#define _vaargsnpp(_1, _2, _3, N, ...) N\n#define _vaargsnidx() 3, 2, 1\n\n#define CONFIGURED_SIZE 42\n\nstruct complex_struct {\n    int zero, one;\n    float pi;\n    unsigned index;\n};\n\n#define INIT(I) { 0, 1, 3.14159f, I },\nstruct complex_struct array[CONFIGURED_SIZE] = {\n    APPLY_FOR_EACH(INIT, INDEX_SEQUENCE(CONFIGURED_SIZE))\n};\n",
            "memcpy (&amp;element [1], &amp;element [0], sizeof (element)-sizeof (element [0]);",
            "#include &lt;string.h&gt;\n\nvoid array_init(void *start, size_t element_size, size_t elements, void *initval) {\n  memcpy(       start,                initval, element_size             );\n  memcpy((char*)start + element_size, start,   element_size*(elements-1));\n}\n\n// Testing\n#include &lt;stdio.h&gt;\n\nstruct s {\n  int a;\n  char b;\n} array[2][3], init;\n\nint main() {\n  init = (struct s){.a = 3, .b = 'x'};\n  array_init(array, sizeof(array[0][0]), 2*3, &amp;init);\n\n  for(int i=0; i&lt;2; i++)\n    for(int j=0; j&lt;3; j++)\n      printf(&quot;array[%i][%i].a = %i .b = '%c'\\n&quot;, i, j, array[i][j].a, array[i][j].b);\n}\n\narray[0][0].a = 3 .b = 'x'\narray[0][1].a = 3 .b = 'x'\narray[0][2].a = 3 .b = 'x'\narray[1][0].a = 3 .b = 'x'\narray[1][1].a = 3 .b = 'x'\narray[1][2].a = 3 .b = 'x'\n",
            "#include &lt;stdio.h&gt;\n\nint main()\n{\n    int i, a[50];\n    for (i=0; i&lt;50; i++) {\n        a[i]=5; // Set value 5 to all the array index\n    }\n    for (i=0; i&lt;50; i++)\n        printf(&quot;%d\\n&quot;, a[i]);\n    return 0;\n}\n"
        ]
    },
    {
        "question_id": 24853,
        "question_code": "++i\ni++\nfor",
        "answer_code_snippets": [
            "++i\ni\n i = 1;\n j = ++i;\n (i is 2, j is 2)\n\ni++\ni\ni\n i = 1;\n j = i++;\n (i is 2, j is 1)\n\nfor\n++i\n++i\ni++\n++i\ni++\noperator++()",
            "i++\n++i\ni++\ni++\ni\nint i = 1, j;\nj = i++;\n\nj = 1\ni = 2\ni\nj\ni\n++i\n++i\ni\nj = i;\ni++\nint i = 1, j;\nj = ++i;\n\nj = 2\ni = 2\ni\nj\ni\ni\n++i\nj=i;\nfor(i=0; i&lt;5; i++)\n   printf(&quot;%d &quot;, i);\n\nfor(i=0; i&lt;5; ++i)\n   printf(&quot;%d &quot;, i);\n\n0 1 2 3 4\nfor(i = 0; i&lt;5;)\n    printf(&quot;%d &quot;, ++i);\n\n1 2 3 4 5",
            "i++\n++i",
            "++i\ni++\n++i\ni++",
            "#include&lt;stdio.h&gt;\n\nint main(int argc, char* argv[])\n{\n  unsigned int i=0, a;\n  printf(&quot;i initial value: %d; &quot;, i);\n  a = i++;\n  printf(&quot;value returned by i++: %d, i after: %d\\n&quot;, a, i);\n  i=0;\n  printf(&quot;i initial value: %d; &quot;, i);\n  a = ++i;\n  printf(&quot; value returned by ++i: %d, i after: %d\\n&quot;,a, i);\n}\n\ni initial value: 0; value returned by i++: 0, i after: 1\ni initial value: 0;  value returned by ++i: 1, i after: 1\n\n++i\ni++\ni\n#include&lt;stdio.h&gt;\n\nint main ()\n  int i=0;\n  int a = i++*2;\n  printf(&quot;i=0, i++*2=%d\\n&quot;, a);\n  i=0;\n  a = ++i * 2;\n  printf(&quot;i=0, ++i*2=%d\\n&quot;, a);\n  i=0;\n  a = (++i) * 2;\n  printf(&quot;i=0, (++i)*2=%d\\n&quot;, a);\n  i=0;\n  a = (i++) * 2;\n  printf(&quot;i=0, (i++)*2=%d\\n&quot;, a);\n  return 0;\n}\n\ni=0, i++*2=0\ni=0, ++i*2=2\ni=0, (++i)*2=2\ni=0, (i++)*2=0\n\ni++*2\n++i*2\n(i++)*2\n(++i)*2\nfor(int i=0; i&lt;10; i++)\n\nfor(int i=0; i&lt;10; ++i)\n\n++\ni\n++\n++\ni\n++\ni",
            "++i\ni++\ni++\n++i\n++i",
            "++i\ni++\n++i\nint i = 0;\nprintf(\"i: %d\\n\", i);\nprintf(\"i++: %d\\n\", i++);\nprintf(\"++i: %d\\n\", ++i);\n\ni: 0\ni++: 0\n++i: 2\n",
            "++i\nint i = 5\nint b = ++i\ni++\nint i = 5\nint b = i++\ni++\ni",
            "int i = 10, j = 10;\n  \nprintf (&quot;i is %i \\n&quot;, i);\nprintf (&quot;i++ is %i \\n&quot;, i++);\nprintf (&quot;i is %i \\n\\n&quot;, i);\n  \nprintf (&quot;j is %i \\n&quot;, j);\nprintf (&quot;++j is %i \\n&quot;, ++j);\nprintf (&quot;j is %i \\n&quot;, j);\n\n//Remember that the values are i = 10, and j = 10\n\ni is 10 \ni++ is 10     //Assigns (print out), then increments\ni is 11 \n\nj is 10 \n++j is 11    //Increments, then assigns (print out)\nj is 11 \n\nint i, j;\n\nfor (i = 0; i &lt;= 3; i++)\n    printf (&quot; &gt; iteration #%i&quot;, i);\n\nprintf (&quot;\\n&quot;);\n\nfor (j = 0; j &lt;= 3; ++j)\n    printf (&quot; &gt; iteration #%i&quot;, j);\n\n&gt; iteration #0 &gt; iteration #1 &gt; iteration #2 &gt; iteration #3\n&gt; iteration #0 &gt; iteration #1 &gt; iteration #2 &gt; iteration #3 \n",
            "int  i;\nint  j;\n\ni = 1;\nj = ++i;    // i is now 2, j is also 2\nj = i++;    // i is now 3, j is 2\n",
            "++i\ni++\nfunction(i++)\nfunction(++i)\nfunction(++i)\ni\nfunction(i++)\ni\ni\nint i=4;\nprintf(\"%d\\n\",pow(++i,2));//it prints 25 and i is 5 now\ni=4;\nprintf(\"%d\",pow(i++,2));//it prints 16 i is 5 now\n",
            "int j = 0;\nSystem.out.println(j); // 0\nSystem.out.println(j++); // 0. post-increment. It means after this line executes j increments.\n\nint k = 0;\nSystem.out.println(k); // 0\nSystem.out.println(++k); // 1. pre increment. It means it increments first and then the line executes\n\nint m = 0;\nif((m == 0 || m++ == 0) &amp;&amp; (m++ == 1)) { // False\n    // In the OR condition, if the first line is already true\n    // then the compiler doesn't check the rest. It is a\n    // technique of compiler optimization\n    System.out.println(&quot;post-increment &quot; + m);\n}\n\nint n = 0;\nif((n == 0 || n++ == 0) &amp;&amp; (++n == 1)) { // True\n    System.out.println(&quot;pre-increment &quot; + n); // 1\n}\n\nSystem.out.println(&quot;In Array&quot;);\nint[] a = { 55, 11, 15, 20, 25 };\nint ii, jj, kk = 1, mm;\nii = ++a[1]; // ii = 12. a[1] = a[1] + 1\nSystem.out.println(a[1]); // 12\n\njj = a[1]++; // 12\nSystem.out.println(a[1]); // a[1] = 13\n\nmm = a[1]; // 13\nSystem.out.printf(&quot;\\n%d %d %d\\n&quot;, ii, jj, mm); // 12, 12, 13\n\nfor (int val: a) {\n     System.out.print(&quot; &quot; + val); // 55, 13, 15, 20, 25\n}\n\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n\n    int x = 10;\n    int* p = &amp;x;\n\n    std::cout &lt;&lt; &quot;address = &quot; &lt;&lt; p &lt;&lt;&quot;\\n&quot;; // Prints the address of x\n    std::cout &lt;&lt; &quot;address = &quot; &lt;&lt; p &lt;&lt;&quot;\\n&quot;; // Prints (the address of x) + sizeof(int)\n    std::cout &lt;&lt; &quot;address = &quot; &lt;&lt; &amp;x &lt;&lt;&quot;\\n&quot;; // Prints the address of x\n\n    std::cout &lt;&lt; &quot;address = &quot; &lt;&lt; ++&amp;x &lt;&lt; &quot;\\n&quot;; // Error. The reference can't reassign, because it is fixed (immutable).\n}\n",
            "int i = 1;\nint j = i++;\n\nj\n1\nint i = 1;\nint j = ++i;\n\nj\n2\ni\n2",
            "for (int i = 0; i != X; ++i) ...\n",
            "i =1\n1,2,3,4,n\ni =1\n2,3,4,5,n",
            "int i, j, k, l;\ni = 1; //initialize int i with 1\nj = i+1; //add 1 with i and set that as the value of j. i is still 1\nk = i++; //k gets the current value of i, after that i is incremented. So here i is 2, but k is 1\nl = ++i; // i is incremented first and then returned. So the value of i is 3 and so does l.\ncout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; j &lt;&lt; ' ' &lt;&lt; k &lt;&lt; ' '&lt;&lt; l &lt;&lt; endl;\nreturn 0;\n",
            "// case 1\n\ni++;\n\n/* you can think as,\n * i;\n * i= i+1;\n */\n\n\n\n// case 2\n\n++i;\n\n/* you can think as,\n * i = i+i;\n * i;\n */\n",
            "++\n++\nclass Int {\n    private:\n        int i;\n\n    public:\n        Int(int i)\n        {\n            this-&gt;i = i;\n        }\n\n        // Overloading the prefix operator\n        Int&amp; operator++()\n        {\n            ++i;\n            // returned value should be a reference to *this\n            return *this;\n        }\n\n        // Overloading the postfix operator\n        Int operator++(int)\n        {\n            // returned value should be a copy of the object before increment\n            Int obj = *this;\n            ++i;\n            return obj;\n        }\n};\n"
        ]
    },
    {
        "question_id": 19210935,
        "question_code": "linux\n1\n#include &lt;stdio.h&gt;\nint main(void)\n{       \n    int linux = 5;\n    return 0;\n}\n\n$ gcc -E test.c\n....\nint main(void)\n{\n    int 1 = 5;\n    return 0;\n}\n\n#define linux\nstdio.h",
        "answer_code_snippets": [
            "unix\nvax\n#ifdef\nunix\nunix\nlinux\nint linux = 5;\ngcc -std=c90 -pedantic ... # or -std=c89 or -ansi\ngcc -std=c99 -pedantic\ngcc -std=c11 -pedantic\n\nunix\nlinux\n__linux__\nunix\nmain() { printf(&amp;unix[&quot;\\021%six\\012\\0&quot;],(unix)[&quot;have&quot;]+&quot;fun&quot;-0x60);}\n\n&quot;unix&quot;",
            "-dM\n-std=gnu99\n-std=c99\n$ cpp --std=c89 -dM &lt; /dev/null | grep linux\n#define __linux 1\n#define __linux__ 1\n#define __gnu_linux__ 1\n\n$ cpp --std=gnu89 -dM &lt; /dev/null | grep linux\n#define __linux 1\n#define __linux__ 1\n#define __gnu_linux__ 1\n#define linux 1\n\n$ cpp --std=c99 -dM &lt; /dev/null | grep linux\n#define __linux 1\n#define __linux__ 1\n#define __gnu_linux__ 1\n\n$ cpp --std=gnu99 -dM &lt; /dev/null | grep linux\n#define __linux 1\n#define __linux__ 1\n#define __gnu_linux__ 1\n#define linux 1\n\n#define unix\nc11\ngnu11\n-std=gnu89\ncpp",
            "linux\ncp /dev/null emptyfile.c\ngcc -E -dM emptyfile.c\n\n/dev/null\n#define __DBL_MIN_EXP__ (-1021)\n#define __UINT_LEAST16_MAX__ 65535\n#define __ATOMIC_ACQUIRE 2\n#define __FLT_MIN__ 1.17549435082228750797e-38F\n#define __UINT_LEAST8_TYPE__ unsigned char\n#define __INTMAX_C(c) c ## L\n#define __CHAR_BIT__ 8\n#define __UINT8_MAX__ 255\n#define __WINT_MAX__ 2147483647\n#define __ORDER_LITTLE_ENDIAN__ 1234\n#define __SIZE_MAX__ 18446744073709551615UL\n#define __WCHAR_MAX__ 2147483647\n#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1 1\n#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2 1\n#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4 1\n#define __DBL_DENORM_MIN__ ((double)4.94065645841246544177e-324L)\n#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8 1\n#define __GCC_ATOMIC_CHAR_LOCK_FREE 2\n#define __FLT_EVAL_METHOD__ 0\n#define __GCC_ATOMIC_CHAR32_T_LOCK_FREE 2\n#define __x86_64 1\n#define __UINT_FAST64_MAX__ 18446744073709551615ULL\n#define __SIG_ATOMIC_TYPE__ int\n#define __DBL_MIN_10_EXP__ (-307)\n#define __FINITE_MATH_ONLY__ 0\n#define __GNUC_PATCHLEVEL__ 1\n#define __UINT_FAST8_MAX__ 255\n#define __DEC64_MAX_EXP__ 385\n#define __INT8_C(c) c\n#define __UINT_LEAST64_MAX__ 18446744073709551615ULL\n#define __SHRT_MAX__ 32767\n#define __LDBL_MAX__ 1.18973149535723176502e+4932L\n#define __UINT_LEAST8_MAX__ 255\n#define __GCC_ATOMIC_BOOL_LOCK_FREE 2\n#define __APPLE_CC__ 1\n#define __UINTMAX_TYPE__ long unsigned int\n#define __DEC32_EPSILON__ 1E-6DF\n#define __UINT32_MAX__ 4294967295U\n#define __LDBL_MAX_EXP__ 16384\n#define __WINT_MIN__ (-__WINT_MAX__ - 1)\n#define __SCHAR_MAX__ 127\n#define __WCHAR_MIN__ (-__WCHAR_MAX__ - 1)\n#define __INT64_C(c) c ## LL\n#define __DBL_DIG__ 15\n#define __GCC_ATOMIC_POINTER_LOCK_FREE 2\n#define __SIZEOF_INT__ 4\n#define __SIZEOF_POINTER__ 8\n#define __USER_LABEL_PREFIX__ _\n#define __STDC_HOSTED__ 1\n#define __LDBL_HAS_INFINITY__ 1\n#define __FLT_EPSILON__ 1.19209289550781250000e-7F\n#define __LDBL_MIN__ 3.36210314311209350626e-4932L\n#define __DEC32_MAX__ 9.999999E96DF\n#define __strong \n#define __INT32_MAX__ 2147483647\n#define __SIZEOF_LONG__ 8\n#define __APPLE__ 1\n#define __UINT16_C(c) c\n#define __DECIMAL_DIG__ 21\n#define __LDBL_HAS_QUIET_NAN__ 1\n#define __DYNAMIC__ 1\n#define __GNUC__ 4\n#define __MMX__ 1\n#define __FLT_HAS_DENORM__ 1\n#define __SIZEOF_LONG_DOUBLE__ 16\n#define __BIGGEST_ALIGNMENT__ 16\n#define __DBL_MAX__ ((double)1.79769313486231570815e+308L)\n#define __INT_FAST32_MAX__ 2147483647\n#define __DBL_HAS_INFINITY__ 1\n#define __DEC32_MIN_EXP__ (-94)\n#define __INT_FAST16_TYPE__ short int\n#define __LDBL_HAS_DENORM__ 1\n#define __DEC128_MAX__ 9.999999999999999999999999999999999E6144DL\n#define __INT_LEAST32_MAX__ 2147483647\n#define __DEC32_MIN__ 1E-95DF\n#define __weak \n#define __DBL_MAX_EXP__ 1024\n#define __DEC128_EPSILON__ 1E-33DL\n#define __SSE2_MATH__ 1\n#define __ATOMIC_HLE_RELEASE 131072\n#define __PTRDIFF_MAX__ 9223372036854775807L\n#define __amd64 1\n#define __tune_core2__ 1\n#define __ATOMIC_HLE_ACQUIRE 65536\n#define __LONG_LONG_MAX__ 9223372036854775807LL\n#define __SIZEOF_SIZE_T__ 8\n#define __SIZEOF_WINT_T__ 4\n#define __GXX_ABI_VERSION 1002\n#define __FLT_MIN_EXP__ (-125)\n#define __INT_FAST64_TYPE__ long long int\n#define __DBL_MIN__ ((double)2.22507385850720138309e-308L)\n#define __LP64__ 1\n#define __DEC128_MIN__ 1E-6143DL\n#define __REGISTER_PREFIX__ \n#define __UINT16_MAX__ 65535\n#define __DBL_HAS_DENORM__ 1\n#define __UINT8_TYPE__ unsigned char\n#define __NO_INLINE__ 1\n#define __FLT_MANT_DIG__ 24\n#define __VERSION__ \"4.8.1\"\n#define __UINT64_C(c) c ## ULL\n#define __GCC_ATOMIC_INT_LOCK_FREE 2\n#define __FLOAT_WORD_ORDER__ __ORDER_LITTLE_ENDIAN__\n#define __INT32_C(c) c\n#define __DEC64_EPSILON__ 1E-15DD\n#define __ORDER_PDP_ENDIAN__ 3412\n#define __DEC128_MIN_EXP__ (-6142)\n#define __INT_FAST32_TYPE__ int\n#define __UINT_LEAST16_TYPE__ short unsigned int\n#define __INT16_MAX__ 32767\n#define __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ 1080\n#define __SIZE_TYPE__ long unsigned int\n#define __UINT64_MAX__ 18446744073709551615ULL\n#define __INT8_TYPE__ signed char\n#define __FLT_RADIX__ 2\n#define __INT_LEAST16_TYPE__ short int\n#define __LDBL_EPSILON__ 1.08420217248550443401e-19L\n#define __UINTMAX_C(c) c ## UL\n#define __SSE_MATH__ 1\n#define __k8 1\n#define __SIG_ATOMIC_MAX__ 2147483647\n#define __GCC_ATOMIC_WCHAR_T_LOCK_FREE 2\n#define __SIZEOF_PTRDIFF_T__ 8\n#define __x86_64__ 1\n#define __DEC32_SUBNORMAL_MIN__ 0.000001E-95DF\n#define __INT_FAST16_MAX__ 32767\n#define __UINT_FAST32_MAX__ 4294967295U\n#define __UINT_LEAST64_TYPE__ long long unsigned int\n#define __FLT_HAS_QUIET_NAN__ 1\n#define __FLT_MAX_10_EXP__ 38\n#define __LONG_MAX__ 9223372036854775807L\n#define __DEC128_SUBNORMAL_MIN__ 0.000000000000000000000000000000001E-6143DL\n#define __FLT_HAS_INFINITY__ 1\n#define __UINT_FAST16_TYPE__ short unsigned int\n#define __DEC64_MAX__ 9.999999999999999E384DD\n#define __CHAR16_TYPE__ short unsigned int\n#define __PRAGMA_REDEFINE_EXTNAME 1\n#define __INT_LEAST16_MAX__ 32767\n#define __DEC64_MANT_DIG__ 16\n#define __INT64_MAX__ 9223372036854775807LL\n#define __UINT_LEAST32_MAX__ 4294967295U\n#define __GCC_ATOMIC_LONG_LOCK_FREE 2\n#define __INT_LEAST64_TYPE__ long long int\n#define __INT16_TYPE__ short int\n#define __INT_LEAST8_TYPE__ signed char\n#define __DEC32_MAX_EXP__ 97\n#define __INT_FAST8_MAX__ 127\n#define __INTPTR_MAX__ 9223372036854775807L\n#define __LITTLE_ENDIAN__ 1\n#define __SSE2__ 1\n#define __LDBL_MANT_DIG__ 64\n#define __CONSTANT_CFSTRINGS__ 1\n#define __DBL_HAS_QUIET_NAN__ 1\n#define __SIG_ATOMIC_MIN__ (-__SIG_ATOMIC_MAX__ - 1)\n#define __code_model_small__ 1\n#define __k8__ 1\n#define __INTPTR_TYPE__ long int\n#define __UINT16_TYPE__ short unsigned int\n#define __WCHAR_TYPE__ int\n#define __SIZEOF_FLOAT__ 4\n#define __pic__ 2\n#define __UINTPTR_MAX__ 18446744073709551615UL\n#define __DEC64_MIN_EXP__ (-382)\n#define __INT_FAST64_MAX__ 9223372036854775807LL\n#define __GCC_ATOMIC_TEST_AND_SET_TRUEVAL 1\n#define __FLT_DIG__ 6\n#define __UINT_FAST64_TYPE__ long long unsigned int\n#define __INT_MAX__ 2147483647\n#define __MACH__ 1\n#define __amd64__ 1\n#define __INT64_TYPE__ long long int\n#define __FLT_MAX_EXP__ 128\n#define __ORDER_BIG_ENDIAN__ 4321\n#define __DBL_MANT_DIG__ 53\n#define __INT_LEAST64_MAX__ 9223372036854775807LL\n#define __GCC_ATOMIC_CHAR16_T_LOCK_FREE 2\n#define __DEC64_MIN__ 1E-383DD\n#define __WINT_TYPE__ int\n#define __UINT_LEAST32_TYPE__ unsigned int\n#define __SIZEOF_SHORT__ 2\n#define __SSE__ 1\n#define __LDBL_MIN_EXP__ (-16381)\n#define __INT_LEAST8_MAX__ 127\n#define __SIZEOF_INT128__ 16\n#define __LDBL_MAX_10_EXP__ 4932\n#define __ATOMIC_RELAXED 0\n#define __DBL_EPSILON__ ((double)2.22044604925031308085e-16L)\n#define _LP64 1\n#define __UINT8_C(c) c\n#define __INT_LEAST32_TYPE__ int\n#define __SIZEOF_WCHAR_T__ 4\n#define __UINT64_TYPE__ long long unsigned int\n#define __INT_FAST8_TYPE__ signed char\n#define __DBL_DECIMAL_DIG__ 17\n#define __FXSR__ 1\n#define __DEC_EVAL_METHOD__ 2\n#define __UINT32_C(c) c ## U\n#define __INTMAX_MAX__ 9223372036854775807L\n#define __BYTE_ORDER__ __ORDER_LITTLE_ENDIAN__\n#define __FLT_DENORM_MIN__ 1.40129846432481707092e-45F\n#define __INT8_MAX__ 127\n#define __PIC__ 2\n#define __UINT_FAST32_TYPE__ unsigned int\n#define __CHAR32_TYPE__ unsigned int\n#define __FLT_MAX__ 3.40282346638528859812e+38F\n#define __INT32_TYPE__ int\n#define __SIZEOF_DOUBLE__ 8\n#define __FLT_MIN_10_EXP__ (-37)\n#define __INTMAX_TYPE__ long int\n#define __DEC128_MAX_EXP__ 6145\n#define __ATOMIC_CONSUME 1\n#define __GNUC_MINOR__ 8\n#define __UINTMAX_MAX__ 18446744073709551615UL\n#define __DEC32_MANT_DIG__ 7\n#define __DBL_MAX_10_EXP__ 308\n#define __LDBL_DENORM_MIN__ 3.64519953188247460253e-4951L\n#define __INT16_C(c) c\n#define __STDC__ 1\n#define __PTRDIFF_TYPE__ long int\n#define __ATOMIC_SEQ_CST 5\n#define __UINT32_TYPE__ unsigned int\n#define __UINTPTR_TYPE__ long unsigned int\n#define __DEC64_SUBNORMAL_MIN__ 0.000000000000001E-383DD\n#define __DEC128_MANT_DIG__ 34\n#define __LDBL_MIN_10_EXP__ (-4931)\n#define __SIZEOF_LONG_LONG__ 8\n#define __GCC_ATOMIC_LLONG_LOCK_FREE 2\n#define __LDBL_DIG__ 18\n#define __FLT_DECIMAL_DIG__ 9\n#define __UINT_FAST16_MAX__ 65535\n#define __GNUC_GNU_INLINE__ 1\n#define __GCC_ATOMIC_SHORT_LOCK_FREE 2\n#define __SSE3__ 1\n#define __UINT_FAST8_TYPE__ unsigned char\n#define __ATOMIC_ACQ_REL 4\n#define __ATOMIC_RELEASE 3\n\n#include &lt;stdio.h&gt;",
            "info gcc\n-ansi\n-std=c90\n-std=c++98\nasm\ntypeof\n//\ninline\n-ansi",
            "gcc -dM -E - &lt; /dev/null\n\n    #define _LP64 1\n#define _STDC_PREDEF_H 1\n#define __ATOMIC_ACQUIRE 2\n#define __ATOMIC_ACQ_REL 4\n#define __ATOMIC_CONSUME 1\n#define __ATOMIC_HLE_ACQUIRE 65536\n#define __ATOMIC_HLE_RELEASE 131072\n#define __ATOMIC_RELAXED 0\n#define __ATOMIC_RELEASE 3\n#define __ATOMIC_SEQ_CST 5\n#define __BIGGEST_ALIGNMENT__ 16\n#define __BYTE_ORDER__ __ORDER_LITTLE_ENDIAN__\n#define __CHAR16_TYPE__ short unsigned int\n#define __CHAR32_TYPE__ unsigned int\n#define __CHAR_BIT__ 8\n#define __DBL_DECIMAL_DIG__ 17\n#define __DBL_DENORM_MIN__ ((double)4.94065645841246544177e-324L)\n#define __DBL_DIG__ 15\n#define __DBL_EPSILON__ ((double)2.22044604925031308085e-16L)\n#define __DBL_HAS_DENORM__ 1\n#define __DBL_HAS_INFINITY__ 1\n#define __DBL_HAS_QUIET_NAN__ 1\n#define __DBL_MANT_DIG__ 53\n#define __DBL_MAX_10_EXP__ 308\n#define __DBL_MAX_EXP__ 1024\n#define __DBL_MAX__ ((double)1.79769313486231570815e+308L)\n#define __DBL_MIN_10_EXP__ (-307)\n#define __DBL_MIN_EXP__ (-1021)\n#define __DBL_MIN__ ((double)2.22507385850720138309e-308L)\n#define __DEC128_EPSILON__ 1E-33DL\n#define __DEC128_MANT_DIG__ 34\n#define __DEC128_MAX_EXP__ 6145\n#define __DEC128_MAX__ 9.999999999999999999999999999999999E6144DL\n#define __DEC128_MIN_EXP__ (-6142)\n#define __DEC128_MIN__ 1E-6143DL\n#define __DEC128_SUBNORMAL_MIN__ 0.000000000000000000000000000000001E-6143DL\n#define __DEC32_EPSILON__ 1E-6DF\n#define __DEC32_MANT_DIG__ 7\n#define __DEC32_MAX_EXP__ 97\n#define __DEC32_MAX__ 9.999999E96DF\n#define __DEC32_MIN_EXP__ (-94)\n#define __DEC32_MIN__ 1E-95DF\n#define __DEC32_SUBNORMAL_MIN__ 0.000001E-95DF\n#define __DEC64_EPSILON__ 1E-15DD\n#define __DEC64_MANT_DIG__ 16\n#define __DEC64_MAX_EXP__ 385\n#define __DEC64_MAX__ 9.999999999999999E384DD\n#define __DEC64_MIN_EXP__ (-382)\n#define __DEC64_MIN__ 1E-383DD\n#define __DEC64_SUBNORMAL_MIN__ 0.000000000000001E-383DD\n#define __DECIMAL_BID_FORMAT__ 1\n#define __DECIMAL_DIG__ 21\n#define __DEC_EVAL_METHOD__ 2\n#define __ELF__ 1\n#define __FINITE_MATH_ONLY__ 0\n#define __FLOAT_WORD_ORDER__ __ORDER_LITTLE_ENDIAN__\n#define __FLT_DECIMAL_DIG__ 9\n#define __FLT_DENORM_MIN__ 1.40129846432481707092e-45F\n#define __FLT_DIG__ 6\n#define __FLT_EPSILON__ 1.19209289550781250000e-7F\n#define __FLT_EVAL_METHOD__ 0\n#define __FLT_HAS_DENORM__ 1\n#define __FLT_HAS_INFINITY__ 1\n#define __FLT_HAS_QUIET_NAN__ 1\n#define __FLT_MANT_DIG__ 24\n#define __FLT_MAX_10_EXP__ 38\n#define __FLT_MAX_EXP__ 128\n#define __FLT_MAX__ 3.40282346638528859812e+38F\n#define __FLT_MIN_10_EXP__ (-37)\n#define __FLT_MIN_EXP__ (-125)\n#define __FLT_MIN__ 1.17549435082228750797e-38F\n#define __FLT_RADIX__ 2\n#define __FXSR__ 1\n#define __GCC_ASM_FLAG_OUTPUTS__ 1\n#define __GCC_ATOMIC_BOOL_LOCK_FREE 2\n#define __GCC_ATOMIC_CHAR16_T_LOCK_FREE 2\n#define __GCC_ATOMIC_CHAR32_T_LOCK_FREE 2\n#define __GCC_ATOMIC_CHAR_LOCK_FREE 2\n#define __GCC_ATOMIC_INT_LOCK_FREE 2\n#define __GCC_ATOMIC_LLONG_LOCK_FREE 2\n#define __GCC_ATOMIC_LONG_LOCK_FREE 2\n#define __GCC_ATOMIC_POINTER_LOCK_FREE 2\n#define __GCC_ATOMIC_SHORT_LOCK_FREE 2\n#define __GCC_ATOMIC_TEST_AND_SET_TRUEVAL 1\n#define __GCC_ATOMIC_WCHAR_T_LOCK_FREE 2\n#define __GCC_HAVE_DWARF2_CFI_ASM 1\n#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1 1\n#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2 1\n#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4 1\n#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8 1\n#define __GCC_IEC_559 2\n#define __GCC_IEC_559_COMPLEX 2\n#define __GNUC_MINOR__ 3\n#define __GNUC_PATCHLEVEL__ 0\n#define __GNUC_STDC_INLINE__ 1\n#define __GNUC__ 6\n#define __GXX_ABI_VERSION 1010\n#define __INT16_C(c) c\n#define __INT16_MAX__ 0x7fff\n#define __INT16_TYPE__ short int\n#define __INT32_C(c) c\n#define __INT32_MAX__ 0x7fffffff\n#define __INT32_TYPE__ int\n#define __INT64_C(c) c ## L\n#define __INT64_MAX__ 0x7fffffffffffffffL\n#define __INT64_TYPE__ long int\n#define __INT8_C(c) c\n#define __INT8_MAX__ 0x7f\n#define __INT8_TYPE__ signed char\n#define __INTMAX_C(c) c ## L\n#define __INTMAX_MAX__ 0x7fffffffffffffffL\n#define __INTMAX_TYPE__ long int\n#define __INTPTR_MAX__ 0x7fffffffffffffffL\n#define __INTPTR_TYPE__ long int\n#define __INT_FAST16_MAX__ 0x7fffffffffffffffL\n#define __INT_FAST16_TYPE__ long int\n#define __INT_FAST32_MAX__ 0x7fffffffffffffffL\n#define __INT_FAST32_TYPE__ long int\n#define __INT_FAST64_MAX__ 0x7fffffffffffffffL\n#define __INT_FAST64_TYPE__ long int\n#define __INT_FAST8_MAX__ 0x7f\n#define __INT_FAST8_TYPE__ signed char\n#define __INT_LEAST16_MAX__ 0x7fff\n#define __INT_LEAST16_TYPE__ short int\n#define __INT_LEAST32_MAX__ 0x7fffffff\n#define __INT_LEAST32_TYPE__ int\n#define __INT_LEAST64_MAX__ 0x7fffffffffffffffL\n#define __INT_LEAST64_TYPE__ long int\n#define __INT_LEAST8_MAX__ 0x7f\n#define __INT_LEAST8_TYPE__ signed char\n#define __INT_MAX__ 0x7fffffff\n#define __LDBL_DENORM_MIN__ 3.64519953188247460253e-4951L\n#define __LDBL_DIG__ 18\n#define __LDBL_EPSILON__ 1.08420217248550443401e-19L\n#define __LDBL_HAS_DENORM__ 1\n#define __LDBL_HAS_INFINITY__ 1\n#define __LDBL_HAS_QUIET_NAN__ 1\n#define __LDBL_MANT_DIG__ 64\n#define __LDBL_MAX_10_EXP__ 4932\n#define __LDBL_MAX_EXP__ 16384\n#define __LDBL_MAX__ 1.18973149535723176502e+4932L\n#define __LDBL_MIN_10_EXP__ (-4931)\n#define __LDBL_MIN_EXP__ (-16381)\n#define __LDBL_MIN__ 3.36210314311209350626e-4932L\n#define __LONG_LONG_MAX__ 0x7fffffffffffffffLL\n#define __LONG_MAX__ 0x7fffffffffffffffL\n#define __LP64__ 1\n#define __MMX__ 1\n#define __NO_INLINE__ 1\n#define __ORDER_BIG_ENDIAN__ 4321\n#define __ORDER_LITTLE_ENDIAN__ 1234\n#define __ORDER_PDP_ENDIAN__ 3412\n#define __PIC__ 2\n#define __PIE__ 2\n#define __PRAGMA_REDEFINE_EXTNAME 1\n#define __PTRDIFF_MAX__ 0x7fffffffffffffffL\n#define __PTRDIFF_TYPE__ long int\n#define __REGISTER_PREFIX__ \n#define __SCHAR_MAX__ 0x7f\n#define __SEG_FS 1\n#define __SEG_GS 1\n#define __SHRT_MAX__ 0x7fff\n#define __SIG_ATOMIC_MAX__ 0x7fffffff\n#define __SIG_ATOMIC_MIN__ (-__SIG_ATOMIC_MAX__ - 1)\n#define __SIG_ATOMIC_TYPE__ int\n#define __SIZEOF_DOUBLE__ 8\n#define __SIZEOF_FLOAT128__ 16\n#define __SIZEOF_FLOAT80__ 16\n#define __SIZEOF_FLOAT__ 4\n#define __SIZEOF_INT128__ 16\n#define __SIZEOF_INT__ 4\n#define __SIZEOF_LONG_DOUBLE__ 16\n#define __SIZEOF_LONG_LONG__ 8\n#define __SIZEOF_LONG__ 8\n#define __SIZEOF_POINTER__ 8\n#define __SIZEOF_PTRDIFF_T__ 8\n#define __SIZEOF_SHORT__ 2\n#define __SIZEOF_SIZE_T__ 8\n#define __SIZEOF_WCHAR_T__ 4\n#define __SIZEOF_WINT_T__ 4\n#define __SIZE_MAX__ 0xffffffffffffffffUL\n#define __SIZE_TYPE__ long unsigned int\n#define __SSE2_MATH__ 1\n#define __SSE2__ 1\n#define __SSE_MATH__ 1\n#define __SSE__ 1\n#define __SSP_STRONG__ 3\n#define __STDC_HOSTED__ 1\n#define __STDC_IEC_559_COMPLEX__ 1\n#define __STDC_IEC_559__ 1\n#define __STDC_ISO_10646__ 201605L\n#define __STDC_NO_THREADS__ 1\n#define __STDC_UTF_16__ 1\n#define __STDC_UTF_32__ 1\n#define __STDC_VERSION__ 201112L\n#define __STDC__ 1\n#define __UINT16_C(c) c\n#define __UINT16_MAX__ 0xffff\n#define __UINT16_TYPE__ short unsigned int\n#define __UINT32_C(c) c ## U\n#define __UINT32_MAX__ 0xffffffffU\n#define __UINT32_TYPE__ unsigned int\n#define __UINT64_C(c) c ## UL\n#define __UINT64_MAX__ 0xffffffffffffffffUL\n#define __UINT64_TYPE__ long unsigned int\n#define __UINT8_C(c) c\n#define __UINT8_MAX__ 0xff\n#define __UINT8_TYPE__ unsigned char\n#define __UINTMAX_C(c) c ## UL\n#define __UINTMAX_MAX__ 0xffffffffffffffffUL\n#define __UINTMAX_TYPE__ long unsigned int\n#define __UINTPTR_MAX__ 0xffffffffffffffffUL\n#define __UINTPTR_TYPE__ long unsigned int\n#define __UINT_FAST16_MAX__ 0xffffffffffffffffUL\n#define __UINT_FAST16_TYPE__ long unsigned int\n#define __UINT_FAST32_MAX__ 0xffffffffffffffffUL\n#define __UINT_FAST32_TYPE__ long unsigned int\n#define __UINT_FAST64_MAX__ 0xffffffffffffffffUL\n#define __UINT_FAST64_TYPE__ long unsigned int\n#define __UINT_FAST8_MAX__ 0xff\n#define __UINT_FAST8_TYPE__ unsigned char\n#define __UINT_LEAST16_MAX__ 0xffff\n#define __UINT_LEAST16_TYPE__ short unsigned int\n#define __UINT_LEAST32_MAX__ 0xffffffffU\n#define __UINT_LEAST32_TYPE__ unsigned int\n#define __UINT_LEAST64_MAX__ 0xffffffffffffffffUL\n#define __UINT_LEAST64_TYPE__ long unsigned int\n#define __UINT_LEAST8_MAX__ 0xff\n#define __UINT_LEAST8_TYPE__ unsigned char\n#define __USER_LABEL_PREFIX__ \n#define __VERSION__ \"6.3.0 20170406\"\n#define __WCHAR_MAX__ 0x7fffffff\n#define __WCHAR_MIN__ (-__WCHAR_MAX__ - 1)\n#define __WCHAR_TYPE__ int\n#define __WINT_MAX__ 0xffffffffU\n#define __WINT_MIN__ 0U\n#define __WINT_TYPE__ unsigned int\n#define __amd64 1\n#define __amd64__ 1\n#define __code_model_small__ 1\n#define __gnu_linux__ 1\n#define __has_include(STR) __has_include__(STR)\n#define __has_include_next(STR) __has_include_next__(STR)\n#define __k8 1\n#define __k8__ 1\n#define __linux 1\n#define __linux__ 1\n#define __pic__ 2\n#define __pie__ 2\n#define __unix 1\n#define __unix__ 1\n#define __x86_64 1\n#define __x86_64__ 1\n#define linux 1\n#define unix 1\n"
        ]
    },
    {
        "question_id": 1410563,
        "question_code": "",
        "answer_code_snippets": [
            "extern int bar;\nextern int g(int, int);\ndouble f(int, double); // extern can be omitted for function declarations\nclass foo; // no extern allowed for type declarations\n\nint bar;\nint g(int lhs, int rhs) {return lhs*rhs;}\ndouble f(int i, double d) {return i+d;}\nclass foo {};\n\ndouble f(int, double);\ndouble f(int, double);\nextern double f(int, double); // the same as the two above\nextern double f(int, double);\n\nstruct x;\nstruct x {};",
            "void sqrt(double);  // declares sqrt\n\nstruct X\n{\n    int a;         // defines a\n    static int b;  // declares b\n};\n\nclass Y;\n\nextern\nextern const int i = 0;  // defines i\nextern int j;  // declares j\nextern \"C\"\n{\n    void foo();  // declares foo\n}\n\ntypedef\nusing\ntypedef long LONG_32;  // declares LONG_32\nusing namespace std;   // declares std\n",
            "T t;\n\nT\ntypedef void T();\nT t; // declaration of function \"t\"\n\nstruct X { \n  T t; // declaration of function \"t\".\n};\n\ntypedef int T;\nT t; // definition of object \"t\".\n\ntemplate &lt;typename T&gt;\nstruct X { \n  static int member; // declaration\n};\n\ntemplate&lt;typename T&gt;\nint X&lt;T&gt;::member; // definition\n\ntemplate&lt;&gt;\nint X&lt;bool&gt;::member; // declaration!\n\nX&lt;bool&gt;\nX&lt;bool&gt;::member\ntemplate&lt;&gt;\nint X&lt;bool&gt;::member = 1; // definition, belongs into a .cpp file.\n",
            "typedef int myint;",
            "extern int a; \nstruct _tagExample { int a; int b; }; \nint myFunc (int a, int b);\n\nint a; \nint b = 0; \nint myFunc (int a, int b) { return a + b; } \nstruct _tagExample example; \n",
            "enum X : int;\ntemplate&lt;typename T&gt; class MyArray;\nint add(int x, int y);\nusing IntVector = std::vector&lt;int&gt;;\nstatic_assert(sizeof(int) == 4, &quot;Yikes!&quot;)\n;\nint add(int x, int y);\nextern int a;\nextern &quot;C&quot; { ... };\nclass C { static int x; };\nstruct Point;\ntypedef int Int;\nusing std::cout;\nusing namespace NS;\n// except one all these are definitions\nint a;                                  // defines a\nextern const int c = 1;                 // defines c\nint f(int x) { return x + a; }          // defines f and defines x\nstruct S { int a; int b; };             // defines S, S::a, and S::b\nstruct X {                              // defines X\n    int x;                              // defines non-static data member x\n    static int y;                       // DECLARES static data member y\n    X(): x(0) { }                       // defines a constructor of X\n};\nint X::y = 1;                           // defines X::y\nenum { up , down };                     // defines up and down\nnamespace N { int d; }                  // defines N and N::d\nnamespace N1 = N;                       // defines N1\nX anX;                                  // defines anX\n\n\n// all these are declarations\nextern int a;                           // declares a\nextern const int c;                     // declares c\nint f(int);                             // declares f\nstruct S;                               // declares S\ntypedef int Int;                        // declares Int\nextern X anotherX;                      // declares anotherX\nusing N::d;                             // declares N::d\n\n\n// specific to C++11 - these are not from the standard\nenum X : int;                           // declares X with int as the underlying type\nusing IntVector = std::vector&lt;int&gt;;     // declares IntVector as an alias to std::vector&lt;int&gt;\nstatic_assert(X::y == 1, &quot;Oops!&quot;);      // declares a static_assert which can render the program ill-formed or have no effect like an empty declaration, depending on the result of expr\ntemplate &lt;class T&gt; class C;             // declares template class C\n;                                       // declares nothing\n",
            "extern int a;      // Declaration \nint a;             // Definition\na = 10             // Initialization\nint b = 10;        // Definition &amp; Initialization\n\nint a;\nfloat b;\ndouble c;\n\nint fun(int a,int b); \n\nint b=fun(x,y,z);\n\n#include &lt;stdio.h&gt;\nvoid print(int a)\n{\n     printf(\"%d\",a);\n}\nmain()\n{\n    print(5);\n}\n\n #include &lt;stdio.h&gt;\n void print(int a); // In this case this is essential\n main()\n {\n    print(5);\n }\n void print(int a)\n {\n     printf(\"%d\",a);\n }\n\nvoid print(int a)\n{\n    printf(\"%d\",a);\n}\n",
            "// declaration\nint sum(int, int);\n\nsum\nint\nint\n// definition\nint sum(int x, int y)\n{\n    return x + y;\n}\n",
            "void  myfunction(); //this is simple declaration\n\nvoid myfunction()\n{\n some statement;    \n}\n",
            "int sampleFunc(); // function\nextern int car;  // variable\n\nint sampleFunc() {} // function\nint car; // variable\n\nint car = 0; // variable\n",
            "int f(int x); // function declaration (I know f exists)\n\nint f(int x) { return 2*x; } // declaration and definition\n",
            "uint8_t   ui8 = 5;  |   movb    $0x5,-0x45(%rbp)\nint         i = 5;  |   movl    $0x5,-0x3c(%rbp)\nuint32_t ui32 = 5;  |   movl    $0x5,-0x38(%rbp)\nuint64_t ui64 = 5;  |   movq    $0x5,-0x10(%rbp)\ndouble   doub = 5;  |   movsd   0x328(%rip),%xmm0        # 0x400a20\n                        movsd   %xmm0,-0x8(%rbp)\n\nui8 = 5;   |   movb    $0x5,-0x45(%rbp)\ni = 5;     |   movl    $0x5,-0x3c(%rbp)\nui32 = 5;  |   movl    $0x5,-0x38(%rbp)\nui64 = 5;  |   movq    $0x5,-0x10(%rbp)\ndoub = 5;  |   movsd   0x328(%rip),%xmm0        # 0x400a20\n               movsd   %xmm0,-0x8(%rbp)\n\nuint def;                  |  no instructions\nprintf(\"some stuff...\");   |  [...] callq   0x400450 &lt;printf@plt&gt;\ndef=5;                     |  movb    $0x5,-0x45(%rbp)\n",
            "int a;                       // defines a\nextern const int c = 1;      // defines c\nint f(int x) { return x+a; } // defines f and defines x\nstruct S { int a; int b; };  // defines S, S::a, and S::b\nstruct X {                   // defines X\n    int x;                   // defines non-static data member x\n    static int y;            // DECLARES static data member y\n    X(): x(0) { }            // defines a constructor of X\n};\nint X::y = 1;                // defines X::y\nenum { up, down };           // defines up and down\nnamespace N { int d; }       // defines N and N::d\nnamespace N1 = N;            // defines N1\nX anX;                       // defines anX\n\nextern int a;                 // declares a\nextern const int c;           // declares c\nint f(int);                   // declares f\nstruct S;                     // declares S\ntypedef int Int;              // declares Int\nextern X anotherX;            // declares anotherX\nusing N::d;                   // declares d\n",
            "int sp;\ndouble val[MAXVAL]\n\nsp\nval\nextern int sp;\nextern double val[];\n\nsp\nint\nval\ndouble\nextern",
            "int i;\n\nint max(int, int);\n\ni = 20;\n\nint max(int a, int b)\n{\n   if(a&gt;b)   return a;\n   return b;  \n}\n\nint i=20;\n\nint max(int a, int b)\n{\n    if(a&gt;b)   return a;\n    return b;    \n} \n\ni\nfunction max()"
        ]
    },
    {
        "question_id": 1675351,
        "question_code": "typedef\ntypedef\nstruct myStruct{\n    int one;\n    int two;\n};\n\ntypedef struct{\n    int one;\n    int two;\n}myStruct;\n",
        "answer_code_snippets": [
            "typedef struct S { \n    int x; \n} S;\n\nstruct S { \n    int x; \n};\n\ntypedef struct S S;\n\nS\nstruct S\nvoid f( struct S argument ); // struct is required here\n\nS\nvoid f( S argument ); // struct keyword no longer needed\n\nS\ntypedef struct S { \n    int x; \n} T;\n\nvoid S() { } // correct\n\n//void T() {} // error: symbol T already defined as an alias to 'struct S'\n\ntypedef\n // C++\nstruct S { \n    int x; \n}; // S defined as a class\n\nvoid f( S a ); // correct: struct is optional\n\nS\nS\ntypedef struct S { \n    int x; \n} T;\n\nvoid S() {} // correct [*]\n\n//void T() {} // error: symbol T already defined as an alias to 'struct S'\n\nS\nS\nstruct\n// previous code here...\nint main() {\n    S(); \n    struct S s;\n}\n",
            "struct\ntypedef\nstruct\nstruct foo {\n    int n;\n};\n\nstruct foo\nfoo\nstruct\nnamespace\ntypedef\ntypedef int my_int;\n\nmy_int\nint\nmy_int\nint\nstruct\ntypedef struct foo foo;\n\nstruct foo\ntypedef\nfoo\nstruct\ntypedef\ntypedef struct bar {\n    int n;\n} bar;\n\nstruct bar\nbar\nstruct\ntypedef struct node {\n    int data;\n    struct node *next; /* can't use just &quot;node *next&quot; here */\n} node;\n\ntypedef struct node_s {\n    /* ... */\n} node;\n\ntypedef\nstruct bar\ntypedef\nn\nstruct blah\nblah",
            "struct myStruct;\nvoid doit(struct myStruct *ptr);\n\ntypedef struct myStruct{\n    int one;\n    int two;\n} myStruct;\n",
            "struct myStruct myVariable;\n\nmyStruct myVariable;\ntypedef\ntypedef struct myStruct someStruct;\nsomeStruct myVariable;\n\nstruct\ntypedef\nstruct\ntypedef\ntypedef struct { ... } myStruct;\n",
            "struct\ntypedef\nstruct mystruct myvar;\n\nmystruct myvar;\n\ntypedef\nstruct",
            "struct\nunion\nenum\ntypedef\ntypedef",
            "typedef struct\nstruct\ntypedef struct{\n    int one;\n    int two;\n} myStruct;\n\nstruct myStruct; //forward declaration fails\n\nvoid blah(myStruct* pStruct);\n\n//error C2371: 'myStruct' : redefinition; different basic types\n",
            "myStruct\ntypedef struct{\n    int one;\n    int two;\n} myStruct;\n",
            "typedef\nstruct myStruct blah;\n\nmyStruct blah;\n",
            "struct\nstruct myStruct aName;\n\nstruct\nmyStruct aName;\n",
            "struct myStruct\n   {\n   int field_1;\n   ...\n   };\n\ntypedef struct\n   {\n   field_1;\n   ...\n   }myStruct;\n\ntypedef struct\n   {\n   field_1;\n   ...\n   }myStruct,*myStructP;\n\ntypedef struct myStructElement\n   {\n   myStructElement*  nextSE;\n   field_1;\n   ...\n   }myStruct;\n",
            "myStruct a;\n\nstruct myStruct a;\n"
        ]
    },
    {
        "question_id": 98650,
        "question_code": "",
        "answer_code_snippets": [
            "uint32_t\nuint16_t\ntypedef struct Msg\n{\n    unsigned int a;\n    unsigned int b;\n} Msg;\n\nvoid SendWord(uint32_t);\n\nint main(void)\n{\n    // Get a 32-bit buffer from the system\n    uint32_t* buff = malloc(sizeof(Msg));\n    \n    // Alias that buffer through message\n    Msg* msg = (Msg*)(buff);\n    \n    // Send a bunch of messages    \n    for (int i = 0; i &lt; 10; ++i)\n    {\n        msg-&gt;a = i;\n        msg-&gt;b = i+1;\n        SendWord(buff[0]);\n        SendWord(buff[1]);   \n    }\n}\n\nbuff\nbuff[0]\nbuff[1]\nbuff\nvoid SendMessage(uint32_t* buff, size_t size32)\n{\n    for (int i = 0; i &lt; size32; ++i) \n    {\n        SendWord(buff[i]);\n    }\n}\n\nfor (int i = 0; i &lt; 10; ++i)\n{\n    msg-&gt;a = i;\n    msg-&gt;b = i+1;\n    SendMessage(buff, 2);\n}\n\nSendMessage\n  union {\n      Msg msg;\n      unsigned int asBuffer[sizeof(Msg)/sizeof(unsigned int)];\n  };\n\nchar*\nchar*\nsigned char\nunsigned char\nchar*",
            "int*\nint\nfloat*\nfloat\nchar*",
            "int x = 10;\nint *ip = &amp;x;\n\nstd::cout &lt;&lt; *ip &lt;&lt; &quot;\\n&quot;;\n*ip = 12;\nstd::cout &lt;&lt; x &lt;&lt; &quot;\\n&quot;;\n\nint foo( float *f, int *i ) { \n    *i = 1;\n    *f = 0.f;\n    \n    return *i;\n}\n\nint main() {\n    int x = 0;\n    \n    std::cout &lt;&lt; x &lt;&lt; &quot;\\n&quot;;   // Expect 0\n    x = foo(reinterpret_cast&lt;float*&gt;(&amp;x), &amp;x);\n    std::cout &lt;&lt; x &lt;&lt; &quot;\\n&quot;;   // Expect 0?\n}\n\n0\n1\n\nfoo(float*, int*): # @foo(float*, int*)\nmov dword ptr [rsi], 1\nmov dword ptr [rdi], 0\nmov eax, 1\nret\n\nint x = 1;\nint *p = &amp;x;\nprintf(&quot;%d\\n&quot;, *p); // *p gives us an lvalue expression of type int which is compatible with int\n\nint x = 1;\nconst int *p = &amp;x;\nprintf(&quot;%d\\n&quot;, *p); // *p gives us an lvalue expression of type const int which is compatible with int\n\nint x = 1;\nunsigned int *p = (unsigned int*)&amp;x;\nprintf(&quot;%u\\n&quot;, *p ); // *p gives us an lvalue expression of type unsigned int which corresponds to \n                     // the effective type of the object\n\nint x = 1;\nconst unsigned int *p = (const unsigned int*)&amp;x;\nprintf(&quot;%u\\n&quot;, *p ); // *p gives us an lvalue expression of type const unsigned int which is a unsigned type \n                     // that corresponds with to a qualified version of the effective type of the object\n\nstruct foo {\n    int x;\n};\n    \nvoid foobar( struct foo *fp, int *ip );  // struct foo is an aggregate that includes int among its members so it\n                                         // can alias with *ip\n\nfoo f;\nfoobar( &amp;f, &amp;f.x );\n\nint x = 65;\nchar *p = (char *)&amp;x;\nprintf(&quot;%c\\n&quot;, *p );  // *p gives us an lvalue expression of type char which is a character type.\n                      // The results are not portable due to endianness issues.\n\nvoid *p = malloc( sizeof(int) ); // We have allocated storage but not started the lifetime of an object\nint *ip = new (p) int{0};        // Placement new changes the dynamic type of the object to int\nstd::cout &lt;&lt; *ip &lt;&lt; &quot;\\n&quot;;        // *ip gives us a glvalue expression of type int which matches the dynamic type \n                                 // of the allocated object\n\nint x = 1;\nconst int *cip = &amp;x;\nstd::cout &lt;&lt; *cip &lt;&lt; &quot;\\n&quot;;  // *cip gives us a glvalue expression of type const int which is a cv-qualified \n                            // version of the dynamic type of x\n\n// Both si and ui are signed or unsigned types corresponding to each others dynamic types\n// We can see from this godbolt(https://godbolt.org/g/KowGXB) the optimizer assumes aliasing.\nsigned int foo( signed int &amp;si, unsigned int &amp;ui ) {\n    si = 1;\n    ui = 2;\n\n    return si;\n}\n\nsigned int foo( const signed int &amp;si1, int &amp;si2); // Hard to show this one assumes aliasing\n\nstruct foo {\n    int x;\n};\n\n// Compiler Explorer example(https://godbolt.org/g/z2wJTC) shows aliasing assumption\nint foobar( foo &amp;fp, int &amp;ip ) {\n    fp.x = 1;\n    ip = 2;\n\n    return fp.x;\n}\n\nfoo f;\nfoobar( f, f.x );\n\nstruct foo { int x; };\n\nstruct bar : public foo {};\n\nint foobar( foo &amp;f, bar &amp;b ) {\n    f.x = 1;\n    b.x = 2;\n\n    return f.x;\n}\n\nint foo( std::byte &amp;b, uint32_t &amp;ui ) {\n    b = static_cast&lt;std::byte&gt;('a');\n    ui = 0xFFFFFFFF;\n  \n    return std::to_integer&lt;int&gt;( b );  // b gives us a glvalue expression of type std::byte which can alias\n                                       // an object of type uint32_t\n}\n\nint x = 1;\n\n// In C\nfloat *fp = (float*)&amp;x;  // Not a valid aliasing\n\n// In C++\nfloat *fp = reinterpret_cast&lt;float*&gt;(&amp;x);  // Not a valid aliasing\n\nprintf( &quot;%f\\n&quot;, *fp );\n\nunion u1\n{\n    int n;\n    float f;\n};\n\nunion u1 u;\nu.f = 1.0f;\n\nprintf( &quot;%d\\n&quot;, u.n );  // UB in C++ n is not the active member\n\nstatic_assert( sizeof( double ) == sizeof( int64_t ) );  // C++17 does not require a message\n\nvoid func1( double d ) {\n    std::int64_t n;\n    std::memcpy(&amp;n, &amp;d, sizeof d);\n    //...\n\nstd::cout &lt;&lt; bit_cast&lt;float&gt;(0x447a0000) &lt;&lt; &quot;\\n&quot;; //assuming sizeof(float) == sizeof(unsigned int)\n\nstruct uint_chars {\n    unsigned char arr[sizeof( unsigned int )] = {};  // Assume sizeof( unsigned int ) == 4\n};\n\n// Assume len is a multiple of 4 \nint bar( unsigned char *p, size_t len ) {\n    int result = 0;\n\n    for( size_t index = 0; index &lt; len; index += sizeof(unsigned int) ) {\n        uint_chars f;\n        std::memcpy( f.arr, &amp;p[index], sizeof(unsigned int));\n        unsigned int result = bit_cast&lt;unsigned int&gt;(f);\n\n        result += foo( result );\n    }\n\n    return result;\n}\n\nint a = 1;\nshort j;\nfloat f = 1.f; // Originally not initialized but tis-kernel caught \n               // it was being accessed w/ an indeterminate value below\n\nprintf(&quot;%i\\n&quot;, j = *(reinterpret_cast&lt;short*&gt;(&amp;a)));\nprintf(&quot;%i\\n&quot;, j = *(reinterpret_cast&lt;int*&gt;(&amp;f)));\n\nint *p;\n\np = &amp;a;\nprintf(&quot;%i\\n&quot;, j = *(reinterpret_cast&lt;short*&gt;(p)));\n\nint *x = new int[2];               // 8 bytes: [0,7].\nint *u = (int*)((char*)x + 6);     // regardless of alignment of x this will not be an aligned address\n*u = 1;                            // Access to range [6-9]\nprintf( &quot;%d\\n&quot;, *u );              // Access to range [6-9]\n\nint a = 1;\nshort j;\nfloat f = 1.0;\n\nprintf(&quot;%i\\n&quot;, j = *((short*)&amp;a));\nprintf(&quot;%i\\n&quot;, j = *((int*)&amp;f));\n    \nint *p;\n\np = &amp;a;\nprintf(&quot;%i\\n&quot;, j = *((short*)p));\n\n./bin/tis-kernel -sa example1.c \n...\nexample1.c:9:[sa] warning: The pointer (short *)(&amp; a) has type short *. It violates strict aliasing\n              rules by accessing a cell with effective type int.\n...\n\nexample1.c:10:[sa] warning: The pointer (int *)(&amp; f) has type int *. It violates strict aliasing rules by\n              accessing a cell with effective type float.\n              Callstack: main\n...\n\nexample1.c:15:[sa] warning: The pointer (short *)p has type short *. It violates strict aliasing rules by\n              accessing a cell with effective type int.\n",
            "char\nunsigned char\nchar\nunsigned char",
            "#include &lt;stdio.h&gt;\n\nvoid check(short *h,long *k)\n{\n    *h=5;\n    *k=6;\n    if (*h == 5)\n        printf(\"strict aliasing problem\\n\");\n}\n\nint main(void)\n{\n    long      k[1];\n    check((short *)k,k);\n    return 0;\n}\n\ngcc -O2 -o check check.c\nif (*h == 5)\nmovw    $5, (%rdi)\nmovq    $6, (%rsi)\nmovl    $.LC0, %edi\njmp puts\n",
            "int x;\nint test(double *p)\n{\n  x=5;\n  *p = 1.0;\n  return x;\n}\n\nx\np\nx\n*p\nx\nvoid test(void)\n{\n  struct S {int x;} s;\n  s.x = 1;\n}\n\nint\nstruct S\nint\nstruct S\nint test(int *ip, double *dp)\n{\n  *ip = 1;\n  *dp = 1.23;\n  return *ip;\n}\nint test2(void)\n{\n  union U { int i; double d; } u;\n  return test(&amp;u.i, &amp;u.d);\n}\n\n void inc_int(int *p) { *p = 3; }\n int test(void)\n {\n   int *p;\n   struct S { int x; } s;\n   s.x = 1;\n   p = &amp;s.x;\n   inc_int(p);\n   return s.x;\n }\n\ninc_int\n*p\nint\ntest\np\nstruct S\ns\np\n void inc_int(int *p) { *p = 3; }\n int test(void)\n {\n   int *p;\n   struct S { int x; } s;\n   p = &amp;s.x;\n   s.x = 1;  //  !!*!!\n   *p += 1;\n   return s.x;\n }\n\np\ns.x",
            "restrict\nint *\nfloat *\nvoid merge_two_ints(int *a, int *b) {\n  *b += *a;\n  *a += *b;\n}\n\na == b\na\nb\na\nb\nb\na\nb\na\na\na\nb\nvoid merge_two_numbers(int *a, long *b) {...}\n\nrestrict\nvoid merge_two_ints(int * restrict a, int * restrict b) {...}\n\nrestrict\na\nb\na\nb\na\nb\na\nb"
        ]
    },
    {
        "question_id": 15393441,
        "question_code": "main(_){_^448&amp;&amp;main(-~_);putchar(--_%64?32|-~7[__TIME__-_/8%8][\"&gt;'txiZ^(~z?\"-48]&gt;&gt;\";;;====~$::199\"[_*2&amp;8|_/64]/(_&amp;2?1:8)%8&amp;1:10);}\n\ngcc 4.6.3\n    !!  !!!!!!              !!  !!!!!!              !!  !!!!!! \n    !!  !!  !!              !!      !!              !!  !!  !! \n    !!  !!  !!              !!      !!              !!  !!  !! \n    !!  !!!!!!    !!        !!      !!    !!        !!  !!!!!! \n    !!      !!              !!      !!              !!  !!  !! \n    !!      !!              !!      !!              !!  !!  !! \n    !!  !!!!!!              !!      !!              !!  !!!!!!\n\n-Wall\nsykes2.c:1:1: warning: return type defaults to âintâ [-Wreturn-type]\nsykes2.c: In function âmainâ:\nsykes2.c:1:14: warning: value computed is not used [-Wunused-value]\nsykes2.c:1:1: warning: implicit declaration of function âputcharâ [-Wimplicit-function-declaration]\nsykes2.c:1:1: warning: suggest parentheses around arithmetic in operand of â|â [-Wparentheses]\nsykes2.c:1:1: warning: suggest parentheses around arithmetic in operand of â|â [-Wparentheses]\nsykes2.c:1:1: warning: control reaches end of non-void function [-Wreturn-type]\n",
        "answer_code_snippets": [
            "main(_) {\n    _^448 &amp;&amp; main(-~_);\n    putchar(--_%64\n        ? 32 | -~7[__TIME__-_/8%8][\"&gt;'txiZ^(~z?\"-48] &gt;&gt; \";;;====~$::199\"[_*2&amp;8|_/64]/(_&amp;2?1:8)%8&amp;1\n        : 10);\n}\n\nmain(int i) {\n    if(i^448)\n        main(-~i);\n    if(--i % 64) {\n        char a = -~7[__TIME__-i/8%8][\"&gt;'txiZ^(~z?\"-48];\n        char b = a &gt;&gt; \";;;====~$::199\"[i*2&amp;8|i/64]/(i&amp;2?1:8)%8;\n        putchar(32 | (b &amp; 1));\n    } else {\n        putchar(10); // newline\n    }\n}\n\n-~i == i+1\nmain(int i) {\n    if(i != 448)\n        main(i+1);\n    i--;\n    if(i % 64 == 0) {\n        putchar('\\n');\n    } else {\n        char a = -~7[__TIME__-i/8%8][\"&gt;'txiZ^(~z?\"-48];\n        char b = a &gt;&gt; \";;;====~$::199\"[i*2&amp;8|i/64]/(i&amp;2?1:8)%8;\n        putchar(32 | (b &amp; 1));\n    }\n}\n\na[b]\nb[a]\n-~ == 1+\nmain(int i) {\n    if(i != 448)\n        main(i+1);\n    i--;\n    if(i % 64 == 0) {\n        putchar('\\n');\n    } else {\n        char a = (\"&gt;'txiZ^(~z?\"-48)[(__TIME__-i/8%8)[7]] + 1;\n        char b = a &gt;&gt; \";;;====~$::199\"[(i*2&amp;8)|i/64]/(i&amp;2?1:8)%8;\n        putchar(32 | (b &amp; 1));\n    }\n}\n\n// please don't pass any command-line arguments\nmain() {\n    int i;\n    for(i=447; i&gt;=0; i--) {\n        if(i % 64 == 0) {\n            putchar('\\n');\n        } else {\n            char t = __TIME__[7 - i/8%8];\n            char a = \"&gt;'txiZ^(~z?\"[t - 48] + 1;\n            int shift = \";;;====~$::199\"[(i*2&amp;8) | (i/64)];\n            if((i &amp; 2) == 0)\n                shift /= 8;\n            shift = shift % 8;\n            char b = a &gt;&gt; shift;\n            putchar(32 | (b &amp; 1));\n        }\n    }\n}\n\n!\n\"&gt;'txiZ^(~z?\"\n\";;;====~$::199\"\nint shift = \";;;====~$::199\"[(i*2&amp;8) | (i/64)];\ni/64\ni*2&amp;8\ni\nif((i &amp; 2) == 0) shift /= 8; shift = shift % 8\ni%8\ni%8\nrow col val\n6   6-7 0\n6   4-5 0\n6   2-3 5\n6   0-1 7\n5   6-7 1\n5   4-5 7\n5   2-3 5\n5   0-1 7\n4   6-7 1\n4   4-5 7\n4   2-3 5\n4   0-1 7\n3   6-7 1\n3   4-5 6\n3   2-3 5\n3   0-1 7\n2   6-7 2\n2   4-5 7\n2   2-3 3\n2   0-1 7\n1   6-7 2\n1   4-5 7\n1   2-3 3\n1   0-1 7\n0   6-7 4\n0   4-5 4\n0   2-3 3\n0   0-1 7\n\n00005577\n11775577\n11775577\n11665577\n22773377\n22773377\n44443377\n\n7\n__TIME__\n\"HH:MM:SS\"\n:\n__TIME__\n7 - i/8%8\n__TIME__\n7-\ni\nt\n__TIME__\na\nt\n0 00111111\n1 00101000\n2 01110101\n3 01111001\n4 01101010\n5 01011011\n6 01011111\n7 00101001\n8 01111111\n9 01111011\n: 01000000\n\n7\n7\n000055  \n11  55  \n11  55  \n116655  \n22  33  \n22  33  \n444433  \n\n4\n01101010\n----!!--\n!!--!!--\n!!--!!--\n!!!!!!--\n----!!--\n----!!--\n----!!--\n\n  00  \n11  55\n11  55\n  66  \n22  33\n22  33\n  44\n\n\"?;;?==? '::799\\x07\"\n\"?{{?}}?gg::799G\"\nmain(_){_^448&amp;&amp;main(-~_);putchar(--_%64?32|-~7[__TIME__-_/8%8][\"&gt;'txiZ^(~z?\"-48]&gt;&gt;\"?{{?}}?gg::799G\"[_*2&amp;8|_/64]/(_&amp;2?1:8)%8&amp;1:10);}\n\n          !!              !!                              !!   \n    !!  !!              !!  !!  !!  !!              !!  !!  !! \n    !!  !!              !!  !!  !!  !!              !!  !!  !! \n          !!      !!              !!      !!                   \n    !!  !!  !!          !!  !!      !!              !!  !!  !! \n    !!  !!  !!          !!  !!      !!              !!  !!  !! \n          !!              !!                              !!   \n",
            "main(_){\n  _^448&amp;&amp;main(-~_);\n  putchar((--_%64) ? (32|-(~7[__TIME__-_/8%8])[\"&gt;'txiZ^(~z?\"-48]&gt;&gt;(\";;;====~$::199\")[_*2&amp;8|_/64]/(_&amp;2?1:8)%8&amp;1):10);\n}\n\n1\nmain()\n-(~_)\n_\n_^448 == 0\n448/64 == 7\nmain(int argc) {\n  if (argc^448) main(-(~argc));\n  if (argc % 64) {\n    putchar((32|-(~7[__TIME__-argc/8%8])[\"&gt;'txiZ^(~z?\"-48]&gt;&gt;(\";;;====~$::199\")[argc*2&amp;8|argc/64]/(argc&amp;2?1:8)%8&amp;1));\n  } else putchar('\\n');\n}\n\n32\n&amp;1\n-(~(7[__TIME__-argc/8%8][\"&gt;'txiZ^(~z?\"-48]) &gt;&gt;\n     (\";;;====~$::199\"[argc*2&amp;8|argc/64]) / (argc&amp;2?1:8) % 8\n\n__TIME__\n7[__TIME__ - (argc/8)%8]\n\n__TIME__\n[\"&gt;'txiZ^(~z?\"-48]",
            "-~x\nx+1\n~x\n(0xffffffff-x)\n(-1-x)\n-~x\n-(-1-x) = x+1",
            "int pixelX, line, digit ;\nfor(line=6; line &gt;= 0; line--){\n  for (digit =0; digit&lt;8; digit++){\n    for(pixelX=7;pixelX &gt; 0; pixelX--){ \n        putchar(' '| 1 + \"&gt;'txiZ^(~z?\"[\"12:34:56\"[digit]-'0'] &gt;&gt; \n          (\";;;====~$::199\"[pixel*2 &amp; 8  | line] / (pixelX&amp;2 ? 1 : 8) ) % 8 &amp; 1);               \n    }\n  }\n  putchar('\\n');\n}\n\nint pixelX, line, digit, shift;\nchar shiftChar;\nfor(line=6; line &gt;= 0; line--){\n    for (digit =0; digit&lt;8; digit++){\n        for(pixelX=7;pixelX &gt;= 0; pixelX--){ \n            shiftChar = \";;;====~$::199\"[pixelX*2 &amp; 8 | line];\n            if (pixelX &amp; 2)\n                shift = shiftChar &amp; 7;\n            else\n                shift = shiftChar &gt;&gt; 3;     \n            putchar(' '| (\"&gt;'txiZ^(~z?\"[\"12:34:56\"[digit]-'0'] + 1) &gt;&gt; shift &amp; 1 );\n        }\n\n    }\n    putchar('\\n');\n}\n"
        ]
    },
    {
        "question_id": 1538420,
        "question_code": "ptr = malloc(MAXELEMS * sizeof(char *));\n\nptr = calloc(MAXELEMS, sizeof(char*));\n\ncalloc\nmalloc",
        "answer_code_snippets": [
            "calloc()\nmalloc()\ncalloc\nmmap(MAP_ANONYMOUS)\nVirtualAlloc\nmalloc\ncalloc\ncalloc\nmalloc\ncalloc\ncalloc\nmmap(MAP_UNINITIALIZED|MAP_ANONYMOUS)",
            "malloc\ncalloc",
            "calloc\nsize_t count = get_int32(file);\nstruct foo *bar = malloc(count * sizeof *bar);\n\nsize_t count = get_int32(file);\nstruct foo *bar = calloc(count, sizeof *bar);\n\ncount\nSIZE_MAX/sizeof *bar",
            "calloc\nmalloc\ncalloc\ncalloc",
            "calloc\ncalloc\n0\n0\n0.0\ncalloc\nmemset(..., 0, ...)\nunsigned char\nunsigned char\ncalloc\nmemset(..., 0, ...)\ncalloc\nmalloc\ncalloc\ncalloc\nmalloc",
            "malloc()\ncalloc()\nmalloc()\ncalloc()\nmalloc()\ncalloc()\nmalloc()\ncalloc()\nvoid *malloc(size_t bytes);         \nvoid *calloc(size_t length, size_t bytes);      \n\nmalloc\ncalloc\nmalloc\ncalloc",
            "calloc\nmalloc+memset\nmalloc+memset\nptr=malloc(sizeof(Item));\nmemset(ptr, 0, sizeof(Item));\n\nsizeof(Item)\nmemset\ncalloc\ncalloc\nmemset\nsizeof(long)\naligned_memset",
            "malloc()\ncalloc()\nmalloc()\ncalloc()\ncalloc()\ncalloc\nNULL\nptr_var = calloc(no_of_blocks, size_of_each_block); \nptr_var = calloc(n, s);\nmalloc()\nptr_var = malloc(Size_in_bytes);\nmalloc()\ncalloc()\ncalloc()\nmalloc()",
            "malloc()\ncalloc()\nmalloc()\ndata_type ptr = (cast_type *)malloc( sizeof(data_type)*no_of_blocks );\n\nint *ptr = (int *) malloc(sizeof(int) * 10 );\n\ncalloc()\ndata_type ptr = (cast_type *)calloc(no_of_blocks, (sizeof(data_type)));\n\nint *ptr = (int *) calloc(10, (sizeof(int)));\n\nmalloc()\ncalloc()",
            "calloc()\n&lt;stdlib.h&gt;\nmalloc()",
            "malloc()\ncalloc()\nvoid *malloc( size_t n);\nvoid *calloc( size_t n, size_t t)\n\nmalloc()\ncalloc()\nmalloc()\ncalloc()\nint *arr;\n\n// allocate memory for 10 integers with garbage values\narr = (int *)malloc(10 * sizeof(int)); \n\n// allocate memory for 10 integers and sets all of them to 0\narr = (int *)calloc(10, sizeof(int));\n\ncalloc()\nmalloc()\nmemset()\n// allocate memory for 10 integers with garbage values   \narr= (int *)malloc(10 * sizeof(int));\n// set all of them to 0\nmemset(arr, 0, 10 * sizeof(int)); \n\nmalloc()\ncalloc()\ncalloc()",
            "void *malloc(size_t size)\nSIZE_MAX\nvoid *calloc(size_t nmemb, size_t size);\nSIZE_MAX*SIZE_MAX\ncalloc()\nnmemb * size &lt;= SIZE_MAX\ndisk_sector\nSIZE_MAX/sizeof disk_sector\nsize_t count = SIZE_MAX/sizeof disk_sector;\ndisk_sector *p = malloc(count * sizeof *p);\n\nsize_t count = something_in_the_range(SIZE_MAX/sizeof disk_sector + 1, SIZE_MAX)\ndisk_sector *p = calloc(count, sizeof *p);\n\nSIZE_MAX\nSIZE_MAX == 4294967295",
            "malloc\ncalloc\ncalloc\nmalloc\nmemset"
        ]
    },
    {
        "question_id": 65820,
        "question_code": "",
        "answer_code_snippets": [
            "#include \"myimplementationfile.c\"\n#include &lt;gtest/gtest.h&gt;\n\n// Mock out external dependency on mylogger.o\nvoid Logger_log(...){}\n\nTEST(FactorialTest, Zero) {\n    EXPECT_EQ(1, Factorial(0));\n}\n",
            "#include &lt;unity.h&gt;\n\nvoid test_true_should_be_true(void)\n{\n    TEST_ASSERT_TRUE(true);\n}\n\nint main(void)\n{\n    UNITY_BEGIN();\n    RUN_TEST(test_true_should_be_true);\n    return UNITY_END();\n}\n",
            "#include &lt;tap.h&gt;\n\nint main () {\n    plan(5);\n\n    ok(3 == 3);\n    is(\"fnord\", \"eek\", \"two different strings not that way?\");\n    ok(3 &lt;= 8732, \"%d &lt;= %d\", 3, 8732);\n    like(\"fnord\", \"f(yes|no)r*[a-f]$\");\n    cmp_ok(3, \"&gt;=\", 10);\n\n    done_testing();\n}\n",
            "#include &lt;stdarg.h&gt;\n#include &lt;stddef.h&gt;\n#include &lt;setjmp.h&gt;\n#include &lt;cmocka.h&gt;\n\n/* A test case that does nothing and succeeds. */\nstatic void null_test_success(void **state) {\n    (void) state; /* unused */\n}\n\nint main(void) {\n    const struct CMUnitTest tests[] = {\n        cmocka_unit_test(null_test_success),\n    };\n    return cmocka_run_group_tests(tests, NULL, NULL);\n}\n",
            "#include &lt;cheat.h&gt;\n\nCHEAT_TEST(mathematics_still_work,\n    cheat_assert(2 + 2 == 4);\n    cheat_assert_not(2 + 2 == 5);\n)\n\n$ gcc -I . tests.c\n$ ./a.out\n..\n---\n2 successful of 2 run\nSUCCESS\n",
            "assert()\n&amp;&amp;",
            "check_PROGRAMS = test_oe_amqp\n\ntest_oe_amqp_SOURCES = test_oe_amqp.c\ntest_oe_amqp_LDADD = -L$(top_builddir)/components/common -loecommon\ntest_oe_amqp_CFLAGS = -I$(top_srcdir)/components/common -static\n\nTESTS = test_oe_amqp\n"
        ]
    },
    {
        "question_id": 154136,
        "question_code": "do while\n#define FOO(X) do { f(X); g(X); } while (0)\n#define FOO(X) if (1) { f(X); g(X); } else\n\ndo while\n#define FOO(X) f(X); g(X)\n",
        "answer_code_snippets": [
            "do ... while\nif ... else\n#define BAR(X) f(x); g(x)\n\nBAR(X);\nif ... else\nif (corge)\n  BAR(corge);\nelse\n  gralt();\n\nif (corge)\n  f(corge); g(corge);\nelse\n  gralt();\n\nif (corge)\n  {f(corge); g(corge);};\nelse\n  gralt();\n\n#define BAR(X) f(X), g(X)\n\nBAR\nif (corge)\n  f(corge), g(corge);\nelse\n  gralt();\n\nf(X)\ndo ... while\n#define BAR(X) do { \\\n  int i = f(X); \\\n  if (i &gt; 4) g(i); \\\n} while (0)\n\ndo ... while\nif ... else\nif ... else\nif ... else\nif (corge)\n  if (1) { f(corge); g(corge); } else;\nelse\n  gralt();\n\nBAR\ndo ... while",
            "doSomething(1) ;\nDO_SOMETHING_ELSE(2)  // &lt;== Hey? What's this?\ndoSomethingElseAgain(3) ;\n\nif(bIsOk)\n   MY_MACRO(42) ;\n\n#define MY_MACRO(x) f(x) ; g(x)\n\nif(bIsOk)\n   f(42) ; g(42) ; // was MY_MACRO(42) ;\n\ng\nbIsOk\n#define MY_MACRO(x) { f(x) ; g(x) ; }\n\nif(bIsOk)\n   { f(42) ; g(42) ; } ; // was MY_MACRO(42) ;\n\n#define MY_MACRO(x) int i = x + 1 ; f(i) ;\n\nvoid doSomething()\n{\n    int i = 25 ;\n    MY_MACRO(32) ;\n}\n\nvoid doSomething()\n{\n    int i = 25 ;\n    int i = 32 + 1 ; f(i) ; ; // was MY_MACRO(32) ;\n}\n\n#define MY_MACRO(x) { int i = x + 1 ; f(i) ; }\n\nvoid doSomething()\n{\n    int i = 25 ;\n    { int i = 32 + 1 ; f(i) ; } ; // was MY_MACRO(32) ;\n}\n\ndo\n{\n    // code\n}\nwhile(false) ;\n\n#define MY_MACRO(x)                                  \\\ndo                                                   \\\n{                                                    \\\n    const int i = x + 1 ;                            \\\n    f(i) ; g(i) ;                                    \\\n}                                                    \\\nwhile(false)\n\nvoid doSomething(bool bIsOk)\n{\n   int i = 25 ;\n\n   if(bIsOk)\n      MY_MACRO(42) ;\n\n   // Etc.\n}\n\nvoid doSomething(bool bIsOk)\n{\n   int i = 25 ;\n\n   if(bIsOk)\n      do\n      {\n         const int i = 42 + 1 ; // was MY_MACRO(42) ;\n         f(i) ; g(i) ;\n      }\n      while(false) ;\n\n   // Etc.\n}\n\nvoid doSomething(bool bIsOk)\n{\n   int i = 25 ;\n\n   if(bIsOk)\n   {\n      f(43) ; g(43) ;\n   }\n\n   // Etc.\n}\n",
            "#define FOO(x)  f(x); g(x)\n\nif (test) FOO( baz);\n\nif (test) f(baz); g(baz);\n",
            "do ... while\nif ... else\nif ... else\nFOO(1)\nprintf(\"abc\");\n\nif (1) { f(X); g(X); } else\nprintf(\"abc\");\n\nprintf\ndo ... while\nwhile(0)",
            "do {} while (0)\nif (1) {} else\nif (something)\n    FOO(X); \n\nif (something)\n    f(X); g(X); \n\ng(X)\nif\ndo {} while (0)\nif (1) {} else\ndo {} while (0)\nif (1) {} else\n({})\n#define FOO(X) ({f(X); g(X);})\n\ndo {} while (0)\nreturn FOO(&quot;X&quot;);\n",
            "do { ... } while(false);\n#define FOO(X) (f(X),g(X))\n\n#define FOO(X) g((f(X),(X)))\n\n#define\n#define FOO(X) (int s=5,f((X)+s),g((X)+s))\n",
            "if(1) { ... } else\n#define P99_NOP ((void)0)\n#define P99_PREFER(...) if (1) { __VA_ARGS__ } else\n#define P99_BLOCK(...) P99_PREFER(__VA_ARGS__) P99_NOP\n\ndo { ... } while(0)\nbreak\ncontinue\n((void)0)\nelse\nif",
            "#define FOO(X) do { int i; for (i = 0; i &lt; (X); ++i) do_something(i); } while (0)\n\nvoid some_func(void) {\n    int i;\n    for (i = 0; i &lt; 10; ++i)\n        FOO(i);\n}\n",
            "while(i&lt;100)\n  FOO(i++);\n\nwhile(i&lt;100)\n  do { f(i++); g(i++); } while (0)\n\ni++"
        ]
    },
    {
        "question_id": 949433,
        "question_code": "#include &lt;stdio.h&gt;\n\nint main(void)\n{\n   int i = 0;\n   i = i++ + ++i;\n   printf(\"%d\\n\", i); // 3\n\n   i = 1;\n   i = (i++);\n   printf(\"%d\\n\", i); // 2 Should be 1, no ?\n\n   volatile int u = 0;\n   u = u++ + ++u;\n   printf(\"%d\\n\", u); // 1\n\n   u = 1;\n   u = (u++);\n   printf(\"%d\\n\", u); // 2 Should also be one, no ?\n\n   register int v = 0;\n   v = v++ + ++v;\n   printf(\"%d\\n\", v); // 3 (Should be the same as u ?)\n\n   int w = 0;\n   printf(\"%d %d\\n\", ++w, w); // shouldn't this print 1 1\n\n   int x[2] = { 5, 8 }, y = 0;\n   x[y] = y ++;\n   printf(\"%d %d\\n\", x[0], x[1]); // shouldn't this print 0 8? or 5 0?\n}\n",
        "answer_code_snippets": [
            "volatile\nu = (u++);\n",
            "A\nB\nA\nB\nA\nB\nA\nB\nA\nB\nA\nB\nA\nB\nint i = 1;\ni = i++;\n\ni\ni\n++\ni\nil\ni++\nir\nil = ir++     // Note that suffix l and r are used for the sake of clarity.\n              // Both il and ir represents the same object.  \n\n++\n++\nil = ir++\ntemp = ir;      // i = 1\nir = ir + 1;    // i = 2   side effect by ++ before assignment\nil = temp;      // i = 1   result is 1  \n\ntemp = ir;      // i = 1\nil = temp;      // i = 1   side effect by assignment before ++\nir = ir + 1;    // i = 2   result is 2  \n\n1\n2\n++",
            "$ cat evil.c\nvoid evil(){\n  int i = 0;\n  i+= i++ + ++i;\n}\n$ gcc evil.c -c -o evil.bin\n$ gdb evil.bin\n(gdb) disassemble evil\nDump of assembler code for function evil:\n   0x00000000 &lt;+0&gt;:   push   %ebp\n   0x00000001 &lt;+1&gt;:   mov    %esp,%ebp\n   0x00000003 &lt;+3&gt;:   sub    $0x10,%esp\n   0x00000006 &lt;+6&gt;:   movl   $0x0,-0x4(%ebp)  // i = 0   i = 0\n   0x0000000d &lt;+13&gt;:  addl   $0x1,-0x4(%ebp)  // i++     i = 1\n   0x00000011 &lt;+17&gt;:  mov    -0x4(%ebp),%eax  // j = i   i = 1  j = 1\n   0x00000014 &lt;+20&gt;:  add    %eax,%eax        // j += j  i = 1  j = 2\n   0x00000016 &lt;+22&gt;:  add    %eax,-0x4(%ebp)  // i += j  i = 3\n   0x00000019 &lt;+25&gt;:  addl   $0x1,-0x4(%ebp)  // i++     i = 4\n   0x0000001d &lt;+29&gt;:  leave  \n   0x0000001e &lt;+30&gt;:  ret\nEnd of assembler dump.\n",
            "6.5\ni = i++ + ++i;\n\ni++\n++i\ni\nu\n6.5\ni = ++i + 1;\na[i++] = i; \n\n;\ni = i++ + ++i;\n^   ^       ^\n\ni = (i++);\n^    ^\n\nu = u++ + ++u;\n^   ^       ^\n\nu = (u++);\n^    ^\n\nv = v++ + ++v;\n^   ^       ^\n\n3.4.4\n3.4.3",
            "i = i++ + ++i\ni = i++\ni\ni\ni\ni\ni = i + 1\n\ni++\n\ni\ni\ni = i++\n\ni\ni\ni\n++\n++\n++\n++",
            "printf(\"%d %d\\n\", i, i++);\n\nprintf(\"%d %d\\n\", ++i, i++);\n\nprintf()\nx = i++ + i++;\n\nprintf(\"%d %d\\n\", ++i, i++);\n\nprintf()\ni++\n++i\nprintf(\"%d %d\\n\", ++x, y++);\n\n++x\ny++\n++x\ny++\nprintf(\"%d %d\\n\", ++i, i++);\n\ni\nint i = 5;\nint j;\n\nj = (++i, i++);  // No undefined behaviour here because the comma operator \n                 // introduces a sequence point between '++i' and 'i++'\n\nprintf(\"i=%d j=%d\\n\",i, j); // prints: i=7 j=6\n\nj = (++i, i++);\n++i\ni\n6\ni++\ni\n6\nj\ni\n7\nprintf(\"%d %d\\n\", ++i, i++);\n",
            "In a single operation, read `i` and lock it to prevent access until further notice\nCompute (1+read_value)\nIn a single operation, unlock `i` and store the computed value\n\ni\ni++\ni\ni\np\nq\n(*p)\n(*q)\ni\np\nq",
            "a = a++\na++ + a++\ni = ++i + 1;\na[i++] = i;\n\ni = i + 1;\na[i] = i;\n\n-Wall\n-Werror\n% gcc plusplus.c -Wall -Werror -pedantic\nplusplus.c: In function âmainâ:\nplusplus.c:6:6: error: operation on âiâ may be undefined [-Werror=sequence-point]\n    i = i++ + ++i;\n    ~~^~~~~~~~~~~\nplusplus.c:6:6: error: operation on âiâ may be undefined [-Werror=sequence-point]\nplusplus.c:10:6: error: operation on âiâ may be undefined [-Werror=sequence-point]\n    i = (i++);\n    ~~^~~~~~~\nplusplus.c:14:6: error: operation on âuâ may be undefined [-Werror=sequence-point]\n    u = u++ + ++u;\n    ~~^~~~~~~~~~~\nplusplus.c:14:6: error: operation on âuâ may be undefined [-Werror=sequence-point]\nplusplus.c:18:6: error: operation on âuâ may be undefined [-Werror=sequence-point]\n    u = (u++);\n    ~~^~~~~~~\nplusplus.c:22:6: error: operation on âvâ may be undefined [-Werror=sequence-point]\n    v = v++ + ++v;\n    ~~^~~~~~~~~~~\nplusplus.c:22:6: error: operation on âvâ may be undefined [-Werror=sequence-point]\ncc1: all warnings being treated as errors\n\nj = (i ++, ++ i);\n\ni\ni\nj = (i += 2)\ni += 2;\nj = i;\n\n,\nint i = 0;\nprintf(\"%d %d\\n\", i++, ++i, i);\n\ni++\n++i\ni\ni++\n++i",
            "++\n++\n--\n++x\nx++\nint x = 5;\nprintf(&quot;%d %d %d\\n&quot;, x, ++x, x++);\n\n++\nint x = 5;\nx = x++ + ++x;\nprintf(&quot;%d\\n&quot;, x);\n\n++\n--\nprintf(&quot;%d %d %d\\n&quot;, x, ++x, x++);\n\nprintf\nx\nx++\n++x\nx\n++x\nx++\nx++\n++x\nx\nx = x++ + ++x;\n\nx\nx++\nx\nx\n++x\nx\nx\nx =\nx\nx\nx\ny = x++;\nz = x++ + y++;\nx = x + 1;\nx = a[i++];\nx = a[i++] + b[j++];\nx[i++] = a[j++] + b[k++];\nx = *p++;\nx = *p++ + *q++;\n\nx = x++;\nx = x++ + ++x;\ny = x + x++;\na[i] = i++;\na[i++] = i;\nprintf(&quot;%d %d %d\\n&quot;, x, ++x, x++);\n\nx = x++ + ++x;\n\nx\ny = x + x++;\n\nx\nprintf(&quot;%d %d %d\\n&quot;, x, ++x, x++);\nprintf\nprintf(&quot;%d &quot;, x);\nprintf(&quot;%d &quot;, ++x);\nprintf(&quot;%d\\n&quot;, x++);\n\nx = x++ + ++x\nx = x++ + ++x",
            "i = i++;\ni = i++ + ++i;\n\nwhile(*src++ = *dst++);\n",
            "int k[] = {0,1,2,3,4,5,6,7,8,9,10};\nint i = 0;\nint num;\nnum = k[++i+k[++i]] + k[++i];\nprintf(\"%d\", num);\n\n++i\n++i\nk[]\n++i\nk[]\nnum = k[i+1]+k[i+2] + k[i+3];\ni += 3\n",
            "i=i++\ni=\ni++\ni=i++\nexpression-statement\ni=i++\n\ntmp = i\ni=i+1\ni = tmp\n\ntmp = i\ni = tmp\ni=i+1\n\ni=i++",
            " #include&lt;stdio.h&gt;\n int main(int argc, char ** argv)\n {\n    int i = 0;\n    i = i++ + ++i;\n    printf(&quot;%d\\n&quot;, i); // 2\n\n    i = 1;\n    i = (i++);\n    printf(&quot;%d\\n&quot;, i); //1\n\n    volatile int u = 0;\n    u = u++ + ++u;\n    printf(&quot;%d\\n&quot;, u); // 2\n\n    u = 1;\n    u = (u++);\n    printf(&quot;%d\\n&quot;, u); //1\n\n    register int v = 0;\n    v = v++ + ++v;\n    printf(&quot;%d\\n&quot;, v); //2\n }\n\n#include&lt;stdio.h&gt;\nint main(int argc, char ** argv)\n{\n    int i = 0;\n    //i = i++ + ++i;\n    int r;\n    r=i;\n    i++;\n    ++i;\n    r+=i;\n    i=r;\n    printf(&quot;%d\\n&quot;, i); // 2\n\n    i = 1;\n    //i = (i++);\n    r=i;\n    i++;\n    i=r;\n    printf(&quot;%d\\n&quot;, i); // 1\n\n    volatile int u = 0;\n    //u = u++ + ++u;\n    r=u;\n    u++;\n    ++u;\n    r+=u;\n    u=r;\n    printf(&quot;%d\\n&quot;, u); // 2\n\n    u = 1;\n    //u = (u++);\n    r=u;\n    u++;\n    u=r;\n    printf(&quot;%d\\n&quot;, u); // 1\n\n    register int v = 0;\n    //v = v++ + ++v;\n    r=v;\n    v++;\n    ++v;\n    r+=v;\n    v=r;\n    printf(&quot;%d\\n&quot;, v); //2\n}\n\n#include&lt;stdio.h&gt;\nint main(int argc, char ** argv)\n{\n    int i = 0;\n    i = i++ + ++i;\n    printf(&quot;%d\\n&quot;, i); // 3\n\n    i = 1;\n    i = (i++);\n    printf(&quot;%d\\n&quot;, i); // 2 \n\n    volatile int u = 0;\n    u = u++ + ++u;\n    printf(&quot;%d\\n&quot;, u); // 3\n\n    u = 1;\n    u = (u++);\n    printf(&quot;%d\\n&quot;, u); // 2 \n\n    register int v = 0;\n    v = v++ + ++v;\n    printf(&quot;%d\\n&quot;, v); // 3 \n}\n\n#include&lt;stdio.h&gt;\nint main(int argc, char ** argv)\n{\n    int r;\n    int i = 0;\n    //i = i++ + ++i;\n    ++i;\n    r = i + i;\n    i = r;\n    i++;\n    printf(&quot;%d\\n&quot;, i); // 3\n\n    i = 1;\n    //i = (i++);\n    r = i;\n    i = r;\n    i++;\n    printf(&quot;%d\\n&quot;, i); // 2 \n\n    volatile int u = 0;\n    //u = u++ + ++u;\n    ++u;\n    r = u + u;\n    u = r;\n    u++;\n    printf(&quot;%d\\n&quot;, u); // 3\n\n    u = 1;\n    //u = (u++);\n    r = u;\n    u = r;\n    u++;\n    printf(&quot;%d\\n&quot;, u); // 2 \n\n    register int v = 0;\n    //v = v++ + ++v;\n    ++v;\n    r = v + v;\n    v = r;\n    v++;\n    printf(&quot;%d\\n&quot;, v); // 3 \n}\n",
            "i++\ni\ni\ni+1\ni\ni++ + ++i\ni\ni+1\ni++ + ++i\ni\ni\ni\ni\ni+i+1\ni+2\ni\n2*i+1; i+=2;\n++\ni=i+1"
        ]
    },
    {
        "question_id": 2346806,
        "question_code": "",
        "answer_code_snippets": [
            "int *p = NULL;\n*p = 1;\n\nchar *str = &quot;Foo&quot;; // Compiler marks the constant string as read-only\n*str = 'b'; // Which means this is illegal and results in a segfault\n\nchar *p = NULL;\n{\n    char c;\n    p = &amp;c;\n}\n// Now p is dangling\n\np\nc\n*p='A'",
            "int *arr = new int[20];\ndelete arr;\ncout&lt;&lt;arr[1];  //dangling problem occurs here\n",
            "#include &lt;stdio.h&gt;\n\nint main(int argc, char *argv[]) {\n    \n    char A = 'asd';\n    puts(A);\n    \n    return 0;\n    \n}\n\nchar\nstring\nchar",
            "int main(int argc, char *argv[])",
            "printf\n#include &lt;stdio.h&gt;\nint main(){   \n  int a = 5;\n  printf(&quot;%s&quot;,a);\n  return 0;\n}\n\nSegmentation Fault (SIGSEGV)\n#include &lt;stdio.h&gt; \ntypedef struct{\n  int a;\n} myStruct;   \nint main(){\n  myStruct *s;\n  /* few lines of code */\n  s-&gt;a = 5;\n  return 0;\n}\n\nSegmentation Fault (SIGSEGV)",
            "Segmentation fault\nSegmentation fault\nSegmentation fault\nscanf()\n&amp;\nint num;\nscanf(\"%d\", num);// must use &amp;num instead of num\n\nint *num; \nprintf(\"%d\",*num); //*num should be correct as num only\n//Unless You can use *num but you have to point this pointer to valid memory address before accessing it.\n\nchar *str;  \n\n//Stored in read only part of data segment\nstr = \"GfG\";      \n\n//Problem:  trying to modify read only memory\n*(str+1) = 'n';\n\n// allocating memory to num \nint* num = malloc(8); \n*num = 100; \n\n// de-allocated the space allocated to num \nfree(num); \n\n// num is already freed there for it cause segmentation fault\n*num = 110; \n\nprintf()\nscanf()",
            "int *number = NULL;\n*number = 1;\n\nint *number = malloc(sizeof(int));\n*number = 1;\n\nmalloc()\nsizeof()",
            " /* \"Array out of bounds\" error \n   valid indices for array foo\n   are 0, 1, ... 999 */\n   int foo[1000];\n   for (int i = 0; i &lt;= 1000 ; i++) \n   foo[i] = i;\n\nit arise primarily due to errors in use of pointers for virtual memory addressing, particularly illegal access.\n\nDe-referencing NULL pointers â this is special-cased by memory management hardware.\n\nAttempting to access a nonexistent memory address (outside processâs address space).\n\nAttempting to access memory the program does not have rights to (such as kernel structures in process context).\n\nAttempting to write read-only memory (such as code segment).\n"
        ]
    },
    {
        "question_id": 1921539,
        "question_code": "",
        "answer_code_snippets": [
            "#include &lt;stdbool.h&gt;\n\ntypedef enum { false, true } bool;\n\ntypedef int bool;\nenum { false, true };\n\ntypedef int bool;\n#define true 1\n#define false 0\n",
            "int\n&lt;stdbool.h&gt;\nif (ready == TRUE) ...\nwhile (empty == FALSE) ...\n\nif (ready) ...\nwhile (!empty) ...\n\nfull\nnotfull\nif (full) ...\nif (!full) ...\n\nif (!notfull) ...\nif (notfull) ...\n\n!notfull\nvoid foo(bool option) { ... }\n\nfoo(TRUE);\nfoo(FALSE):\n\ntypedef enum { OPT_ON, OPT_OFF } foo_option;\nvoid foo(foo_option option);\n\n#define OPT_ON true\n#define OPT_OFF false\nvoid foo(bool option) { ... }\n\nfoo(OPT_ON);\nfoo(OPT_OFF);\n\nfoo",
            "typedef enum { false = 0, true = !false } bool;\n\nif (true == !false)\n\ntypedef enum { myfalse = 0, mytrue = !myfalse } mybool;\n\ntrue\nfalse\nmybool somebool;\nint someint = 5;\nsomebool = !!someint;\n\nmyfalse\nfalse = 0,\nfalse,\ntypedef __attribute__((__packed__)) enum { myfalse = 0, mytrue = !myfalse } mybool;\n\nstruct mystruct {\n    mybool somebool1;\n    mybool somebool2;\n    mybool somebool3;\n    mybool somebool4;\n}\n",
            "#include &lt;stdbool.h&gt;\nint main()\n{\n  bool b = false;\n  b = true;\n}\n",
            "#include &lt;stdbool.h&gt;\ntrue\nfalse\nbool\n_Bool\n1\n0\ntypedef int bool;\n#define true 1\n#define false 0\n\nbool\nbool\ndouble a = ...;\nbool b = a;\n\nbool\n_Bool\nb\nfalse\na\ntrue\n_Bool\ntypedef\ndouble\nint\nint\ntrue\nfalse\nenum\ntypedef enum bool {\n    false, true\n} bool;\n\nint\n0\n1\n!!\nBOOL\nTRUE\nFALSE",
            "typedef enum {\n    false = 0,\n    true\n} t_bool;\n",
            "#define TRUE 1\n#define FALSE 0\n",
            "+-------+----------------+-------------------------+--------------------+\n|  Name | Characteristic | Dependence in stdbool.h |        Value       |\n+-------+----------------+-------------------------+--------------------+\n| _Bool |   Native type  |    Don't need header    |                    |\n+-------+----------------+-------------------------+--------------------+\n|  bool |      Macro     |           Yes           | Translate to _Bool |\n+-------+----------------+-------------------------+--------------------+\n|  true |      Macro     |           Yes           |   Translate to 1   |\n+-------+----------------+-------------------------+--------------------+\n| false |      Macro     |           Yes           |   Translate to 0   |\n+-------+----------------+-------------------------+--------------------+\n\n_Bool\nbool\nbool\n_Bool\nbool\n_Bool\nfalse\ntrue\n0\n1\nfalse\ntrue\n_Bool\nunsigned int\n0\n1\nbool\ntrue\nfalse\n_Bool\nbool\n0\n0\n0\n1\n _Bool x = 9;\n9\n1\nx\n_Bool\nchar",
            "#include &lt;stdbool.h&gt;\n#include &lt;stdbool.h&gt;\n\nint main() \n{ \n    bool arr[2] = {true, false}; \n\n    printf(\"%d\\n\", arr[0] &amp;&amp; arr[1]);\n    printf(\"%d\\n\", arr[0] || arr[1]);\n\n    return 0; \n} \n\n0\n1\n",
            "bool\n_Bool\ntrue\nfalse\nbool\n_Bool\ntrue\nfalse\n!\n||\n&amp;&amp;\nbool\nfalse\nnull\nnullptr_t\ntrue\nbool\ntrue\nfalse\n&lt;stdbool.h&gt;\n__bool_true_false_are_defined\n_Bool\n1\n0\n!\n||\n&amp;&amp;\n_Bool\n0\n1\n&lt;stdbool.h&gt;\nbool\n_Bool\ntrue\n_Bool\n1\nfalse\n0\n__bool_true_false_are_defined\n1\nbool\ntrue\nfalse\ntypedef enum { false, true } bool;",
            "void foo(bool flag);\n\n...\n\nint flag = TRUE;\nfoo(flag);\n\nfoo(flag == TRUE);\n\nfoo(flag == !0);\n",
            "#define TRUE  1\n#define FALSE 0\n\nchar bValue = TRUE;\n",
            "#define TRUE 1\n#define FALSE 0\n",
            "_Bool\n#include\n1\ntrue\n0\nfalse\nTRUE\nFALSE\n_Bool this_is_a_Boolean_var = 1;\n\n\n//or using it with true and false\n#define TRUE 1\n#define FALSE 0\n_Bool var = TRUE;\n",
            "enum {false, true};\ntypedef _Bool bool;\n\n_Bool",
            "#define\n#define TRUE 1\n#define FALSE 0\n#define NOT(arg) (arg == TRUE)? FALSE : TRUE\ntypedef int bool;\n\nbool isVisible = FALSE;\nbool isWorking = TRUE;\nisVisible = NOT(isVisible);\n"
        ]
    },
    {
        "question_id": 16931770,
        "question_code": "all:ll\n\nll:ll.c   \n  gcc  -c  -Wall -Werror -02 c.c ll.c  -o  ll  $@  $&lt;\n\nclean :\n  \\rm -fr ll\n\nmake clean\nmake make\n:makefile:4: *** missing separator.  Stop.\n",
        "answer_code_snippets": [
            "cat -e -t -v makefile_name\n^I\n$\nKaizen ~/so_test $ cat -e -t -v  mk.t\nall:ll$      ## here the $ is end of line ...                   \n$\nll:ll.c   $\n^Igcc  -c  -Wall -Werror -02 c.c ll.c  -o  ll  $@  $&lt;$ \n## the ^I above means a tab was there before the action part, so this line is ok .\n $\nclean :$\n   \\rm -fr ll$\n## see here there is no ^I which means , tab is not present .... \n## in this case you need to open the file again and edit/ensure a tab \n## starts the action part\n",
            ".RECIPEPREFIX\ngcc\ngcc\n\\rm -fr ll\nrm -fr ll",
            "make\nbash\nsometask:\n  ifeq ($FOO,bar)  // this is make code. only spaces\n    echo &quot;foobar&quot;  // this is bash code. only tabs\n  endif            // again, this is make code. only spaces\n",
            "PyCharm\nMakefile support\nPreferences\ncmd + ,\nPlugins\nMarketplace\nMakefile support",
            ".editorconfig\nroot = true\n\n[*]\ncharset = utf-8\nend_of_line = lf\ninsert_final_newline = true\nindent_style = space\nindent_size = 4\n\n[Makefile]\nindent_style = tab\n",
            "vi/vim\nvi/vim\nMakefile\nvim Makefile\n:set list\n %-linux: force$\n^I@if [ \"$(GCC_VERSION)\" = \"2.96\" ] ; then \\$\n^I^Iecho ===== Generating build tree for legacy $@ architecture =====; \\$\n^I^I$(CONFIGURE) $(CWD) $@ legacy; \\$\n^Ielse \\$\n^I^Iecho ===== Generating build tree for $@ architecture =====; \\$\n^I^I$(CONFIGURE) $(CWD) $@; \\$\n^Ifi$\n^Icd build-$@;make$\n",
            ".vimrc\nset tabstop=X",
            "Other File Types\nUse tab character\nTab size\nIndent",
            "perl -pi -e 's/^  */\\t/' Makefile",
            ".editorconfig\n[Makefile]\nindent_style = tab\n",
            ":set noet\n*** missing separator.  Stop.\n:set et",
            "Windows-&gt; Preferences-&gt;General-&gt;Editor-&gt;Text Editors-&gt;Show Whitespace Characters -&gt; Apply\n",
            "*** missing separator.  Stop.\n\n/home/user/#my_sources/\n"
        ]
    },
    {
        "question_id": 119123,
        "question_code": "sizeof",
        "answer_code_snippets": [
            "SIGBUS\nstruct X\n{\n    short s; /* 2 bytes */\n             /* 2 padding bytes */\n    int   i; /* 4 bytes */\n    char  c; /* 1 byte */\n             /* 3 padding bytes */\n};\n\nstruct Y\n{\n    int   i; /* 4 bytes */\n    char  c; /* 1 byte */\n             /* 1 padding byte */\n    short s; /* 2 bytes */\n};\n\nstruct Z\n{\n    int   i; /* 4 bytes */\n    short s; /* 2 bytes */\n    char  c; /* 1 byte */\n             /* 1 padding byte */\n};\n\nconst int sizeX = sizeof(struct X); /* = 12 */\nconst int sizeY = sizeof(struct Y); /* = 8 */\nconst int sizeZ = sizeof(struct Z); /* = 8 */\n\nZ\n#pragma",
            "struct {\n    char a[3];\n    short int b;\n    long int c;\n    char d[3];\n};\n\n+-------+-------+-------+-------+\n|           a           |   b   |\n+-------+-------+-------+-------+\n|   b   |           c           |\n+-------+-------+-------+-------+\n|   c   |           d           |\n+-------+-------+-------+-------+\n\n+-------+-------+-------+\n|           a           |\n+-------+-------+-------+\n|       b       |\n+-------+-------+-------+-------+\n|               c               |\n+-------+-------+-------+-------+\n|           d           |\n+-------+-------+-------+\n\n+-------+-------+-------+-------+\n|           a           | pad1  |\n+-------+-------+-------+-------+\n|       b       |     pad2      |\n+-------+-------+-------+-------+\n|               c               |\n+-------+-------+-------+-------+\n|           d           | pad3  |\n+-------+-------+-------+-------+\n",
            "__attribute__((packed))",
            "#include \"stdio.h\"\n\n\nstruct oneInt {\n  int x;\n};\n\nstruct twoInts {\n  int x;\n  int y;\n};\n\nstruct someBits {\n  int x:2;\n  int y:6;\n};\n\n\nint main (int argc, char** argv) {\n  printf(\"oneInt=%zu\\n\",sizeof(struct oneInt));\n  printf(\"twoInts=%zu\\n\",sizeof(struct twoInts));\n  printf(\"someBits=%zu\\n\",sizeof(struct someBits));\n  return 0;\n}\n\noneInt=4\ntwoInts=8\nsomeBits=4\n",
            "struct myStruct\n{\n   int a;\n   char b;\n   int c;\n} data;\n\n#pragma pack 1\nstruct MyStruct\n{\n    int a;\n    char b;\n    int c;\n    short d;\n} myData;\n\nI = sizeof(myData);\n",
            "struct S {int is[];};",
            "struct pixel {\n    unsigned char red;   // 0\n    unsigned char green; // 1\n    unsigned int alpha;  // 4 (gotta skip to an aligned offset)\n    unsigned char blue;  // 8 (then skip 9 10 11)\n};\n\n// next offset: 12\n",
            "sizeof\nsizeof\nsizeof\nsizeof\nsizeof\nstruct foo {\n   int a;   \n   int b;\n   int c;     \n} bar;\n\nsizeof(int) == 4\nbar\nsizeof(bar) == 12\nstruct foo {\n   short int a;   \n   short int b;\n   int c;     \n} bar;\n\nsizeof(short int) == 2\nsizeof(int) == 4\na\nb\nc\nsizeof(bar) == 8",
            "#pragma pack(push, 1)\n\n// your structure\n\n#pragma pack(pop) \n"
        ]
    },
    {
        "question_id": 204476,
        "question_code": "main()\nint main()\nvoid main()\nint main()\nreturn 1\nreturn 0",
        "answer_code_snippets": [
            "main\nmain\nvoid main()\nmain\nint main(void)\n\nint main(int argc, char **argv)\n\nint main(int argc, char *argv[])\n\nint main()\nreturn 0;\nmain\nmain()\nint main()\nint main(int argc, char **argv)\nreturn 0;",
            "main()\nint main(void)\nint main(int argc, char **argv)\n\nint main(int argc, char *argv[])\nint\nint\nmain()\nint main(int argc, char *argv[], char *envp[])\n0\nEXIT_SUCCESS\nEXIT_FAILURE\nmain()\nreturn\nmain()\nmain()\nreturn 0\nmain()",
            "main\nint\nint main(void) { /* ... */ }\n\nargc\nargv\nint main(int argc, char *argv[]) { /* ... */ }\n\nargc\nargv[argc]\nargc\nargv[0]\nargv[argc-1]\nargc\nargv[0]\nargv[0][0]\nargc\nargv[1]\nargv[argc-1]\nargc\nargv\nargv\nint\nint\nargv\nchar **argv\nmain()\nmain\nint\nmain\nexit\nmain\n}\nmain\nint\nmain\n0\nEXIT_FAILURE\nEXIT_SUCCESS\n&lt;stdlib.h&gt;\nmain()\nexit\nstatus\nEXIT_SUCCESS\nstatus\nEXIT_FAILURE\nint main() { /* ... */ }\n\nint main(int argc, char* argv[]) { /* ... */ }\n\nargc\nargc\nargv[0]\nargv[argc-1]\nargv[0]\n&quot;&quot;\nargc\nargv[argc]\nargv\nmain\nmain\nstd::exit\nreturn 0;\n\nint\nmain\nexit\nEXIT_SUCCESS\nEXIT_FAILURE\n&lt;cstdlib&gt;\nint main(int argc, char **argv, char **envp) { ... }\n\nextern char **environ;\nchar *envp[]\nchar\n int main();\n\nint main(int argc, char *argv[], char *envp[]);\n\nmain\nwmain\nvoid\nmain\nwmain\nmain\nwmain\nvoid\nexit\nvoid main()\nmain()\nchar **envp\nwmain()\nvoid main()\nmain\n&lt;float.h&gt;\n&lt;iso646.h&gt;\n&lt;limits.h&gt;\n&lt;stdalign.h&gt;\n&lt;stdarg.h&gt;\n&lt;stdbool.h&gt;\n&lt;stddef.h&gt;\n&lt;stdint.h&gt;\n&lt;stdnoreturn.h&gt;\n#ifdef __STDC_IEC_559__ /* FE_UPWARD defined */\n    /* ... */\n    fesetround(FE_UPWARD);\n    /* ... */\n#endif\n\n&lt;stdarg.h&gt;\n&lt;cstdlib&gt;\nabort\natexit\nat_quick_exit\nexit\nquick_exit\n&lt;ciso646&gt;\n&lt;cstddef&gt;\n&lt;cfloat&gt;\n&lt;limits&gt;\n&lt;climits&gt;\n&lt;cstdint&gt;\n&lt;cstdlib&gt;\n&lt;new&gt;\n&lt;typeinfo&gt;\n&lt;exception&gt;\n&lt;initializer_list&gt;\n&lt;cstdalign&gt;\n&lt;cstdarg&gt;\n&lt;cstdbool&gt;\n&lt;type_traits&gt;\n&lt;atomic&gt;\nint main()\nint main(void)\nint main()\nint main()\nint main()\nsizeof\n_Alignof\n#include &lt;stddef.h&gt;\n\nsize_t fsize3(int n)\n{\n    char b[n+3]; // variable length array\n    return sizeof b; // execution time sizeof\n}\nint main()\n{\n    size_t size;\n    size = fsize3(10); // fsize3 returns 13\n    return 0;\n}\n\nint main(){ â¦ }\nmain()\nmain()\nmain()\nint i = 0;\nint main()\n{\n    if (i++ &lt; 10)\n        main(i, i * i);\n    return 0;\n}\n\n-Wstrict-prototypes\nmain(void)",
            "main()\nEXIT_SUCCESS\nEXIT_FAILURE\nstdlib.h",
            "int main (void)\nint main (int argc, char *argv[])\n\nmain (void)\nmain (int argc, char *argv[])\n/*... etc, similar forms with implicit int */\n\nint main (void)\nint main (int argc, char *argv[])\n/* or in some other implementation-defined manner. */\n\nmain()\nint main()\nmain()\nint main\nint main (void)\nint main (int argc, char *argv[])\n/* or in some other implementation-defined manner. */\n\nint main()\n()\n(void)\nint main ()\nint main (int argc, char *argv[])\n\nmain()\n// implementation-defined name, or \nint main ()\nint main (int argc, char *argv[])\n\nint main ()\nint main (int argc, char *argv[])\n\nmain()\n// implementation-defined name, or \nint main ()\nint main (int argc, char *argv[])\n\nint main(void) { /* ... */ } \n\nint main(int argc, char *argv[]) { /* ... */ }\n\nint main(void) { /* ... */ } \n\nint main(int argc, char *argv[]) { /* ... */ }\n\n}\nint main() { /* ... */ }\n\nint main(int argc, char* argv[]) { /* ... */ }\n",
            "main()\nreturn 1? return 0?\n\nint main()\n}\nreturn 0\nreturn 1\nmain()\n$ ./a.out\n$ echo $?\n\n$?\nmain()\nreturn 0",
            "main()\nzero",
            "return 0\nmain\nreturn 0;\nmain\nmain\nexit\nmain\n}\nmain\nreturn;\nvoid\nreturn 0;\nmain",
            "main()\nint\nmain()\nint\nmain()\nmain()\nmain()\nmain\nmain",
            "int main (void) { .. return 0; .. }",
            "$ grep order myfile\n\n$ echo $?\n$ 0\n\n$ grep foo myfile\n$ echo $?\n$ 1\n\n$ grep foo myfile\n$ CHECK=$?\n$ [ $CHECK -eq 0] &amp;&amp; echo 'Match found'; [ $CHECK -ne 0] &amp;&amp; echo 'No match was found'\n$ No match was found\n",
            "int\nint main(void) { /* ... */ }\n\nargc\nargv\nint main(int argc, char *argv[]) { /* ... */ }\n\nint read_file(char filename[LEN]);",
            "STATUS_ACCESS_VIOLATION (0xC0000005)\nmain\nexit"
        ]
    },
    {
        "question_id": 9410,
        "question_code": "",
        "answer_code_snippets": [
            "void func ( void (*f)(int) );\n\nf\nvoid\nint\nprint\nfunc\nvoid print ( int x ) {\n  printf(\"%d\\n\", x);\n}\n\nfunc(print);\n\nfunc\nfunc\nfunc\nfor ( int ctr = 0 ; ctr &lt; 5 ; ctr++ ) {\n  print(ctr);\n}\n\nfunc\nf\nf\n*f\nf\nprint\n*f\nvoid func ( void (*f)(int) ) {\n  for ( int ctr = 0 ; ctr &lt; 5 ; ctr++ ) {\n    (*f)(ctr);\n  }\n}\n",
            "typedef void (*functiontype)();\n\nvoid dosomething() { }\n\nfunctiontype func = &amp;dosomething;\nfunc();\n\ntypedef int (*functiontype2)(char);\n\nint dosomethingwithchar(char a) { return 1; }\n\nfunctiontype2 func2 = &amp;dosomethingwithchar\nint result = func2('a');\n\nboost::function&lt;int (char a)&gt; functiontype2;\n",
            "std::function&lt;bool (int)&gt;\n\nbool\nint\n// g++ test.cpp --std=c++11\n#include &lt;functional&gt;\n\ndouble Combiner(double a, double b, std::function&lt;double (double,double)&gt; func){\n  return func(a,b);\n}\n\ndouble Add(double a, double b){\n  return a+b;\n}\n\ndouble Mult(double a, double b){\n  return a*b;\n}\n\nint main(){\n  Combiner(12,13,Add);\n  Combiner(12,13,Mult);\n}\n\n// g++ test.cpp --std=c++11\n\ntemplate&lt;class T&gt;\ndouble Combiner(double a, double b, T func){\n  return func(a,b);\n}\n\ndouble Add(double a, double b){\n  return a+b;\n}\n\ndouble Mult(double a, double b){\n  return a*b;\n}\n\nint main(){\n  Combiner(12,13,Add);\n  Combiner(12,13,Mult);\n}\n",
            "#include &lt;stdio.h&gt;\n\nvoid print();\nvoid execute(void());\n\nint main()\n{\n    execute(print); // sends address of print\n    return 0;\n}\n\nvoid print()\n{\n    printf(\"Hello!\");\n}\n\nvoid execute(void f()) // receive address of print\n{\n    f();\n}\n\n#include &lt;stdio.h&gt;\n\nvoid print();\nvoid execute(void (*f)());\n\nint main()\n{\n    execute(&amp;print); // sends address of print\n    return 0;\n}\n\nvoid print()\n{\n    printf(\"Hello!\");\n}\n\nvoid execute(void (*f)()) // receive address of print\n{\n    f();\n}\n",
            "void foo(int bar(int, int));\n\nvoid foo(int (*bar)(int, int));\n",
            "compare\nsorting\nbool compare(int a, int b) {\n    return a &gt; b;\n}\n\nvoid bubble_sort(int arr[], int n, bool (&amp;cmp)(int a, int b)) {\n\n    for (int i = 0;i &lt; n - 1;i++) {\n        for (int j = 0;j &lt; (n - 1 - i);j++) {\n            \n            if (cmp(arr[j], arr[j + 1])) {\n                swap(arr[j], arr[j + 1]);\n            }\n        }\n    }\n}\n\nmain\nint main()\n{\n    int i, n = 10, key = 11;\n    int arr[10] = { 20, 22, 18, 8, 12, 3, 6, 12, 11, 15 };\n\n    bubble_sort(arr, n, compare);\n    cout&lt;&lt;&quot;Sorted Order&quot;&lt;&lt;endl;\n    for (int i = 0;i &lt; n;i++) {\n        cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;\n    }\n}\n\nSorted Order\n3 6 8 11 12 12 15 18 20 22\n",
            "typedef int function();\n\nfunction *g(function *f)\n{\n    f();\n    return f;\n}\n\nint main(void)\n{\n    function f;\n\n    function *fn = g(f);\n\n    fn();\n}\n\nint f() { return 0; }\n",
            "#include &lt;stdio.h&gt;\n\nint IncMultInt(int a, int b)\n{\n    a++;\n    return a * b;\n}\n\nint main(int argc, char *argv[])\n\n{\n    int a = 5;\n    int b = 7;\n\n    printf(\"%d * %d = %d\\n\", a, b, IncMultInt(a, b));\n\n    b = 9;\n\n    // Create some local code with it's own local variable\n    printf(\"%d * %d = %d\\n\", a, b,  ( { int _a = a+1; _a * b; } ) );\n\n    return 0;\n}\n"
        ]
    },
    {
        "question_id": 2550774,
        "question_code": "size_t\nsizeof\nfor\nfor(i = 0; i &lt; some_size; i++)\n\nint i;\nsize_t i;",
        "answer_code_snippets": [
            "size_t\nsize_t\nstddef.h\nstdlib.h\nstddef.h\nsize_t\nsize_t\nsize_t",
            "size_t\nstrlen()\nsize_t\nsize_t\nsize_t\nsize_t s1 = strlen(str1);\nsize_t s2 = strlen(str2);\n\nstr2\nstr1\nint diff = s2 - s1; /* bad */\n\ndiff\ns2 &lt; s1\nint\nlong long\ns1\ns2\nsize_t\nfgets\nsize_t\nint",
            "size_t\nunsigned char\nunsigned short\nunsigned int\nunsigned long\nunsigned long long\nsize_t\nstddef.h\ntypedef unsigned long size_t;\n",
            "echo | gcc -E -xc -include 'stddef.h' - | grep size_t\n\ntypedef long unsigned int size_t;\n\nstddef.h\nsrc/gcc/ginclude/stddef.h\nmalloc\nsize_t\nsizeof",
            "size_t\nsize_t\nptrdiff_t\nsize_t\nptrdiff_t\nintptr_t\nuintptr_t\nsize_t\nptrdiff_t\nfar\nintptr_t\nsize_t\nptrdiff_t\nlong\nlong\nlong\nint\nint\nlong\nint\nlong\nint\nlong long int",
            "size_t\nsizeof\nptrdiff_t",
            "size_t\nint\nsize_t\nsizeof(void*)\nint\nsize_t\nssize_t\nint\nsize_t\nssize_t\nmmap()",
            "size_t\nsizeof\nconst\nsize_t\nconst\nconst size_t number;\n\nsize_t\n32-bit\nunsigned int\n64-bit\nunsigned long long int\nsize_t\nsize_t\n&lt;stdio.h&gt;\n&lt;stddef.h&gt;\n&lt;stdlib.h&gt;\n&lt;string.h&gt;\n&lt;time.h&gt;\n&lt;wchar.h&gt;\nconst\n#include &lt;stdio.h&gt;\n\nint main()\n{\n    const size_t value = 200;\n    size_t i;\n    int arr[value];\n\n    for (i = 0 ; i &lt; value ; ++i)\n    {\n        arr[i] = i;\n    }\n\n    size_t size = sizeof(arr);\n    printf(&quot;size = %zu\\n&quot;, size);\n}\n\nsize = 800\nconst\n#include &lt;stdio.h&gt;\n\nint main()\n{\n    size_t value = 200;\n    size_t i;\n    int arr[value];\n\n    for (i = 0; i &lt; value; ++i)\n    {\n        arr[i] = i;\n    }\n\n    size_t size = sizeof(arr);\n    printf(&quot;size = %zu\\n&quot;, size);\n}\n\nsize = 800",
            "size_t\nstddef.h\ntypedef unsigned long long size_t;\n\nsize_t\n&lt;stdio.h&gt;\nsize_t\nsize_t\n#include &lt;stdio.h&gt;\n\nvoid disp_ary(int *ary, size_t ary_size)\n{\n    for (int i = 0; i &lt; ary_size; i++)\n    {\n        printf(&quot;%d &quot;, ary[i]);\n    }\n}\n \nint main(void)\n{\n    int arr[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 0};\n    int ary_size = sizeof(arr)/sizeof(int);\n    disp_ary(arr, ary_size);\n    return 0;\n}\n\nsize_t\nld\nstack-size\nmalloc\nmemcpy\nstrlen\nsize_t\nsize_t\nsize_t\nconst char* reverse(char *orig)\n{\n  size_t len = strlen(orig);\n  char *rev = orig + len - 1;\n  while (rev &gt;= orig)\n  {\n    printf(&quot;%c&quot;, *rev);\n    rev = rev - 1;  // &lt;= See below\n  }\n  return rev;\n}\n\nint main() {\n  char *string = &quot;123&quot;;\n  printf(&quot;%c&quot;, reverse(string));\n}\n// Output: 321\n\n0x7ff626939004 &quot;123&quot;  // &lt;= orig\n0x7ff626939006 &quot;3&quot;    // &lt;= rev - 1 of 3\n0x7ff626939005 &quot;23&quot;   // &lt;= rev - 2 of 3\n0x7ff626939004 &quot;123&quot;  // &lt;= rev - 3 of 3\n0x7ff6aade9003 &quot;&quot;     // &lt;= rev is indeterminant. This can be exploited as an out of bounds bug to read memory contents that this program has no business reading.\n\nsize_t\nsize_t\nsize_t\nvoid print_reverse(int *orig, size_t ary_size)\n{\n  int *rev = orig + ary_size - 1;\n  while (rev &gt;= orig)\n  {\n    printf(&quot;%i&quot;, *rev);\n    rev = rev - 1;\n  }\n}\n\nint main()\n{\n  int nums[] = {1, 2, 3};\n  print_reverse(nums, sizeof(nums)/sizeof(*nums));\n\n  return 0;\n}\n\n0x617d3ffb44 1  // &lt;= orig\n0x617d3ffb4c 3  // &lt;= rev - 1 of 3\n0x617d3ffb48 2  // &lt;= rev - 2 of 3\n0x617d3ffb44 1  // &lt;= rev - 3 of 3\n\nt_size\nsize_t",
            "typedef\nunsigned int\nunsigned long",
            "// C program to demonstrate that size_t or\n// any unsigned int type should be used \n// carefully when used in a loop\n\n#include&lt;stdio.h&gt;\nint main()\n{\nconst size_t N = 10;\nint a[N];\n\n// This is fine\nfor (size_t n = 0; n &lt; N; ++n)\na[n] = n;\n\n// But reverse cycles are tricky for unsigned \n// types as can lead to infinite loop\nfor (size_t n = N-1; n &gt;= 0; --n)\nprintf(\"%d \", a[n]);\n}\n\nOutput\nInfinite loop and then segmentation fault\n",
            "size_t\nunsigned\nsizeof(size_t) &gt;= sizeof(void*)\n"
        ]
    },
    {
        "question_id": 612097,
        "question_code": "ls",
        "answer_code_snippets": [
            "std::filesystem\n#include &lt;string&gt;\n#include &lt;iostream&gt;\n#include &lt;filesystem&gt;\nnamespace fs = std::filesystem;\n\nint main()\n{\n    std::string path = &quot;/path/to/directory&quot;;\n    for (const auto &amp; entry : fs::directory_iterator(path))\n        std::cout &lt;&lt; entry.path() &lt;&lt; std::endl;\n}\n\ndirent.h\nDIR *dir;\nstruct dirent *ent;\nif ((dir = opendir (&quot;c:\\\\src\\\\&quot;)) != NULL) {\n  /* print all the files and directories within directory */\n  while ((ent = readdir (dir)) != NULL) {\n    printf (&quot;%s\\n&quot;, ent-&gt;d_name);\n  }\n  closedir (dir);\n} else {\n  /* could not open directory */\n  perror (&quot;&quot;);\n  return EXIT_FAILURE;\n}\n",
            "std::filesystem::directory_iterator\n#include &lt;string&gt;\n#include &lt;iostream&gt;\n#include &lt;filesystem&gt;\nnamespace fs = std::filesystem;\n \nint main() {\n  std::string path = &quot;/path/to/directory&quot;;\n\n  for (const auto &amp; entry : fs::directory_iterator(path)) {\n    std::cout &lt;&lt; entry.path() &lt;&lt; std::endl;\n  }\n}\n\nstd::filesystem::recursive_directory_iterator",
            "bool find_file(const path &amp; dir_path,         // in this directory,\n               const std::string &amp; file_name, // search for this name,\n               path &amp; path_found)             // placing path here if found\n{\n    if (!exists(dir_path)) \n        return false;\n\n    directory_iterator end_itr; // default construction yields past-the-end\n\n    for (directory_iterator itr(dir_path); itr != end_itr; ++itr)\n    {\n        if (is_directory(itr-&gt;status()))\n        {\n            if (find_file(itr-&gt;path(), file_name, path_found)) \n                return true;\n        }\n        else if (itr-&gt;leaf() == file_name) // see below\n        {\n            path_found = itr-&gt;path();\n            return true;\n        }\n    }\n    return false;\n}\n\nlen = strlen(name);\ndirp = opendir(\".\");\nwhile ((dp = readdir(dirp)) != NULL)\n        if (dp-&gt;d_namlen == len &amp;&amp; !strcmp(dp-&gt;d_name, name)) {\n                (void)closedir(dirp);\n                return FOUND;\n        }\n(void)closedir(dirp);\nreturn NOT_FOUND;\n\n#include &lt;windows.h&gt;\n#include &lt;tchar.h&gt;\n#include &lt;stdio.h&gt;\n\nvoid _tmain(int argc, TCHAR *argv[])\n{\n   WIN32_FIND_DATA FindFileData;\n   HANDLE hFind;\n\n   if( argc != 2 )\n   {\n      _tprintf(TEXT(\"Usage: %s [target_file]\\n\"), argv[0]);\n      return;\n   }\n\n   _tprintf (TEXT(\"Target file is %s\\n\"), argv[1]);\n   hFind = FindFirstFile(argv[1], &amp;FindFileData);\n   if (hFind == INVALID_HANDLE_VALUE) \n   {\n      printf (\"FindFirstFile failed (%d)\\n\", GetLastError());\n      return;\n   } \n   else \n   {\n      _tprintf (TEXT(\"The first file found is %s\\n\"), \n                FindFileData.cFileName);\n      FindClose(hFind);\n   }\n}\n",
            "#include &lt;Windows.h&gt;\n\nvector&lt;string&gt; get_all_files_names_within_folder(string folder)\n{\n    vector&lt;string&gt; names;\n    string search_path = folder + \"/*.*\";\n    WIN32_FIND_DATA fd; \n    HANDLE hFind = ::FindFirstFile(search_path.c_str(), &amp;fd); \n    if(hFind != INVALID_HANDLE_VALUE) { \n        do { \n            // read all (real) files in current folder\n            // , delete '!' read other 2 default folder . and ..\n            if(! (fd.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY) ) {\n                names.push_back(fd.cFileName);\n            }\n        }while(::FindNextFile(hFind, &amp;fd)); \n        ::FindClose(hFind); \n    } \n    return names;\n}\n\n*.*\n*.ext",
            "tinydir_dir dir;\ntinydir_open(&amp;dir, \"/path/to/dir\");\n\nwhile (dir.has_next)\n{\n    tinydir_file file;\n    tinydir_readfile(&amp;dir, &amp;file);\n\n    printf(\"%s\", file.name);\n    if (file.is_dir)\n    {\n        printf(\"/\");\n    }\n    printf(\"\\n\");\n\n    tinydir_next(&amp;dir);\n}\n\ntinydir_close(&amp;dir);\n\nreaddir_r\nUNICODE",
            "glob\nvector&lt;string&gt;\n#include &lt;glob.h&gt;\n#include &lt;vector&gt;\nusing std::vector;\n\nvector&lt;string&gt; globVector(const string&amp; pattern){\n    glob_t glob_result;\n    glob(pattern.c_str(),GLOB_TILDE,NULL,&amp;glob_result);\n    vector&lt;string&gt; files;\n    for(unsigned int i=0;i&lt;glob_result.gl_pathc;++i){\n        files.push_back(string(glob_result.gl_pathv[i]));\n    }\n    globfree(&amp;glob_result);\n    return files;\n}\n\nvector&lt;string&gt; files = globVector(\"./*\");\n",
            "#include &lt;stdio.h&gt;\n#include &lt;dirent.h&gt;\n#include &lt;sys/types.h&gt;\n\nint main(int argc, char** argv) { \n    list_dir(&quot;myFolderName&quot;);\n    return EXIT_SUCCESS;\n}  \n\nstatic void list_dir(const char *path) {\n    struct dirent *entry;\n    DIR *dir = opendir(path);\n    if (dir == NULL) {\n        return;\n    }\n\n    while ((entry = readdir(dir)) != NULL) {\n        printf(&quot;%s\\n&quot;,entry-&gt;d_name);\n    }\n\n    closedir(dir);\n}\n\ndirent.h\nstruct dirent {\n    ino_t d_ino; /* inode number */\n    off_t d_off; /* offset to the next dirent */\n    unsigned short d_reclen; /* length of this record */\n    unsigned char d_type; /* type of file */\n    char d_name[256]; /* filename */\n};\n",
            "glob()\n#include &lt;glob.h&gt;\n\nglob_t glob_result;\nglob(\"/your_directory/*\",GLOB_TILDE,NULL,&amp;glob_result);\nfor(unsigned int i=0; i&lt;glob_result.gl_pathc; ++i){\n  cout &lt;&lt; glob_result.gl_pathv[i] &lt;&lt; endl;\n}\n",
            "C++11\nboost::filesystem\n#include &lt;string&gt;\n#include &lt;iostream&gt;\n#include &lt;boost/filesystem.hpp&gt;\nusing namespace std;\nusing namespace boost::filesystem;\n\nint main()\n{\n    path p(\"D:/AnyFolder\");\n    for (auto i = directory_iterator(p); i != directory_iterator(); i++)\n    {\n        if (!is_directory(i-&gt;path())) //we eliminate directories\n        {\n            cout &lt;&lt; i-&gt;path().filename().string() &lt;&lt; endl;\n        }\n        else\n            continue;\n    }\n}\n\nfile1.txt\nfile2.dat\n",
            "foldername\ngetNextFile\nfilename\nwindows.h\nstdio.h\nclass FileGetter{\n    WIN32_FIND_DATAA found; \n    HANDLE hfind;\n    char folderstar[255];       \n    int chk;\n\npublic:\n    FileGetter(char* folder){       \n        sprintf(folderstar,\"%s\\\\*.*\",folder);\n        hfind = FindFirstFileA(folderstar,&amp;found);\n        //skip .\n        FindNextFileA(hfind,&amp;found);        \n    }\n\n    int getNextFile(char* fname){\n        //skips .. when called for the first time\n        chk=FindNextFileA(hfind,&amp;found);\n        if (chk)\n            strcpy(fname, found.cFileName);     \n        return chk;\n    }\n\n};\n",
            "namespace fs = experimental::filesystem;\n#include &lt;string&gt;\n#include &lt;iostream&gt;\n#include &lt;filesystem&gt;\n\nusing namespace std;\nnamespace fs = experimental::filesystem;\n\nint main()\n{\n    string path = \"C:\\\\splits\\\\\";\n    for (auto &amp; p : fs::directory_iterator(path))\n        cout &lt;&lt; p &lt;&lt; endl;\n    int n;\n    cin &gt;&gt; n;\n}\n",
            "#include &lt;string&gt;\n#include &lt;iostream&gt;\n#include &lt;filesystem&gt;\nnamespace fs = std::filesystem;\n\nint main() {\n    std::string path = &quot;/path/to/directory&quot;;\n    for (const auto &amp; entry : fs::directory_iterator(path))\n        std::cout &lt;&lt; entry.path() &lt;&lt; std::endl;\n}\n",
            "char **getKeys(char *data_dir, char* tablename, int *num_keys)\n{\n    char** arr = malloc(MAX_RECORDS_PER_TABLE*sizeof(char*));\nint i = 0;\nfor (;i &lt; MAX_RECORDS_PER_TABLE; i++)\n    arr[i] = malloc( (MAX_KEY_LEN+1) * sizeof(char) );  \n\n\nchar *buf = (char *)malloc( (MAX_KEY_LEN+1)*sizeof(char) );\nsnprintf(buf, MAX_KEY_LEN+1, \"%s/%s\", data_dir, tablename);\n\nDIR* tableDir = opendir(buf);\nstruct dirent* getInfo;\n\nreaddir(tableDir); // ignore '.'\nreaddir(tableDir); // ignore '..'\n\ni = 0;\nwhile(1)\n{\n\n\n    getInfo = readdir(tableDir);\n    if (getInfo == 0)\n        break;\n    strcpy(arr[i++], getInfo-&gt;d_name);\n}\n*(num_keys) = i;\nreturn arr;\n}\n",
            "#include &lt;windows.h&gt;\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nstring wchar_t2string(const wchar_t *wchar)\n{\n    string str = \"\";\n    int index = 0;\n    while(wchar[index] != 0)\n    {\n        str += (char)wchar[index];\n        ++index;\n    }\n    return str;\n}\n\nwchar_t *string2wchar_t(const string &amp;str)\n{\n    wchar_t wchar[260];\n    int index = 0;\n    while(index &lt; str.size())\n    {\n        wchar[index] = (wchar_t)str[index];\n        ++index;\n    }\n    wchar[index] = 0;\n    return wchar;\n}\n\nvector&lt;string&gt; listFilesInDirectory(string directoryName)\n{\n    WIN32_FIND_DATA FindFileData;\n    wchar_t * FileName = string2wchar_t(directoryName);\n    HANDLE hFind = FindFirstFile(FileName, &amp;FindFileData);\n\n    vector&lt;string&gt; listFileNames;\n    listFileNames.push_back(wchar_t2string(FindFileData.cFileName));\n\n    while (FindNextFile(hFind, &amp;FindFileData))\n        listFileNames.push_back(wchar_t2string(FindFileData.cFileName));\n\n    return listFileNames;\n}\n\nvoid main()\n{\n    vector&lt;string&gt; listFiles;\n    listFiles = listFilesInDirectory(\"C:\\\\*.txt\");\n    for each (string str in listFiles)\n        cout &lt;&lt; str &lt;&lt; endl;\n}\n",
            "int exploreDirectory(const char *dirpath, char ***list, int *numItems) {\n    struct dirent **direntList;\n    int i;\n    errno = 0;\n\n    if ((*numItems = scandir(dirpath, &amp;direntList, NULL, alphasort)) == -1)\n        return errno;\n\n    if (!((*list) = malloc(sizeof(char *) * (*numItems)))) {\n        fprintf(stderr, \"Error in list allocation for file list: dirpath=%s.\\n\", dirpath);\n        exit(EXIT_FAILURE);\n    }\n\n    for (i = 0; i &lt; *numItems; i++) {\n        (*list)[i] = stringDuplication(direntList[i]-&gt;d_name);\n    }\n\n    for (i = 0; i &lt; *numItems; i++) {\n        free(direntList[i]);\n    }\n\n    free(direntList);\n\n    return 0;\n}\n",
            "#include &lt;string&gt;\n#include &lt;iostream&gt;\n#include &lt;filesystem&gt;\n\nusing namespace std;\nnamespace fs = filesystem;\nint main()\n{\n    string path = &quot;\\\\path\\\\to\\\\directory&quot;;\n    // string path = &quot;/path/to/directory&quot;;\n    for (auto &amp; p : fs::recursive_directory_iterator(path))\n        cout &lt;&lt; p.path() &lt;&lt; endl;\n}\n\ncl /EHsc /W4 /WX /std:c++17 ListFiles.cpp",
            "system( \"dir /b /s /a-d * &gt; file_names.txt\" );\n",
            "#include &lt;ftw.h&gt;\n\nint AnalizeDirectoryElement (const char *fpath, \n                            const struct stat *sb,\n                            int tflag, \n                            struct FTW *ftwbuf) {\n\n  if (tflag == FTW_F) {\n    std::string strFileName(fpath);\n\n    DoSomethingWith(strFileName);\n  }\n  return 0; \n}\n\nvoid WalkDirectoryTree (const char * pchFileName) {\n\n  int nFlags = 0;\n\n  if (nftw(pchFileName, AnalizeDirectoryElement, 20, nFlags) == -1) {\n    perror(\"nftw\");\n  }\n}\n\nint main() {\n  WalkDirectoryTree(\"some_dir/\");\n}\n",
            "#include &lt;iostream&gt;\n#include &lt;filesystem&gt;\n#include &lt;string&gt;\n#include &lt;direct.h&gt;\nusing namespace std;\nnamespace fs = std::experimental::filesystem;\nvoid ShowListFile(string path)\n{\nfor(auto &amp;p: fs::directory_iterator(path))  /*get directory */\n     cout&lt;&lt;p.path().filename()&lt;&lt;endl;   // get file name\n}\n\nint main() {\n\nShowListFile(\"C:/Users/dell/Pictures/Camera Roll/\");\ngetchar();\nreturn 0;\n}\n",
            "void filefinder()\nmain\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include \"dirent.h\"\n\nstring path = \"C:/folder\"; //Put a valid path here for folder\n\nvoid filefinder()\n{\n    DIR *directory = opendir(path.c_str());\n    struct dirent *direntStruct;\n\n    if (directory != NULL) {\n        while (direntStruct = readdir(directory)) {\n            printf(\"File Name: %s\\n\", direntStruct-&gt;d_name); //If you are using &lt;stdio.h&gt;\n            //std::cout &lt;&lt; direntStruct-&gt;d_name &lt;&lt; std::endl; //If you are using &lt;iostream&gt;\n        }\n    }\n    closedir(directory);\n}\n",
            "std::filesystem::directory_entry\n&lt;&lt;\nstd::cout &lt;&lt; p &lt;&lt; std::endl;\n#include &lt;iostream&gt;\n#include &lt;filesystem&gt;\n#include &lt;string&gt;\nnamespace fs = std::filesystem;\n\nint main() {\n    std::string path = \"/path/to/directory\";\n    for(const auto&amp; p : fs::directory_iterator(path))\n        std::cout &lt;&lt; p.path() &lt;&lt; std::endl;\n}\n\np\nstd::cout &lt;&lt;",
            "#include &lt;algorithm&gt;\n#include &lt;filesystem&gt;\n#include &lt;ranges&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main() {\n    vector&lt;filesystem::path&gt; filePaths;\n    ranges::transform(filesystem::directory_iterator(&quot;.&quot;),     \n    back_inserter(filePaths), [](const auto&amp; dirFile){return dirFile.path();} );\n}\n",
            "#include&lt;io.h&gt;\n#include&lt;iostream.h&gt;\n#include&lt;string&gt;\nusing namespace std;\n\nvoid TraverseFilesUsingDFS(const string&amp; folder_path){\n   _finddata_t file_info;\n   string any_file_pattern = folder_path + \"\\\\*\";\n   intptr_t handle = _findfirst(any_file_pattern.c_str(),&amp;file_info);\n   //If folder_path exsist, using any_file_pattern will find at least two files \".\" and \"..\", \n   //of which \".\" means current dir and \"..\" means parent dir\n   if (handle == -1){\n       cerr &lt;&lt; \"folder path not exist: \" &lt;&lt; folder_path &lt;&lt; endl;\n       exit(-1);\n   }\n   //iteratively check each file or sub_directory in current folder\n   do{\n       string file_name=file_info.name; //from char array to string\n       //check whtether it is a sub direcotry or a file\n       if (file_info.attrib &amp; _A_SUBDIR){\n            if (file_name != \".\" &amp;&amp; file_name != \"..\"){\n               string sub_folder_path = folder_path + \"\\\\\" + file_name;                \n               TraverseFilesUsingDFS(sub_folder_path);\n               cout &lt;&lt; \"a sub_folder path: \" &lt;&lt; sub_folder_path &lt;&lt; endl;\n            }\n       }\n       else\n            cout &lt;&lt; \"file name: \" &lt;&lt; file_name &lt;&lt; endl;\n    } while (_findnext(handle, &amp;file_info) == 0);\n    //\n    _findclose(handle);\n}\n",
            "#include &lt;string&gt;\n#include &lt;Windows.h&gt;\n#include &lt;vector&gt;\n#include &lt;locale&gt;\n#include &lt;codecvt&gt;\n\nstd::vector&lt;std::string&gt; listFilesInDir(std::string path)\n{\n    std::vector&lt;std::string&gt; names;\n    //Convert string to wstring\n    std::wstring search_path = std::wstring_convert&lt;std::codecvt_utf8&lt;wchar_t&gt;&gt;().from_bytes(path);\n    WIN32_FIND_DATA fd;\n    HANDLE hFind = FindFirstFile(search_path.c_str(), &amp;fd);\n    if (hFind != INVALID_HANDLE_VALUE) \n    {\n        do \n        {\n            // read all (real) files in current folder\n            // , delete '!' read other 2 default folder . and ..\n            if (!(fd.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY)) \n            {\n                //convert from wide char to narrow char array\n                char ch[260];\n                char DefChar = ' ';\n                WideCharToMultiByte(CP_ACP, 0, fd.cFileName, -1, ch, 260, &amp;DefChar, NULL);\n                names.push_back(ch);\n            }\n        } \n        while (::FindNextFile(hFind, &amp;fd));\n        ::FindClose(hFind);\n    }\n    return names;\n}\n",
            "#include &lt;vector&gt;\n#include &lt;string&gt;\n#include &lt;algorithm&gt;\n\n#ifdef _WIN32\n#include &lt;windows.h&gt;\nstd::vector&lt;std::string&gt; files_in_directory(std::string path)\n{\n    std::vector&lt;std::string&gt; files;\n\n    // check directory exists\n    char fullpath[MAX_PATH];\n    GetFullPathName(path.c_str(), MAX_PATH, fullpath, 0);\n    std::string fp(fullpath);\n    if (GetFileAttributes(fp.c_str()) != FILE_ATTRIBUTE_DIRECTORY)\n        return files;\n\n    // get file names\n    WIN32_FIND_DATA findfiledata;\n    HANDLE hFind = FindFirstFile((LPCSTR)(fp + &quot;\\\\*&quot;).c_str(), &amp;findfiledata);\n    if (hFind != INVALID_HANDLE_VALUE)\n    {\n        do \n        {\n            files.push_back(findfiledata.cFileName);\n        } \n        while (FindNextFile(hFind, &amp;findfiledata));\n        FindClose(hFind);\n    }\n\n    // delete current and parent directories\n    files.erase(std::find(files.begin(), files.end(), &quot;.&quot;));\n    files.erase(std::find(files.begin(), files.end(), &quot;..&quot;));\n\n    // sort in alphabetical order\n    std::sort(files.begin(), files.end());\n\n    return files;\n}\n#else\n#include &lt;dirent.h&gt;\nstd::vector&lt;std::string&gt; files_in_directory(std::string directory)\n{\n    std::vector&lt;std::string&gt; files;\n\n    // open directory\n    DIR *dir;\n    dir = opendir(directory.c_str());\n    if (dir == NULL)\n        return files;\n\n    // get file names\n    struct dirent *ent;\n    while ((ent = readdir(dir)) != NULL)\n        files.push_back(ent-&gt;d_name);\n    closedir(dir);\n\n    // delete current and parent directories\n    files.erase(std::find(files.begin(), files.end(), &quot;.&quot;));\n    files.erase(std::find(files.begin(), files.end(), &quot;..&quot;));\n\n    // sort in alphabetical order\n    std::sort(files.begin(), files.end());\n\n    return files;\n}\n#endif  // _WIN32\n",
            "#include &lt;bits/stdc++.h&gt;\n#include &lt;dirent.h&gt;\nusing namespace std;\n\nint main(){\n    DIR *dpdf;\n    struct dirent *epdf;\n    dpdf = opendir(&quot;./&quot;);\n    \n    if (dpdf != NULL){\n    while (epdf = readdir(dpdf)){\n        cout &lt;&lt; epdf-&gt;d_name &lt;&lt; std::endl;\n    }\n    }\n    closedir(dpdf);\n    return 0;\n}\n",
            "#include &lt;stdio.h&gt;\n#include &lt;sys/stat.h&gt;\n#include &lt;iostream&gt;\n#include &lt;dirent.h&gt;\n#include &lt;map&gt;\n\nstd::map&lt;int, std::string&gt; getFile(std::string p, std::string e = \"\", unsigned char s = '/'){\n    if ( p.size() &gt; 0 ){\n        if (p.back() != s) p += s;\n    }\n    if ( e.size() &gt; 0 ){\n        if ( e.at(0) != '.' &amp;&amp; !(e.size() == 1 &amp;&amp; e.at(0) == '*') ) e = \".\" + e;\n    }\n\n    DIR *dir;\n    struct dirent *ent;\n    struct stat sb;\n    std::map&lt;int, std::string&gt; r = {{999, \"FAILED\"}};\n    std::string temp;\n    int f = 0;\n    bool fd;\n\n    if ( (dir = opendir(p.c_str())) != NULL ){\n        r.erase (999);\n        while ((ent = readdir (dir)) != NULL){\n            temp = ent-&gt;d_name;\n            fd = temp.find(\".\") != std::string::npos? true : false;\n            temp = p + temp;\n\n            if (stat(temp.c_str(), &amp;sb) == 0 &amp;&amp; S_ISREG(sb.st_mode)){\n                if ( e.size() == 1 &amp;&amp; e.at(0) == '*' ){\n                    r[f] = temp;\n                    f++;\n                } else {\n                    if (e.size() == 0){\n                        if ( fd == false ){\n                            r[f] = temp;\n                            f++;\n                        }\n                        continue;\n                    }\n\n                    if (e.size() &gt; temp.size()) continue;\n\n                    if ( temp.substr(temp.size() - e.size()) == e ){\n                        r[f] = temp;\n                        f++;\n                    }\n                }\n            }\n        }\n\n        closedir(dir);\n        return r;\n    } else {\n        return r;\n    }\n}\n\nvoid printMap(auto &amp;m){\n    for (const auto &amp;p : m) {\n        std::cout &lt;&lt; \"m[\" &lt;&lt; p.first &lt;&lt; \"] = \" &lt;&lt; p.second &lt;&lt; std::endl;\n    }\n}\n\nint main(){\n    std::map&lt;int, std::string&gt; k = getFile(\"./\", \"\");\n    printMap(k);\n    return 0;\n}\n",
            "#include&lt;iostream&gt;\n#include &lt;dirent.h&gt;\nusing namespace std;\nchar ROOT[]={'.'};\n\nvoid listfiles(char* path){\n    DIR * dirp = opendir(path);\n    dirent * dp;\n    while ( (dp = readdir(dirp)) !=NULL ) {\n         cout &lt;&lt; dp-&gt;d_name &lt;&lt; \" size \" &lt;&lt; dp-&gt;d_reclen&lt;&lt;std::endl;\n    }\n    (void)closedir(dirp);\n}\n\nint main(int argc, char **argv)\n{\n    char* path;\n    if (argc&gt;1) path=argv[1]; else path=ROOT;\n\n    cout&lt;&lt;\"list files in [\"&lt;&lt;path&lt;&lt;\"]\"&lt;&lt;std::endl;\n    listfiles(path);\n\n    return 0;\n}\n"
        ]
    },
    {
        "question_id": 63166,
        "question_code": "",
        "answer_code_snippets": [
            "#include &quot;windows.h&quot;\n\nMEMORYSTATUSEX memInfo;\nmemInfo.dwLength = sizeof(MEMORYSTATUSEX);\nGlobalMemoryStatusEx(&amp;memInfo);\nDWORDLONG totalVirtualMem = memInfo.ullTotalPageFile;\n\n DWORDLONG virtualMemUsed = memInfo.ullTotalPageFile - memInfo.ullAvailPageFile;\n\n#include &quot;windows.h&quot;\n#include &quot;psapi.h&quot;\n\nPROCESS_MEMORY_COUNTERS_EX pmc;\nGetProcessMemoryInfo(GetCurrentProcess(), (PROCESS_MEMORY_COUNTERS*)&amp;pmc, sizeof(pmc));\nSIZE_T virtualMemUsedByMe = pmc.PrivateUsage;\n\nDWORDLONG totalPhysMem = memInfo.ullTotalPhys;\n\nDWORDLONG physMemUsed = memInfo.ullTotalPhys - memInfo.ullAvailPhys;\n\nSIZE_T physMemUsedByMe = pmc.WorkingSetSize;\n\n#include &quot;TCHAR.h&quot;\n#include &quot;pdh.h&quot;\n\nstatic PDH_HQUERY cpuQuery;\nstatic PDH_HCOUNTER cpuTotal;\n\nvoid init(){\n    PdhOpenQuery(NULL, NULL, &amp;cpuQuery);\n    // You can also use L&quot;\\\\Processor(*)\\\\% Processor Time&quot; and get individual CPU values with PdhGetFormattedCounterArray()\n    PdhAddEnglishCounter(cpuQuery, L&quot;\\\\Processor(_Total)\\\\% Processor Time&quot;, NULL, &amp;cpuTotal);\n    PdhCollectQueryData(cpuQuery);\n}\n\ndouble getCurrentValue(){\n    PDH_FMT_COUNTERVALUE counterVal;\n\n    PdhCollectQueryData(cpuQuery);\n    PdhGetFormattedCounterValue(cpuTotal, PDH_FMT_DOUBLE, NULL, &amp;counterVal);\n    return counterVal.doubleValue;\n}\n\n#include &quot;windows.h&quot;\n\nstatic ULARGE_INTEGER lastCPU, lastSysCPU, lastUserCPU;\nstatic int numProcessors;\nstatic HANDLE self;\n\nvoid init(){\n    SYSTEM_INFO sysInfo;\n    FILETIME ftime, fsys, fuser;\n\n    GetSystemInfo(&amp;sysInfo);\n    numProcessors = sysInfo.dwNumberOfProcessors;\n\n    GetSystemTimeAsFileTime(&amp;ftime);\n    memcpy(&amp;lastCPU, &amp;ftime, sizeof(FILETIME));\n\n    self = GetCurrentProcess();\n    GetProcessTimes(self, &amp;ftime, &amp;ftime, &amp;fsys, &amp;fuser);\n    memcpy(&amp;lastSysCPU, &amp;fsys, sizeof(FILETIME));\n    memcpy(&amp;lastUserCPU, &amp;fuser, sizeof(FILETIME));\n}\n\ndouble getCurrentValue(){\n    FILETIME ftime, fsys, fuser;\n    ULARGE_INTEGER now, sys, user;\n    double percent;\n\n    GetSystemTimeAsFileTime(&amp;ftime);\n    memcpy(&amp;now, &amp;ftime, sizeof(FILETIME));\n\n    GetProcessTimes(self, &amp;ftime, &amp;ftime, &amp;fsys, &amp;fuser);\n    memcpy(&amp;sys, &amp;fsys, sizeof(FILETIME));\n    memcpy(&amp;user, &amp;fuser, sizeof(FILETIME));\n    percent = (sys.QuadPart - lastSysCPU.QuadPart) +\n        (user.QuadPart - lastUserCPU.QuadPart);\n    percent /= (now.QuadPart - lastCPU.QuadPart);\n    percent /= numProcessors;\n    lastCPU = now;\n    lastUserCPU = user;\n    lastSysCPU = sys;\n\n    return percent * 100;\n}\n\ngetrusage()\n/proc\n#include &quot;sys/types.h&quot;\n#include &quot;sys/sysinfo.h&quot;\n\nstruct sysinfo memInfo;\n\nsysinfo (&amp;memInfo);\nlong long totalVirtualMem = memInfo.totalram;\n//Add other values in next statement to avoid int overflow on right hand side...\ntotalVirtualMem += memInfo.totalswap;\ntotalVirtualMem *= memInfo.mem_unit;\n\nlong long virtualMemUsed = memInfo.totalram - memInfo.freeram;\n//Add other values in next statement to avoid int overflow on right hand side...\nvirtualMemUsed += memInfo.totalswap - memInfo.freeswap;\nvirtualMemUsed *= memInfo.mem_unit;\n\n#include &quot;stdlib.h&quot;\n#include &quot;stdio.h&quot;\n#include &quot;string.h&quot;\n\nint parseLine(char* line){\n    // This assumes that a digit will be found and the line ends in &quot; Kb&quot;.\n    int i = strlen(line);\n    const char* p = line;\n    while (*p &lt;'0' || *p &gt; '9') p++;\n    line[i-3] = '\\0';\n    i = atoi(p);\n    return i;\n}\n\nint getValue(){ //Note: this value is in KB!\n    FILE* file = fopen(&quot;/proc/self/status&quot;, &quot;r&quot;);\n    int result = -1;\n    char line[128];\n\n    while (fgets(line, 128, file) != NULL){\n        if (strncmp(line, &quot;VmSize:&quot;, 7) == 0){\n            result = parseLine(line);\n            break;\n        }\n    }\n    fclose(file);\n    return result;\n}\n\nlong long totalPhysMem = memInfo.totalram;\n//Multiply in next statement to avoid int overflow on right hand side...\ntotalPhysMem *= memInfo.mem_unit;\n\nlong long physMemUsed = memInfo.totalram - memInfo.freeram;\n//Multiply in next statement to avoid int overflow on right hand side...\nphysMemUsed *= memInfo.mem_unit;\n\nint getValue(){ //Note: this value is in KB!\n    FILE* file = fopen(&quot;/proc/self/status&quot;, &quot;r&quot;);\n    int result = -1;\n    char line[128];\n\n    while (fgets(line, 128, file) != NULL){\n        if (strncmp(line, &quot;VmRSS:&quot;, 6) == 0){\n            result = parseLine(line);\n            break;\n        }\n    }\n    fclose(file);\n    return result;\n}\n\n#include &quot;stdlib.h&quot;\n#include &quot;stdio.h&quot;\n#include &quot;string.h&quot;\n\nstatic unsigned long long lastTotalUser, lastTotalUserLow, lastTotalSys, lastTotalIdle;\n\nvoid init(){\n    FILE* file = fopen(&quot;/proc/stat&quot;, &quot;r&quot;);\n    fscanf(file, &quot;cpu %llu %llu %llu %llu&quot;, &amp;lastTotalUser, &amp;lastTotalUserLow,\n        &amp;lastTotalSys, &amp;lastTotalIdle);\n    fclose(file);\n}\n\ndouble getCurrentValue(){\n    double percent;\n    FILE* file;\n    unsigned long long totalUser, totalUserLow, totalSys, totalIdle, total;\n\n    file = fopen(&quot;/proc/stat&quot;, &quot;r&quot;);\n    fscanf(file, &quot;cpu %llu %llu %llu %llu&quot;, &amp;totalUser, &amp;totalUserLow,\n        &amp;totalSys, &amp;totalIdle);\n    fclose(file);\n\n    if (totalUser &lt; lastTotalUser || totalUserLow &lt; lastTotalUserLow ||\n        totalSys &lt; lastTotalSys || totalIdle &lt; lastTotalIdle){\n        //Overflow detection. Just skip this value.\n        percent = -1.0;\n    }\n    else{\n        total = (totalUser - lastTotalUser) + (totalUserLow - lastTotalUserLow) +\n            (totalSys - lastTotalSys);\n        percent = total;\n        total += (totalIdle - lastTotalIdle);\n        percent /= total;\n        percent *= 100;\n    }\n\n    lastTotalUser = totalUser;\n    lastTotalUserLow = totalUserLow;\n    lastTotalSys = totalSys;\n    lastTotalIdle = totalIdle;\n\n    return percent;\n}\n\n#include &quot;stdlib.h&quot;\n#include &quot;stdio.h&quot;\n#include &quot;string.h&quot;\n#include &quot;sys/times.h&quot;\n#include &quot;sys/vtimes.h&quot;\n\nstatic clock_t lastCPU, lastSysCPU, lastUserCPU;\nstatic int numProcessors;\n\nvoid init(){\n    FILE* file;\n    struct tms timeSample;\n    char line[128];\n\n    lastCPU = times(&amp;timeSample);\n    lastSysCPU = timeSample.tms_stime;\n    lastUserCPU = timeSample.tms_utime;\n\n    file = fopen(&quot;/proc/cpuinfo&quot;, &quot;r&quot;);\n    numProcessors = 0;\n    while(fgets(line, 128, file) != NULL){\n        if (strncmp(line, &quot;processor&quot;, 9) == 0) numProcessors++;\n    }\n    fclose(file);\n}\n\ndouble getCurrentValue(){\n    struct tms timeSample;\n    clock_t now;\n    double percent;\n\n    now = times(&amp;timeSample);\n    if (now &lt;= lastCPU || timeSample.tms_stime &lt; lastSysCPU ||\n        timeSample.tms_utime &lt; lastUserCPU){\n        //Overflow detection. Just skip this value.\n        percent = -1.0;\n    }\n    else{\n        percent = (timeSample.tms_stime - lastSysCPU) +\n            (timeSample.tms_utime - lastUserCPU);\n        percent /= (now - lastCPU);\n        percent /= numProcessors;\n        percent *= 100;\n    }\n    lastCPU = now;\n    lastSysCPU = timeSample.tms_stime;\n    lastUserCPU = timeSample.tms_utime;\n\n    return percent;\n}\n\ngetrusage()",
            "struct statfs stats;\nif (0 == statfs(&quot;/&quot;, &amp;stats))\n{\n    myFreeSwap = (uint64_t)stats.f_bsize * stats.f_bfree;\n}\n\nsysctl -n vm.swapusage\nvm.swapusage: total = 3072.00M  used = 2511.78M  free = 560.22M  (encrypted)\n\nxsw_usage vmusage = {0};\nsize_t size = sizeof(vmusage);\nif( sysctlbyname(&quot;vm.swapusage&quot;, &amp;vmusage, &amp;size, NULL, 0)!=0 )\n{\n   perror( &quot;unable to get swap usage by calling sysctlbyname(\\&quot;vm.swapusage\\&quot;,...)&quot; );\n}\n\ntask_info\n#include&lt;mach/mach.h&gt;\n\nstruct task_basic_info t_info;\nmach_msg_type_number_t t_info_count = TASK_BASIC_INFO_COUNT;\n\nif (KERN_SUCCESS != task_info(mach_task_self(),\n                              TASK_BASIC_INFO, (task_info_t)&amp;t_info,\n                              &amp;t_info_count))\n{\n    return -1;\n}\n// resident size is in t_info.resident_size;\n// virtual size is in t_info.virtual_size;\n\nsysctl\n#include &lt;sys/types.h&gt;\n#include &lt;sys/sysctl.h&gt;\n...\nint mib[2];\nint64_t physical_memory;\nmib[0] = CTL_HW;\nmib[1] = HW_MEMSIZE;\nlength = sizeof(int64_t);\nsysctl(mib, 2, &amp;physical_memory, &amp;length, NULL, 0);\n\nhost_statistics\n#include &lt;mach/vm_statistics.h&gt;\n#include &lt;mach/mach_types.h&gt;\n#include &lt;mach/mach_init.h&gt;\n#include &lt;mach/mach_host.h&gt;\n\nint main(int argc, const char * argv[]) {\n    vm_size_t page_size;\n    mach_port_t mach_port;\n    mach_msg_type_number_t count;\n    vm_statistics64_data_t vm_stats;\n\n    mach_port = mach_host_self();\n    count = sizeof(vm_stats) / sizeof(natural_t);\n    if (KERN_SUCCESS == host_page_size(mach_port, &amp;page_size) &amp;&amp;\n        KERN_SUCCESS == host_statistics64(mach_port, HOST_VM_INFO,\n                                        (host_info64_t)&amp;vm_stats, &amp;count))\n    {\n        long long free_memory = (int64_t)vm_stats.free_count * (int64_t)page_size;\n\n        long long used_memory = ((int64_t)vm_stats.active_count +\n                                 (int64_t)vm_stats.inactive_count +\n                                 (int64_t)vm_stats.wire_count) *  (int64_t)page_size;\n        printf(&quot;free memory: %lld\\nused memory: %lld\\n&quot;, free_memory, used_memory);\n    }\n\n    return 0;\n}\n",
            "Anderson cxc # more /proc/meminfo\nMemTotal:      4083948 kB\nMemFree:       2198520 kB\nBuffers:         82080 kB\nCached:        1141460 kB\nSwapCached:          0 kB\nActive:        1137960 kB\nInactive:       608588 kB\nHighTotal:     3276672 kB\nHighFree:      1607744 kB\nLowTotal:       807276 kB\nLowFree:        590776 kB\nSwapTotal:     2096440 kB\nSwapFree:      2096440 kB\nDirty:              32 kB\nWriteback:           0 kB\nAnonPages:      523252 kB\nMapped:          93560 kB\nSlab:            52880 kB\nSReclaimable:    24652 kB\nSUnreclaim:      28228 kB\nPageTables:       2284 kB\nNFS_Unstable:        0 kB\nBounce:              0 kB\nCommitLimit:   4138412 kB\nCommitted_AS:  1845072 kB\nVmallocTotal:   118776 kB\nVmallocUsed:      3964 kB\nVmallocChunk:   112860 kB\nHugePages_Total:     0\nHugePages_Free:      0\nHugePages_Rsvd:      0\nHugepagesize:     2048 kB\n\nAnderson cxc #  more /proc/stat\ncpu  2329889 0 2364567 1063530460 9034 9463 96111 0\ncpu0 572526 0 636532 265864398 2928 1621 6899 0\ncpu1 590441 0 531079 265949732 4763 351 8522 0\ncpu2 562983 0 645163 265796890 682 7490 71650 0\ncpu3 603938 0 551790 265919440 660 0 9040 0\nintr 37124247\nctxt 50795173133\nbtime 1218807985\nprocesses 116889\nprocs_running 1\nprocs_blocked 0\n\ncpu  2330047 0 2365006 1063853632 9035 9463 96114 0\n\ncpu  2330047 0 2365007 1063854028 9035 9463 96114 0\n\n19340 (whatever) S 19115 19115 3084 34816 19115 4202752 118200 607 0 0 770 384 2\n 7 20 0 77 0 266764385 692477952 105074 4294967295 134512640 146462952 321468364\n8 3214683328 4294960144 0 2147221247 268439552 1276 4294967295 0 0 17 0 0 0 0\n\nName:   whatever\nState:  S (sleeping)\nTgid:   19340\nPid:    19340\nPPid:   19115\nTracerPid:      0\nUid:    0       0       0       0\nGid:    0       0       0       0\nFDSize: 256\nGroups: 0 1 2 3 4 6 10 11 20 26 27\nVmPeak:   676252 kB\nVmSize:   651352 kB\nVmLck:         0 kB\nVmHWM:    420300 kB\nVmRSS:    420296 kB\nVmData:   581028 kB\nVmStk:       112 kB\nVmExe:     11672 kB\nVmLib:     76608 kB\nVmPTE:      1244 kB\nThreads:        77\nSigQ:   0/36864\nSigPnd: 0000000000000000\nShdPnd: 0000000000000000\nSigBlk: fffffffe7ffbfeff\nSigIgn: 0000000010001000\nSigCgt: 20000001800004fc\nCapInh: 0000000000000000\nCapPrm: 00000000ffffffff\nCapEff: 00000000fffffeff\nCpus_allowed:   0f\nMems_allowed:   1\nvoluntary_ctxt_switches:        6518\nnonvoluntary_ctxt_switches:     6598\n",
            "sysinfo\n   #include &lt;sys/sysinfo.h&gt;\n\n   int sysinfo(struct sysinfo *info);\n\n   Until Linux 2.3.16, sysinfo() used to return information in the\n   following structure:\n\n       struct sysinfo {\n           long uptime;             /* Seconds since boot */\n           unsigned long loads[3];  /* 1, 5, and 15 minute load averages */\n           unsigned long totalram;  /* Total usable main memory size */\n           unsigned long freeram;   /* Available memory size */\n           unsigned long sharedram; /* Amount of shared memory */\n           unsigned long bufferram; /* Memory used by buffers */\n           unsigned long totalswap; /* Total swap space size */\n           unsigned long freeswap;  /* swap space still available */\n           unsigned short procs;    /* Number of current processes */\n           char _f[22];             /* Pads structure to 64 bytes */\n       };\n\n   and the sizes were given in bytes.\n\n   Since Linux 2.3.23 (i386), 2.3.48 (all architectures) the structure\n   is:\n\n       struct sysinfo {\n           long uptime;             /* Seconds since boot */\n           unsigned long loads[3];  /* 1, 5, and 15 minute load averages */\n           unsigned long totalram;  /* Total usable main memory size */\n           unsigned long freeram;   /* Available memory size */\n           unsigned long sharedram; /* Amount of shared memory */\n           unsigned long bufferram; /* Memory used by buffers */\n           unsigned long totalswap; /* Total swap space size */\n           unsigned long freeswap;  /* swap space still available */\n           unsigned short procs;    /* Number of current processes */\n           unsigned long totalhigh; /* Total high memory size */\n           unsigned long freehigh;  /* Available high memory size */\n           unsigned int mem_unit;   /* Memory unit size in bytes */\n           char _f[20-2*sizeof(long)-sizeof(int)]; /* Padding to 64 bytes */\n       };\n\n   and the sizes are given as multiples of mem_unit bytes.\n",
            "#include &lt;windows.h&gt;\n#include &lt;stdio.h&gt;\n\n//------------------------------------------------------------------------------------------------------------------\n// Prototype(s)...\n//------------------------------------------------------------------------------------------------------------------\nCHAR cpuusage(void);\n\n//-----------------------------------------------------\ntypedef BOOL ( __stdcall * pfnGetSystemTimes)( LPFILETIME lpIdleTime, LPFILETIME lpKernelTime, LPFILETIME lpUserTime );\nstatic pfnGetSystemTimes s_pfnGetSystemTimes = NULL;\n\nstatic HMODULE s_hKernel = NULL;\n//-----------------------------------------------------\nvoid GetSystemTimesAddress()\n{\n    if(s_hKernel == NULL)\n    {\n        s_hKernel = LoadLibrary(L&quot;Kernel32.dll&quot;);\n        if(s_hKernel != NULL)\n        {\n            s_pfnGetSystemTimes = (pfnGetSystemTimes)GetProcAddress(s_hKernel, &quot;GetSystemTimes&quot;);\n            if(s_pfnGetSystemTimes == NULL)\n            {\n                FreeLibrary(s_hKernel);\n                s_hKernel = NULL;\n            }\n        }\n    }\n}\n//----------------------------------------------------------------------------------------------------------------\n\n//----------------------------------------------------------------------------------------------------------------\n// cpuusage(void)\n// ==============\n// Return a CHAR value in the range 0 - 100 representing actual CPU usage in percent.\n//----------------------------------------------------------------------------------------------------------------\nCHAR cpuusage()\n{\n    FILETIME               ft_sys_idle;\n    FILETIME               ft_sys_kernel;\n    FILETIME               ft_sys_user;\n\n    ULARGE_INTEGER         ul_sys_idle;\n    ULARGE_INTEGER         ul_sys_kernel;\n    ULARGE_INTEGER         ul_sys_user;\n\n    static ULARGE_INTEGER     ul_sys_idle_old;\n    static ULARGE_INTEGER  ul_sys_kernel_old;\n    static ULARGE_INTEGER  ul_sys_user_old;\n\n    CHAR usage = 0;\n\n    // We cannot directly use GetSystemTimes in the C language\n    /* Add this line :: pfnGetSystemTimes */\n    s_pfnGetSystemTimes(&amp;ft_sys_idle,    /* System idle time */\n        &amp;ft_sys_kernel,  /* system kernel time */\n        &amp;ft_sys_user);   /* System user time */\n\n    CopyMemory(&amp;ul_sys_idle  , &amp;ft_sys_idle  , sizeof(FILETIME)); // Could been optimized away...\n    CopyMemory(&amp;ul_sys_kernel, &amp;ft_sys_kernel, sizeof(FILETIME)); // Could been optimized away...\n    CopyMemory(&amp;ul_sys_user  , &amp;ft_sys_user  , sizeof(FILETIME)); // Could been optimized away...\n\n    usage  =\n        (\n        (\n        (\n        (\n        (ul_sys_kernel.QuadPart - ul_sys_kernel_old.QuadPart)+\n        (ul_sys_user.QuadPart   - ul_sys_user_old.QuadPart)\n        )\n        -\n        (ul_sys_idle.QuadPart-ul_sys_idle_old.QuadPart)\n        )\n        *\n        (100)\n        )\n        /\n        (\n        (ul_sys_kernel.QuadPart - ul_sys_kernel_old.QuadPart)+\n        (ul_sys_user.QuadPart   - ul_sys_user_old.QuadPart)\n        )\n        );\n\n    ul_sys_idle_old.QuadPart   = ul_sys_idle.QuadPart;\n    ul_sys_user_old.QuadPart   = ul_sys_user.QuadPart;\n    ul_sys_kernel_old.QuadPart = ul_sys_kernel.QuadPart;\n\n    return usage;\n}\n\n\n//------------------------------------------------------------------------------------------------------------------\n// Entry point\n//------------------------------------------------------------------------------------------------------------------\nint main(void)\n{\n    int n;\n    GetSystemTimesAddress();\n    for(n=0; n&lt;20; n++)\n    {\n        printf(&quot;CPU Usage: %3d%%\\r&quot;, cpuusage());\n        Sleep(2000);\n    }\n    printf(&quot;\\n&quot;);\n    return 0;\n}\n",
            "#include &lt;mach/mach_init.h&gt;\n#include &lt;mach/mach_error.h&gt;\n#include &lt;mach/mach_host.h&gt;\n#include &lt;mach/vm_map.h&gt;\n\nstatic unsigned long long _previousTotalTicks = 0;\nstatic unsigned long long _previousIdleTicks = 0;\n\n// Returns 1.0f for &quot;CPU fully pinned&quot;, 0.0f for &quot;CPU idle&quot;, or somewhere in between\n// You'll need to call this at regular intervals, since it measures the load between\n// the previous call and the current one.\nfloat GetCPULoad()\n{\n   host_cpu_load_info_data_t cpuinfo;\n   mach_msg_type_number_t count = HOST_CPU_LOAD_INFO_COUNT;\n   if (host_statistics(mach_host_self(), HOST_CPU_LOAD_INFO, (host_info_t)&amp;cpuinfo, &amp;count) == KERN_SUCCESS)\n   {\n      unsigned long long totalTicks = 0;\n      for(int i=0; i&lt;CPU_STATE_MAX; i++) totalTicks += cpuinfo.cpu_ticks[i];\n      return CalculateCPULoad(cpuinfo.cpu_ticks[CPU_STATE_IDLE], totalTicks);\n   }\n   else return -1.0f;\n}\n\nfloat CalculateCPULoad(unsigned long long idleTicks, unsigned long long totalTicks)\n{\n  unsigned long long totalTicksSinceLastTime = totalTicks-_previousTotalTicks;\n  unsigned long long idleTicksSinceLastTime  = idleTicks-_previousIdleTicks;\n  float ret = 1.0f-((totalTicksSinceLastTime &gt; 0) ? ((float)idleTicksSinceLastTime)/totalTicksSinceLastTime : 0);\n  _previousTotalTicks = totalTicks;\n  _previousIdleTicks  = idleTicks;\n  return ret;\n}\n",
            "#include &lt;atomic.h&gt;\n#include &lt;libc.h&gt;\n#include &lt;pthread.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#include &lt;sys/iofunc.h&gt;\n#include &lt;sys/neutrino.h&gt;\n#include &lt;sys/resmgr.h&gt;\n#include &lt;sys/syspage.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;inttypes.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;sys/types.h&gt;\n#include &lt;sys/debug.h&gt;\n#include &lt;sys/procfs.h&gt;\n#include &lt;sys/syspage.h&gt;\n#include &lt;sys/neutrino.h&gt;\n#include &lt;sys/time.h&gt;\n#include &lt;time.h&gt;\n#include &lt;fcntl.h&gt;\n#include &lt;devctl.h&gt;\n#include &lt;errno.h&gt;\n\n#define MAX_CPUS 32\n\nstatic float Loads[MAX_CPUS];\nstatic _uint64 LastSutime[MAX_CPUS];\nstatic _uint64 LastNsec[MAX_CPUS];\nstatic int ProcFd = -1;\nstatic int NumCpus = 0;\n\n\nint find_ncpus(void) {\n    return NumCpus;\n}\n\nint get_cpu(int cpu) {\n    int ret;\n    ret = (int)Loads[ cpu % MAX_CPUS ];\n    ret = max(0,ret);\n    ret = min(100,ret);\n    return( ret );\n}\n\nstatic _uint64 nanoseconds( void ) {\n    _uint64 sec, usec;\n    struct timeval tval;\n    gettimeofday( &amp;tval, NULL );\n    sec = tval.tv_sec;\n    usec = tval.tv_usec;\n    return( ( ( sec * 1000000 ) + usec ) * 1000 );\n}\n\nint sample_cpus( void ) {\n    int i;\n    debug_thread_t debug_data;\n    _uint64 current_nsec, sutime_delta, time_delta;\n    memset( &amp;debug_data, 0, sizeof( debug_data ) );\n    \n    for( i=0; i&lt;NumCpus; i++ ) {\n        /* Get the sutime of the idle thread #i+1 */\n        debug_data.tid = i + 1;\n        devctl( ProcFd, DCMD_PROC_TIDSTATUS,\n        &amp;debug_data, sizeof( debug_data ), NULL );\n        /* Get the current time */\n        current_nsec = nanoseconds();\n        /* Get the deltas between now and the last samples */\n        sutime_delta = debug_data.sutime - LastSutime[i];\n        time_delta = current_nsec - LastNsec[i];\n        /* Figure out the load */\n        Loads[i] = 100.0 - ( (float)( sutime_delta * 100 ) / (float)time_delta );\n        /* Flat out strange rounding issues. */\n        if( Loads[i] &lt; 0 ) {\n            Loads[i] = 0;\n        }\n        /* Keep these for reference in the next cycle */\n        LastNsec[i] = current_nsec;\n        LastSutime[i] = debug_data.sutime;\n    }\n    return EOK;\n}\n\nint init_cpu( void ) {\n    int i;\n    debug_thread_t debug_data;\n    memset( &amp;debug_data, 0, sizeof( debug_data ) );\n/* Open a connection to proc to talk over.*/\n    ProcFd = open( &quot;/proc/1/as&quot;, O_RDONLY );\n    if( ProcFd == -1 ) {\n        fprintf( stderr, &quot;pload: Unable to access procnto: %s\\n&quot;,strerror( errno ) );\n        fflush( stderr );\n        return -1;\n    }\n    i = fcntl(ProcFd,F_GETFD);\n    if(i != -1){\n        i |= FD_CLOEXEC;\n        if(fcntl(ProcFd,F_SETFD,i) != -1){\n            /* Grab this value */\n            NumCpus = _syspage_ptr-&gt;num_cpu;\n            /* Get a starting point for the comparisons */\n            for( i=0; i&lt;NumCpus; i++ ) {\n                /*\n                * the sutime of idle thread is how much\n                * time that thread has been using, we can compare this\n                * against how much time has passed to get an idea of the\n                * load on the system.\n                */\n                debug_data.tid = i + 1;\n                devctl( ProcFd, DCMD_PROC_TIDSTATUS, &amp;debug_data, sizeof( debug_data ), NULL );\n                LastSutime[i] = debug_data.sutime;\n                LastNsec[i] = nanoseconds();\n            }\n            return(EOK);\n        }\n    }\n    close(ProcFd);\n    return(-1);\n}\n\nvoid close_cpu(void){\n    if(ProcFd != -1){\n        close(ProcFd);\n        ProcFd = -1;\n    }\n}\n\nint main(int argc, char* argv[]){\n    int i,j;\n    init_cpu();\n    printf(&quot;System has: %d CPUs\\n&quot;, NumCpus);\n    for(i=0; i&lt;20; i++) {\n        sample_cpus();\n        for(j=0; j&lt;NumCpus;j++)\n        printf(&quot;CPU #%d: %f\\n&quot;, j, Loads[j]);\n        sleep(1);\n    }\n    close_cpu();\n}\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;errno.h&gt;\n#include &lt;err.h&gt;\n#include &lt;sys/stat.h&gt;\n#include &lt;sys/types.h&gt;\n\nint main( int argc, char *argv[] ){\n    struct stat statbuf;\n    paddr_t freemem;\n    stat( &quot;/proc&quot;, &amp;statbuf );\n    freemem = (paddr_t)statbuf.st_size;\n    printf( &quot;Free memory: %d bytes\\n&quot;, freemem );\n    printf( &quot;Free memory: %d KB\\n&quot;, freemem / 1024 );\n    printf( &quot;Free memory: %d MB\\n&quot;, freemem / ( 1024 * 1024 ) );\n    return 0;\n} \n",
            "/proc/[pid]/statm\n\n    Provides information about memory usage, measured in pages.\n    The columns are:\n\n        size       (1) total program size\n                   (same as VmSize in /proc/[pid]/status)\n        resident   (2) resident set size\n                   (same as VmRSS in /proc/[pid]/status)\n        shared     (3) number of resident shared pages (i.e., backed by a file)\n                   (same as RssFile+RssShmem in /proc/[pid]/status)\n        text       (4) text (code)\n        lib        (5) library (unused since Linux 2.6; always 0)\n        data       (6) data + stack\n        dt         (7) dirty pages (unused since Linux 2.6; always 0)\n",
            "static HANDLE self;\nstatic int numProcessors;\nSYSTEM_INFO sysInfo;\n\ndouble percent;\n\nnumProcessors = sysInfo.dwNumberOfProcessors;\n\n//Getting system times information\nFILETIME SysidleTime;\nFILETIME SyskernelTime; \nFILETIME SysuserTime; \nULARGE_INTEGER SyskernelTimeInt, SysuserTimeInt;\nGetSystemTimes(&amp;SysidleTime, &amp;SyskernelTime, &amp;SysuserTime);\nmemcpy(&amp;SyskernelTimeInt, &amp;SyskernelTime, sizeof(FILETIME));\nmemcpy(&amp;SysuserTimeInt, &amp;SysuserTime, sizeof(FILETIME));\n__int64 denomenator = SysuserTimeInt.QuadPart + SyskernelTimeInt.QuadPart;  \n\n//Getting process times information\nFILETIME ProccreationTime, ProcexitTime, ProcKernelTime, ProcUserTime;\nULARGE_INTEGER ProccreationTimeInt, ProcexitTimeInt, ProcKernelTimeInt, ProcUserTimeInt;\nGetProcessTimes(self, &amp;ProccreationTime, &amp;ProcexitTime, &amp;ProcKernelTime, &amp;ProcUserTime);\nmemcpy(&amp;ProcKernelTimeInt, &amp;ProcKernelTime, sizeof(FILETIME));\nmemcpy(&amp;ProcUserTimeInt, &amp;ProcUserTime, sizeof(FILETIME));\n__int64 numerator = ProcUserTimeInt.QuadPart + ProcKernelTimeInt.QuadPart;\n//QuadPart represents a 64-bit signed integer (ULARGE_INTEGER)\n\npercent = 100*(numerator/denomenator);\n"
        ]
    },
    {
        "question_id": 199333,
        "question_code": "unsigned long b, c, c_test;\n...\nc_test=c*b;         // Possible overflow\nif (c_test/b != c) {/* There has been an overflow*/}\nelse c=c_test;      // No overflow\n\nint",
        "answer_code_snippets": [
            "#include &lt;limits.h&gt;\n\nint a = &lt;something&gt;;\nint x = &lt;something&gt;;\na += x;              /* UB */\nif (a &lt; 0) {         /* Unreliable test */\n  /* ... */\n}\n\n// For addition\n#include &lt;limits.h&gt;\n\nint a = &lt;something&gt;;\nint x = &lt;something&gt;;\nif (x &gt; 0 &amp;&amp; a &gt; INT_MAX - x) // `a + x` would overflow\nif (x &lt; 0 &amp;&amp; a &lt; INT_MIN - x) // `a + x` would underflow\n\n// For subtraction\n#include &lt;limits.h&gt;\nint a = &lt;something&gt;;\nint x = &lt;something&gt;;\nif (x &lt; 0 &amp;&amp; a &gt; INT_MAX + x) // `a - x` would overflow\nif (x &gt; 0 &amp;&amp; a &lt; INT_MIN + x) // `a - x` would underflow\n\n// For multiplication\n#include &lt;limits.h&gt;\n\nint a = &lt;something&gt;;\nint x = &lt;something&gt;;\n// There may be a need to check for -1 for two's complement machines.\n// If one number is -1 and another is INT_MIN, multiplying them we get abs(INT_MIN) which is 1 higher than INT_MAX\nif (a == -1 &amp;&amp; x == INT_MIN) // `a * x` can overflow\nif (x == -1 &amp;&amp; a == INT_MIN) // `a * x` (or `a / x`) can overflow\n// general case\nif (x != 0 &amp;&amp; a &gt; INT_MAX / x) // `a * x` would overflow\nif (x != 0 &amp;&amp; a &lt; INT_MIN / x) // `a * x` would underflow\n\nINT_MIN\n-1\nINT_MIN\nINT_MAX",
            "&lt;stdckdint.h&gt;\nbool ckd_add(type1 *result, type2 a, type3 b);\nbool ckd_sub(type1 *result, type2 a, type3 b);\nbool ckd_mul(type1 *result, type2 a, type3 b);\n\ntype1\ntype2\ntype3\n*result\ntype1\ntrue\nunsigned long b, c, c_test;\n// ...\nif (ckd_mul(&amp;c_test, c, b))\n{\n    // returned non-zero: there has been an overflow\n}\nelse\n{\n    c = c_test; // returned 0: no overflow\n}\n\n__builtin_add_overflow\n__builtin_sub_overflow\n__builtin_mul_overflow\nint\nunsigned long b, c, c_test;\n// ...\nif (__builtin_mul_overflow(c, b, &amp;c_test))\n{\n    // returned non-zero: there has been an overflow\n}\nelse\n{\n    c = c_test; // returned 0: no overflow\n}\n\n__builtin_umull_overflow\n&lt;intrin.h&gt;\naddcarry_uNN\nsubborrow_uNN\naddcarry_u8\nsubborrow_u64\nunsigned char _addcarry_u32(unsigned char c_in, unsigned int src1, unsigned int src2, unsigned int *sum);\nunsigned char _subborrow_u32(unsigned char b_in, unsigned int src1, unsigned int src2, unsigned int *diff);\n\nc_in\nb_in",
            "bool addition_is_safe(uint32_t a, uint32_t b) {\n    size_t a_bits=highestOneBitPosition(a), b_bits=highestOneBitPosition(b);\n    return (a_bits&lt;32 &amp;&amp; b_bits&lt;32);\n}\n\nbool multiplication_is_safe(uint32_t a, uint32_t b) {\n    size_t a_bits=highestOneBitPosition(a), b_bits=highestOneBitPosition(b);\n    return (a_bits+b_bits&lt;=32);\n}\n\na\nb\nbool exponentiation_is_safe(uint32_t a, uint32_t b) {\n    size_t a_bits=highestOneBitPosition(a);\n    return (a_bits*b&lt;=32);\n}\n\nsize_t highestOneBitPosition(uint32_t a) {\n    size_t bits=0;\n    while (a!=0) {\n        ++bits;\n        a&gt;&gt;=1;\n    };\n    return bits;\n}\n\nhighestOneBitPosition",
            "if ( b &gt; ULONG_MAX / a ) // a * b would overflow\n",
            "-O2\n-Wall\nif (a + b &lt; a) { /* Deal with overflow */ }\n\nb = abs(a);\nif (b &lt; 0) { /* Deal with overflow */ }\n\n-fwrapv",
            "uint32_t x, y;\nuint32_t value = x + y;\nbool overflow = value &lt; (x | y);\n\nuint32_t x, y;\nuint32_t value = x + y;\nconst bool overflow = value &lt; x; // Alternatively &quot;value &lt; y&quot; should also work\n\nuint32_t x, y;\nconst uint32_t a = (x &gt;&gt; 16U) * (y &amp; 0xFFFFU);\nconst uint32_t b = (x &amp; 0xFFFFU) * (y &gt;&gt; 16U);\nconst bool overflow = ((x &gt;&gt; 16U) * (y &gt;&gt; 16U)) +\n    (a &gt;&gt; 16U) + (b &gt;&gt; 16U);\nuint32_t value = overflow ? UINT32_MAX : x * y;\n\nuint32_t x, y;\nconst bool overflow\n{\n    [](const uint32_t x, const uint32_t y) noexcept -&gt; bool\n    {\n        const uint32_t a{(x &gt;&gt; 16U) * uint16_t(y)};\n        const uint32_t b{uint16_t(x) * (y &gt;&gt; 16U)};\n        return ((x &gt;&gt; 16U) * (y &gt;&gt; 16U)) + (a &gt;&gt; 16U) + (b &gt;&gt; 16U);\n    }(x, y)\n};\nuint32_t value{overflow ? UINT32_MAX : x * y};\n",
            "    9938.08^2 == 98765432\n    462.241^3 == 98765432\n    99.6899^4 == 98765432\n    39.7119^5 == 98765432\n    21.4998^6 == 98765432\n    13.8703^7 == 98765432\n    9.98448^8 == 98765432\n    7.73196^9 == 98765432\n    6.30174^10 == 98765432\n    5.33068^11 == 98765432\n    4.63679^12 == 98765432\n    4.12069^13 == 98765432\n    3.72429^14 == 98765432\n    3.41172^15 == 98765432\n    3.15982^16 == 98765432\n    2.95305^17 == 98765432\n    2.78064^18 == 98765432\n    2.63493^19 == 98765432\n    2.51033^20 == 98765432\n    2.40268^21 == 98765432\n    2.30883^22 == 98765432\n    2.22634^23 == 98765432\n    2.15332^24 == 98765432\n    2.08826^25 == 98765432\n    2.02995^26 == 98765432\n    1.97741^27 == 98765432\n\n    ['0', '2', '4', '5', '6', '7', '8'] 84^2 = 7056\n    ['1', '2', '3', '4', '5', '8', '9'] 59^2 = 3481\n    ['0', '1', '2', '3', '4', '5', '8', '9'] 59^2 = 3481 (+leading zero)\n    ['1', '2', '3', '5', '8'] 8^3 = 512\n    ['0', '1', '2', '3', '5', '8'] 8^3 = 512 (+leading zero)\n    ['1', '2', '4', '6'] 4^2 = 16\n    ['0', '1', '2', '4', '6'] 4^2 = 16 (+leading zero)\n    ['1', '2', '4', '6'] 2^4 = 16\n    ['0', '1', '2', '4', '6'] 2^4 = 16 (+leading zero)\n    ['1', '2', '8', '9'] 9^2 = 81\n    ['0', '1', '2', '8', '9'] 9^2 = 81 (+leading zero)\n    ['1', '3', '4', '8'] 3^4 = 81\n    ['0', '1', '3', '4', '8'] 3^4 = 81 (+leading zero)\n    ['2', '3', '6', '7', '9'] 3^6 = 729\n    ['0', '2', '3', '6', '7', '9'] 3^6 = 729 (+leading zero)\n    ['2', '3', '8'] 2^3 = 8\n    ['0', '2', '3', '8'] 2^3 = 8 (+leading zero)\n    ['2', '3', '9'] 3^2 = 9\n    ['0', '2', '3', '9'] 3^2 = 9 (+leading zero)\n    ['2', '4', '6', '8'] 8^2 = 64\n    ['0', '2', '4', '6', '8'] 8^2 = 64 (+leading zero)\n    ['2', '4', '7', '9'] 7^2 = 49\n    ['0', '2', '4', '7', '9'] 7^2 = 49 (+leading zero)\n\n    import math\n\n    m = 98765432\n    l = []\n    for i in xrange(2, 98765432):\n        inv = 1.0/i\n        r = m**inv\n        if (r &lt; 2.0): break\n        top = int(math.floor(r))\n        assert(top &lt;= m)\n\n        for j in xrange(2, top+1):\n            s = str(i) + str(j) + str(j**i)\n            l.append((sorted(s), i, j, j**i))\n            assert(j**i &lt;= m)\n\n    l.sort()\n    for s, i, j, ji in l:\n        assert(ji &lt;= m)\n        ss = sorted(set(s))\n        if s == ss:\n            print '%s %d^%d = %d' % (s, i, j, ji)\n\n        # Try with non significant zero somewhere\n        s = ['0'] + s\n        ss = sorted(set(s))\n        if s == ss:\n            print '%s %d^%d = %d (+leading zero)' % (s, i, j, ji)\n",
            "#include &lt;cstddef&gt;\n#if defined( _MSC_VER )\n#include &lt;intrin.h&gt;\n#endif\n\ninline size_t query_intel_x86_eflags(const size_t query_bit_mask)\n{\n    #if defined( _MSC_VER )\n\n        return __readeflags() &amp; query_bit_mask;\n\n    #elif defined( __GNUC__ )\n        // This code will work only on 64-bit GNU-C machines.\n        // Tested and does NOT work with Intel C++ 10.1!\n        size_t eflags;\n        __asm__ __volatile__(\n            \"pushfq \\n\\t\"\n            \"pop %%rax\\n\\t\"\n            \"movq %%rax, %0\\n\\t\"\n            :\"=r\"(eflags)\n            :\n            :\"%rax\"\n            );\n        return eflags &amp; query_bit_mask;\n\n    #else\n\n        #pragma message(\"No inline assembly will work with this compiler!\")\n            return 0;\n    #endif\n}\n\nint main(int argc, char **argv)\n{\n    int x = 1000000000;\n    int y = 20000;\n    int z = x * y;\n    int f = query_intel_x86_eflags(0x801);\n    printf(\"%X\\n\", f);\n}\n\nquery_intel_eflags(0x801)",
            "uint8_t x, y;    /* Give these values */\nconst uint16_t data16    = x + y;\nconst bool carry        = (data16 &gt; 0xFF);\nconst bool overflow     = ((~(x ^ y)) &amp; (x ^ data16) &amp; 0x80);\n\n0xFF\n0xFFFFFFFF\n0x80\n0x80000000\nuint16_t\nuint64_t\ncalloc",
            "unsigned long\nunsigned long long\nFPE_INTOVF_TRAP\nSIGFPE\nFPE_INTOVF_TRAP",
            "-ftrapv\n-ftrapv",
            "unsigned int r, a, b;\nr = a + b;\nif (r &lt; a)\n{\n    // Overflow\n}\n\nsigned int r, a, b, s;\nr = a + b;\ns = a&gt;=0;\nif (s == (b&gt;=0) &amp;&amp; s != (r&gt;=0))\n{\n    // Overflow\n}\n",
            "CLANG ARITHMETIC UNDEFINED at &lt;add.c, (9:11)&gt; :\nOp: +, Reason : Signed Addition Overflow,\nBINARY OPERATION: left (int32): 2147483647 right (int32): 1\n",
            "format ELF64\n\nsection '.text' executable\n\npublic u_mul\n\nu_mul:\n  MOV eax, edi\n  mul esi\n  jnc u_mul_ret\n  xor eax, eax\nu_mul_ret:\nret\n\nextern \"C\" unsigned int u_mul(const unsigned int a, const unsigned int b);\n\nint main() {\n    printf(\"%u\\n\", u_mul(4000000000,2)); // 0\n    printf(\"%u\\n\", u_mul(UINT_MAX/2,2)); // OK\n    return 0;\n}\n\nLIBS",
            "#define overflowflag(isOverflow){   \\\nsize_t eflags;                      \\\nasm (\"pushfl ;\"                     \\\n     \"pop %%eax\"                    \\\n    : \"=a\" (eflags));               \\\nisOverflow = (eflags &gt;&gt; 11) &amp; 1;}\n\n#include &lt;cstddef&gt;\n#include &lt;stdio.h&gt;\n#include &lt;iostream&gt;\n#include &lt;conio.h&gt;\n#if defined( _MSC_VER )\n#include &lt;intrin.h&gt;\n#include &lt;oskit/x86&gt;\n#endif\n\nusing namespace std;\n\n#define detectOverflow(isOverflow){     \\\nsize_t eflags;                      \\\nasm (\"pushfl ;\"                     \\\n    \"pop %%eax\"                     \\\n    : \"=a\" (eflags));               \\\nisOverflow = (eflags &gt;&gt; 11) &amp; 1;}\n\nint main(int argc, char **argv) {\n\n    bool endTest = false;\n    bool isOverflow;\n\n    do {\n        cout &lt;&lt; \"Enter two intergers\" &lt;&lt; endl;\n        int x = 0;\n        int y = 0;\n        cin.clear();\n        cin &gt;&gt; x &gt;&gt; y;\n        int z = x * y;\n        detectOverflow(isOverflow)\n        printf(\"\\nThe result is: %d\", z);\n        if (!isOverflow) {\n            std::cout &lt;&lt; \": no overflow occured\\n\" &lt;&lt; std::endl;\n        } else {\n            std::cout &lt;&lt; \": overflow occured\\n\" &lt;&lt; std::endl;\n        }\n\n        z = x * x * y;\n        detectOverflow(isOverflow)\n        printf(\"\\nThe result is: %d\", z);\n        if (!isOverflow) {\n            std::cout &lt;&lt; \": no overflow ocurred\\n\" &lt;&lt; std::endl;\n        } else {\n            std::cout &lt;&lt; \": overflow occured\\n\" &lt;&lt; std::endl;\n        }\n\n        cout &lt;&lt; \"Do you want to stop? (Enter \\\"y\\\" or \\\"Y)\" &lt;&lt; endl;\n\n        char c = 0;\n\n        do {\n            c = getchar();\n        } while ((c == '\\n') &amp;&amp; (c != EOF));\n\n        if (c == 'y' || c == 'Y') {\n            endTest = true;\n        }\n\n        do {\n            c = getchar();\n        } while ((c != '\\n') &amp;&amp; (c != EOF));\n\n    } while (!endTest);\n}\n",
            "jo\ninfo as\ninfo gcc",
            "mozilla::CheckedInt&lt;T&gt;\nT\nIntegerTypeTraits.h\nAttributes.h\nCompiler.h",
            "unsigned long checked_imul(unsigned long a, unsigned long b) {\n  unsigned __int128 res = (unsigned __int128)a * b;\n  if ((unsigned long)(res &gt;&gt; 64))\n    printf(\"overflow in integer multiply\");\n  return (unsigned long)res;\n}\n",
            "addition_is_safe\nbool addition_is_safe(unsigned int a, unsigned int b)\n{\n    unsigned int L_Mask = std::numeric_limits&lt;unsigned int&gt;::max();\n    L_Mask &gt;&gt;= 1;\n    L_Mask = ~L_Mask;\n\n    a &amp;= L_Mask;\n    b &amp;= L_Mask;\n\n    return ( a == 0 || b == 0 );\n}\n",
            "uint64_t foo(uint64_t a, uint64_t b) {\n    double dc;\n\n    dc = pow(a, b);\n\n    if (dc &lt; UINT_MAX) {\n       return (powu64(a, b));\n    }\n    else {\n      // Overflow\n    }\n}\n",
            "DWORD\nMy Addition(DWORD Value_A, DWORD Value_B)\n{\n    ULARGE_INTEGER a, b;\n\n    b.LowPart = Value_A;  // A 32 bit value(up to 32 bit)\n    b.HighPart = 0;\n    a.LowPart = Value_B;  // A 32 bit value(up to 32 bit)\n    a.HighPart = 0;\n\n    a.QuadPart += b.QuadPart;\n\n    // If  a.HighPart\n    // Then a.HighPart contains the overflow (carry)\n\n    return (a.LowPart + a.HighPart)\n\n    // Any overflow is stored in a.HighPart (up to 32 bits)\n",
            "... /* begin multiplication */\nunsigned multiplicand, multiplier, product, productHalf;\nint zeroesMultiplicand, zeroesMultiplier;\nzeroesMultiplicand = number_of_leading_zeroes( multiplicand );\nzeroesMultiplier   = number_of_leading_zeroes( multiplier );\nif( zeroesMultiplicand + zeroesMultiplier &lt;= 30 ) goto overflow;\nproductHalf = multiplicand * ( c &gt;&gt; 1 );\nif( (int)productHalf &lt; 0 ) goto overflow;\nproduct = productHalf * 2;\nif( multiplier &amp; 1 ){\n   product += multiplicand;\n   if( product &lt; multiplicand ) goto overflow;\n}\n..../* continue code here where \"product\" is the correct product */\n....\noverflow: /* put overflow handling code here */\n\nint number_of_leading_zeroes( unsigned value ){\n   int ctZeroes;\n   if( value == 0 ) return 32;\n   ctZeroes = 1;\n   if( ( value &gt;&gt; 16 ) == 0 ){ ctZeroes += 16; value = value &lt;&lt; 16; }\n   if( ( value &gt;&gt; 24 ) == 0 ){ ctZeroes +=  8; value = value &lt;&lt;  8; }\n   if( ( value &gt;&gt; 28 ) == 0 ){ ctZeroes +=  4; value = value &lt;&lt;  4; }\n   if( ( value &gt;&gt; 30 ) == 0 ){ ctZeroes +=  2; value = value &lt;&lt;  2; }\n   ctZeroes -= x &gt;&gt; 31;\n   return ctZeroes;\n}\n",
            "long lng;\nint n;\nfor (n = 0; n &lt; 34; ++n)\n{\n   lng = pow (2, n);\n   printf (\"%li\\n\", lng);\n}\n\nlong signed lng, lng_prev = 0;\nint n;\nfor (n = 0; n &lt; 34; ++n)\n{\n    lng = pow (2, n);\n    if (lng &lt;= lng_prev)\n    {\n        printf (\"Overflow: %i\\n\", n);\n        /* Do whatever you do in the event of overflow.  */\n    }\n    printf (\"%li\\n\", lng);\n    lng_prev = lng;\n}\n\n&lt;=\n&gt;=",
            "#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\n#define MAX 100 \n\nint mltovf(int a, int b)\n{\n    if (a &amp;&amp; b) return abs(a) &gt; MAX/abs(b);\n    else return 0;\n}\n\nmain()\n{\n    int a, b;\n\n    for (a = 0; a &lt;= MAX; a++)\n        for (b = 0; b &lt; MAX; b++) {\n\n        if (mltovf(a, b) != (a*b &gt; MAX)) \n            printf(\"Bad calculation: a: %d b: %d\\n\", a, b);\n\n    }\n}\n"
        ]
    },
    {
        "question_id": 19902828,
        "question_code": "ENT\nENOENT\nENOFILE",
        "answer_code_snippets": [
            "ENOFILE",
            "File: /usr/include/asm-generic/errno-base.h\n6: #define  ENOENT       2  /* No such file or directory */\n7: \n\nerrno 2\n\nENOENT 2 No such file or directory\n\n&quot;No such file or directory.&quot; This is a âfile doesnât existâ error for ordinary files that are referenced in contexts where they are\n"
        ]
    },
    {
        "question_id": 6964392,
        "question_code": "lorenzo@enzo:~/erlang$ gcc -lm -o euler12.bin euler12.c\nlorenzo@enzo:~/erlang$ time ./euler12.bin\n842161320\n\nreal    0m11.074s\nuser    0m11.070s\nsys 0m0.000s\n\nlorenzo@enzo:~/erlang$ time ./euler12.py \n842161320\n\nreal    1m16.632s\nuser    1m16.370s\nsys 0m0.250s\n\nlorenzo@enzo:~/Downloads/pypy-c-jit-43780-b590cf6de419-linux64/bin$ time ./pypy /home/lorenzo/erlang/euler12.py \n842161320\n\nreal    0m13.082s\nuser    0m13.050s\nsys 0m0.020s\n\nlorenzo@enzo:~/erlang$ erlc euler12.erl \nlorenzo@enzo:~/erlang$ time erl -s euler12 solve\nErlang R13B03 (erts-5.7.4) [source] [64-bit] [smp:4:4] [rq:4] [async-threads:0] [hipe] [kernel-poll:false]\n\nEshell V5.7.4  (abort with ^G)\n1&gt; 842161320\n\nreal    0m48.259s\nuser    0m48.070s\nsys 0m0.020s\n\nlorenzo@enzo:~/erlang$ ghc euler12.hs -o euler12.hsx\n[1 of 1] Compiling Main             ( euler12.hs, euler12.o )\nLinking euler12.hsx ...\nlorenzo@enzo:~/erlang$ time ./euler12.hsx \n842161320\n\nreal    2m37.326s\nuser    2m37.240s\nsys 0m0.080s\n\nMAXINT\n#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\n\nint factorCount (long n)\n{\n    double square = sqrt (n);\n    int isquare = (int) square;\n    int count = isquare == square ? -1 : 0;\n    long candidate;\n    for (candidate = 1; candidate &lt;= isquare; candidate ++)\n        if (0 == n % candidate) count += 2;\n    return count;\n}\n\nint main ()\n{\n    long triangle = 1;\n    int index = 1;\n    while (factorCount (triangle) &lt; 1001)\n    {\n        index ++;\n        triangle += index;\n    }\n    printf (&quot;%ld\\n&quot;, triangle);\n}\n\n#! /usr/bin/env python3.2\n\nimport math\n\ndef factorCount (n):\n    square = math.sqrt (n)\n    isquare = int (square)\n    count = -1 if isquare == square else 0\n    for candidate in range (1, isquare + 1):\n        if not n % candidate: count += 2\n    return count\n\ntriangle = 1\nindex = 1\nwhile factorCount (triangle) &lt; 1001:\n    index += 1\n    triangle += index\n\nprint (triangle)\n\n-module (euler12).\n-compile (export_all).\n\nfactorCount (Number) -&gt; factorCount (Number, math:sqrt (Number), 1, 0).\n\nfactorCount (_, Sqrt, Candidate, Count) when Candidate &gt; Sqrt -&gt; Count;\n\nfactorCount (_, Sqrt, Candidate, Count) when Candidate == Sqrt -&gt; Count + 1;\n\nfactorCount (Number, Sqrt, Candidate, Count) -&gt;\n    case Number rem Candidate of\n        0 -&gt; factorCount (Number, Sqrt, Candidate + 1, Count + 2);\n        _ -&gt; factorCount (Number, Sqrt, Candidate + 1, Count)\n    end.\n\nnextTriangle (Index, Triangle) -&gt;\n    Count = factorCount (Triangle),\n    if\n        Count &gt; 1000 -&gt; Triangle;\n        true -&gt; nextTriangle (Index + 1, Triangle + Index + 1)  \n    end.\n\nsolve () -&gt;\n    io:format (&quot;~p~n&quot;, [nextTriangle (1, 1) ] ),\n    halt (0).\n\nfactorCount number = factorCount' number isquare 1 0 - (fromEnum $ square == fromIntegral isquare)\n    where square = sqrt $ fromIntegral number\n          isquare = floor square\n\nfactorCount' number sqrt candidate count\n    | fromIntegral candidate &gt; sqrt = count\n    | number `mod` candidate == 0 = factorCount' number sqrt (candidate + 1) (count + 2)\n    | otherwise = factorCount' number sqrt (candidate + 1) count\n\nnextTriangle index triangle\n    | factorCount triangle &gt; 1000 = triangle\n    | otherwise = nextTriangle (index + 1) (triangle + index + 1)\n\nmain = print $ nextTriangle 1 1\n",
        "answer_code_snippets": [
            "GHC 7.0.3\ngcc 4.4.6\nLinux 2.6.29\nghc -O2 -fllvm -fforce-recomp\ngcc -O3 -lm\n-O3\n-O2\nfactorCount'\nInteger\nInt\nfactorCount'\nfromIntegral\nmod\nrem\nfactorCount'\nnumber\nsqrt\n $ time ./so\n 842161320  \n\n real    0m7.954s  \n user    0m7.944s  \n sys     0m0.004s  \n\n-fllvm\n8.182 seconds\nfactorCount number = factorCount' number isquare 1 0 - (fromEnum $ square == fromIntegral isquare)\n    where square = sqrt $ fromIntegral number\n          isquare = floor square\n\nfactorCount' :: Int -&gt; Int -&gt; Int -&gt; Int -&gt; Int\nfactorCount' number sqrt candidate0 count0 = go candidate0 count0\n  where\n  go candidate count\n    | candidate &gt; sqrt = count\n    | number `rem` candidate == 0 = go (candidate + 1) (count + 2)\n    | otherwise = go (candidate + 1) count\n\nnextTriangle index triangle\n    | factorCount triangle &gt; 1000 = triangle\n    | otherwise = nextTriangle (index + 1) (triangle + index + 1)\n\nmain = print $ nextTriangle 1 1\n\nInteger\nInt\nInt\nInt64\nWord64\nlong\n-O2\nrem\nmod",
            "+native\nexport_all\nerlc +native euler12\n-compile(export_all)\n-export([solve/0]).\nfactorCount (_, Sqrt, Candidate, Count) when Candidate == Sqrt -&gt; Count + 1;\n\nfactorCount (N) -&gt;\n    Sqrt = math:sqrt (N),\n    ISqrt = trunc(Sqrt),\n    if ISqrt == Sqrt -&gt; factorCount (N, ISqrt, 1, -1);\n       true          -&gt; factorCount (N, ISqrt, 1, 0)\n    end.\n\nfactorCount (_N, ISqrt, Candidate, Count) when Candidate &gt; ISqrt -&gt; Count;\nfactorCount ( N, ISqrt, Candidate, Count) -&gt;\n    case N rem Candidate of\n        0 -&gt; factorCount (N, ISqrt, Candidate + 1, Count + 2);\n        _ -&gt; factorCount (N, ISqrt, Candidate + 1, Count)\n    end.\n\nexport_all\n$ erlc +native euler12.erl\n$ time erl -noshell -s euler12 solve\n842161320\n\nreal    0m19.468s\nuser    0m19.450s\nsys 0m0.010s\n\n$ time ./a.out \n842161320\n\nreal    0m12.755s\nuser    0m12.730s\nsys 0m0.020s\n",
            "gcc -O3 -lm\n% time ./euler12-c \n842161320\n\n./euler12-c  11.95s \n user 0.00s \n system 99% \n cpu 11.959 total\n\n% time pypy euler12.py\n842161320\npypy euler12.py  \n16.44s user \n0.01s system \n99% cpu 16.449 total\n\nc2f583445aee\n% time ./euler12-rpython-c\n842161320\n./euler12-rpy-c  \n10.54s user 0.00s \nsystem 99% \ncpu 10.540 total\n\n% time python euler12-cython.py\n842161320\npython euler12-cython.py  \n6.27s user 0.00s \nsystem 99% \ncpu 6.274 total\n\ntarget\nmain\nsys.argv\n% translate.py euler12-rpython.py\n# euler12-rpython.py\n\nimport math, sys\n\ndef factorCount(n):\n    square = math.sqrt(n)\n    isquare = int(square)\n    count = -1 if isquare == square else 0\n    for candidate in xrange(1, isquare + 1):\n        if not n % candidate: count += 2\n    return count\n\ndef main(argv):\n    triangle = 1\n    index = 1\n    while factorCount(triangle) &lt; 1001:\n        index += 1\n        triangle += index\n    print triangle\n    return 0\n\nif __name__ == '__main__':\n    main(sys.argv)\n\ndef target(*args):\n    return main, None\n\n_euler12.pyx\n_euler12.pyx\npython setup.py build_ext --inplace\n# _euler12.pyx\nfrom libc.math cimport sqrt\n\ncdef int factorCount(int n):\n    cdef int candidate, isquare, count\n    cdef double square\n    square = sqrt(n)\n    isquare = int(square)\n    count = -1 if isquare == square else 0\n    for candidate in range(1, isquare + 1):\n        if not n % candidate: count += 2\n    return count\n\ncpdef main():\n    cdef int triangle = 1, index = 1\n    while factorCount(triangle) &lt; 1001:\n        index += 1\n        triangle += index\n    print triangle\n\n# euler12-cython.py\nimport _euler12\n_euler12.main()\n\n# setup.py\nfrom distutils.core import setup\nfrom distutils.extension import Extension\nfrom Cython.Distutils import build_ext\n\next_modules = [Extension(\"_euler12\", [\"_euler12.pyx\"])]\n\nsetup(\n  name = 'Euler12-Cython',\n  cmdclass = {'build_ext': build_ext},\n  ext_modules = ext_modules\n)\n",
            "#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\n\nstatic inline int factorCount(int n)\n{\n    double square = sqrt (n);\n    int isquare = (int)square;\n    int count = isquare == square ? -1 : 0;\n    int candidate;\n    for (candidate = 1; candidate &lt;= isquare; candidate ++)\n        if (0 == n % candidate) count += 2;\n    return count;\n}\n\nint main ()\n{\n    int triangle = 1;\n    int index = 1;\n    while (factorCount (triangle) &lt; 1001)\n    {\n        index++;\n        triangle += index;\n    }\n    printf (\"%d\\n\", triangle);\n}\n\n$ gcc -O3 -lm -o euler12 euler12.c; time ./euler12\n842161320\n./euler12  2.95s user 0.00s system 99% cpu 2.956 total\n\n$ ghc -O2 -fllvm -fforce-recomp euler12.hs; time ./euler12                                                                                      [9:40]\n[1 of 1] Compiling Main             ( euler12.hs, euler12.o )\nLinking euler12 ...\n842161320\n./euler12  9.43s user 0.13s system 99% cpu 9.602 total\n",
            "import Control.Applicative\nimport Control.Monad\nimport Data.Either\nimport Math.NumberTheory.Powers.Squares\n\nisInt :: RealFrac c =&gt; c -&gt; Bool\nisInt = (==) &lt;$&gt; id &lt;*&gt; fromInteger . round\n\nintSqrt :: (Integral a) =&gt; a -&gt; Int\n--intSqrt = fromIntegral . floor . sqrt . fromIntegral\nintSqrt = fromIntegral . integerSquareRoot'\n\nfactorize :: Int -&gt; [Int]\nfactorize 1 = []\nfactorize n = first : factorize (quot n first)\n  where first = (!! 0) $ [a | a &lt;- [2..intSqrt n], rem n a == 0] ++ [n]\n\nfactorize2 :: Int -&gt; [(Int,Int)]\nfactorize2 = foldl (\\ls@((val,freq):xs) y -&gt; if val == y then (val,freq+1):xs else (y,1):ls) [(0,0)] . factorize\n\nnumDivisors :: Int -&gt; Int\nnumDivisors = foldl (\\acc (_,y) -&gt; acc * (y+1)) 1 &lt;$&gt; factorize2\n\nnextTriangleNumber :: (Int,Int) -&gt; (Int,Int)\nnextTriangleNumber (n,acc) = (n+1,acc+n+1)\n\nforward :: Int -&gt; (Int, Int) -&gt; Either (Int, Int) (Int, Int)\nforward k val@(n,acc) = if numDivisors acc &gt; k then Left val else Right (nextTriangleNumber val)\n\nproblem12 :: Int -&gt; (Int, Int)\nproblem12 n = (!!0) . lefts . scanl (&gt;&gt;=) (forward n (1,1)) . repeat . forward $ n\n\nmain = do\n  let (n,val) = problem12 1000\n  print val\n\nghc -O3\nint factorCount (int n)\n{\n  int count = 1;\n  int candidate,tmpCount;\n  while (n % 2 == 0) {\n    count++;\n    n /= 2;\n  }\n    for (candidate = 3; candidate &lt; n &amp;&amp; candidate * candidate &lt; n; candidate += 2)\n    if (n % candidate == 0) {\n      tmpCount = 1;\n      do {\n        tmpCount++;\n        n /= candidate;\n      } while (n % candidate == 0);\n       count*=tmpCount;\n      }\n  if (n &gt; 1)\n    count *= 2;\n  return count;\n}\n\ngcc -O3 -lm\nint main ()\n{\n  int triangle = 0,count1,count2 = 1;\n  do {\n    count1 = count2;\n    count2 = ++triangle % 2 == 0 ? factorCount(triangle+1) : factorCount((triangle+1)/2);\n  } while (count1*count2 &lt; 1001);\n  printf (\"%lld\\n\", ((long long)triangle)*(triangle+1)/2);\n}\n",
            "import Data.Numbers.Primes\nimport Data.List\n\ntriangleNumbers = scanl1 (+) [1..]\nnDivisors n = product $ map ((+1) . length) (group (primeFactors n))\nanswer = head $ filter ((&gt; 500) . nDivisors) triangleNumbers\n\nmain :: IO ()\nmain = putStrLn $ \"First triangle number to have over 500 divisors: \" ++ (show answer)\n\nPS&gt; measure-command { bin\\012_slow.exe }\n\nTotalSeconds      : 16.3807409\nTotalMilliseconds : 16380.7409\n\nPS&gt; measure-command { bin\\012.exe }\n\nTotalSeconds      : 0.0383436\nTotalMilliseconds : 38.3436\n\nghc -O2 012.hs -o bin\\012.exe\nghc -O2 012_slow.hs -o bin\\012_slow.exe\n",
            "factorCount\nrange (1, isquare + 1)\nmalloc\nfactorCount()\nrange()\nrange\ndef factorial(n, acc=1):\n    if n &gt; 1:\n        acc = acc * n\n        n = n - 1\n        return factorial(n, acc)\n    else:\n        return acc\n\ndef factorial2(n):\n    if n &gt; 1:\n        f = factorial2(n-1)\n        return f*n\n    else:\n        return 1\n\ndef factorial(n, acc=1):\n    if n &gt; 1:\n        return factorial(n-1, acc*n)\n    else:\n        return acc\n\ndef factorial2(n):\n    if n &gt; 1:\n        return n*factorial(n-1)\n    else:\n        return 1\n\nacc\naccumulator",
            "factorCount number = foldr factorCount' 0 [1..isquare] -\n                     (fromEnum $ square == fromIntegral isquare)\n    where\n      square = sqrt $ fromIntegral number\n      isquare = floor square\n      factorCount' candidate\n        | number `rem` candidate == 0 = (2 +)\n        | otherwise = id\n\ntriangles :: [Int]\ntriangles = scanl1 (+) [1,2..]\n\nmain = print . head $ dropWhile ((&lt; 1001) . factorCount) triangles\n",
            "timer:tc/1 or timer:tc/2 or timer:tc/3",
            "compiling on VS x64 command prompt &gt; `for /f %f in ('dir /b *.c') do cl /O2 /Ot /Ox %f -o %f_x64_vs2012.exe`\ncompiling on cygwin with gcc x64   &gt; `for f in ./*.c; do gcc -m64 -O3 $f -o ${f}_x64_gcc.exe ; done`\ntime (unix tools) using cygwin &gt; `for f in ./*.exe; do  echo \"----------\"; echo $f ; time $f ; done`\n\n----------\n$ time python ./original.py\n\nreal    2m17.748s\nuser    2m15.783s\nsys     0m0.093s\n----------\n$ time ./original_x86_vs2012.exe\n\nreal    0m8.377s\nuser    0m0.015s\nsys     0m0.000s\n----------\n$ time ./original_x64_vs2012.exe\n\nreal    0m8.408s\nuser    0m0.000s\nsys     0m0.015s\n----------\n$ time ./original_x64_gcc.exe\n\nreal    0m20.951s\nuser    0m20.732s\nsys     0m0.030s\n\nintegertype_architecture_compiler.exe\nint\nlong\n----------\n$ time ./int_x86_vs2012.exe\n\nreal    0m8.440s\nuser    0m0.016s\nsys     0m0.015s\n----------\n$ time ./int_x64_vs2012.exe\n\nreal    0m8.408s\nuser    0m0.016s\nsys     0m0.015s\n----------\n$ time ./int32_x86_vs2012.exe\n\nreal    0m8.408s\nuser    0m0.000s\nsys     0m0.015s\n----------\n$ time ./int32_x64_vs2012.exe\n\nreal    0m8.362s\nuser    0m0.000s\nsys     0m0.015s\n----------\n$ time ./int64_x86_vs2012.exe\n\nreal    0m18.112s\nuser    0m0.000s\nsys     0m0.015s\n----------\n$ time ./int64_x64_vs2012.exe\n\nreal    0m18.611s\nuser    0m0.000s\nsys     0m0.015s\n----------\n$ time ./long_x86_vs2012.exe\n\nreal    0m8.393s\nuser    0m0.015s\nsys     0m0.000s\n----------\n$ time ./long_x64_vs2012.exe\n\nreal    0m8.440s\nuser    0m0.000s\nsys     0m0.015s\n----------\n$ time ./uint32_x86_vs2012.exe\n\nreal    0m8.362s\nuser    0m0.000s\nsys     0m0.015s\n----------\n$ time ./uint32_x64_vs2012.exe\n\nreal    0m8.393s\nuser    0m0.015s\nsys     0m0.015s\n----------\n$ time ./uint64_x86_vs2012.exe\n\nreal    0m15.428s\nuser    0m0.000s\nsys     0m0.015s\n----------\n$ time ./uint64_x64_vs2012.exe\n\nreal    0m15.725s\nuser    0m0.015s\nsys     0m0.015s\n----------\n$ time ./int_x64_gcc.exe\n\nreal    0m8.531s\nuser    0m8.329s\nsys     0m0.015s\n----------\n$ time ./int32_x64_gcc.exe\n\nreal    0m8.471s\nuser    0m8.345s\nsys     0m0.000s\n----------\n$ time ./int64_x64_gcc.exe\n\nreal    0m20.264s\nuser    0m20.186s\nsys     0m0.015s\n----------\n$ time ./long_x64_gcc.exe\n\nreal    0m20.935s\nuser    0m20.809s\nsys     0m0.015s\n----------\n$ time ./uint32_x64_gcc.exe\n\nreal    0m8.393s\nuser    0m8.346s\nsys     0m0.015s\n----------\n$ time ./uint64_x64_gcc.exe\n\nreal    0m16.973s\nuser    0m16.879s\nsys     0m0.030s\n\nint\nlong\nint32_t\nuint32_t\nint64_t\nuint64_t\n#include &lt;stdint.h&gt;\nuint32_t\n#include &lt;stdint.h&gt;",
            "-module(p12dist).  \n-author(\"Jannich Brendle, jannich@bredsaal.dk, http://blog.bredsaal.dk\").  \n-compile(export_all).\n\nserver() -&gt;  \n  server(1).\n\nserver(Number) -&gt;  \n  receive {getwork, Worker_PID} -&gt; Worker_PID ! {work,Number,Number+100},  \n  server(Number+101);  \n  {result,T} -&gt; io:format(\"The result is: \\~w.\\~n\", [T]);  \n  _ -&gt; server(Number)  \n  end.\n\nworker(Server_PID) -&gt;  \n  Server_PID ! {getwork, self()},  \n  receive {work,Start,End} -&gt; solve(Start,End,Server_PID)  \n  end,  \n  worker(Server_PID).\n\nstart() -&gt;  \n  Server_PID = spawn(p12dist, server, []),  \n  spawn(p12dist, worker, [Server_PID]),  \n  spawn(p12dist, worker, [Server_PID]),  \n  spawn(p12dist, worker, [Server_PID]),  \n  spawn(p12dist, worker, [Server_PID]).\n\nsolve(N,End,_) when N =:= End -&gt; no_solution;\n\nsolve(N,End,Server_PID) -&gt;  \n  T=round(N*(N+1)/2),\n  case (divisor(T,round(math:sqrt(T))) &gt; 500) of  \n    true -&gt;  \n      Server_PID ! {result,T};  \n    false -&gt;  \n      solve(N+1,End,Server_PID)  \n  end.\n\ndivisors(N) -&gt;  \n  divisor(N,round(math:sqrt(N))).\n\ndivisor(_,0) -&gt; 1;  \ndivisor(N,I) -&gt;  \n  case (N rem I) =:= 0 of  \n  true -&gt;  \n    2+divisor(N,I-1);  \n  false -&gt;  \n    divisor(N,I-1)  \n  end.\n\n~$ time erl -noshell -s p12dist start\n\nThe result is: 76576500.\n\n^C\n\nBREAK: (a)bort (c)ontinue (p)roc info (i)nfo (l)oaded\n       (v)ersion (k)ill (D)b-tables (d)istribution\na\n\nreal    0m5.510s\nuser    0m5.836s\nsys 0m0.152s\n",
            "package main\n\nimport \"fmt\"\nimport \"math\"\n\nfunc main() {\n    var n, m, c int\n    for i := 1; ; i++ {\n        n, m, c = i * (i + 1) / 2, int(math.Sqrt(float64(n))), 0\n        for f := 1; f &lt; m; f++ {\n            if n % f == 0 { c++ }\n    }\n    c *= 2\n    if m * m == n { c ++ }\n    if c &gt; 1001 {\n        fmt.Println(n)\n        break\n        }\n    }\n}\n\npackage main\n\nimport (\n    \"math\"\n    \"fmt\"\n )\n\n// Sieve of Eratosthenes\nfunc PrimesBelow(limit int) []int {\n    switch {\n        case limit &lt; 2:\n            return []int{}\n        case limit == 2:\n            return []int{2}\n    }\n    sievebound := (limit - 1) / 2\n    sieve := make([]bool, sievebound+1)\n    crosslimit := int(math.Sqrt(float64(limit))-1) / 2\n    for i := 1; i &lt;= crosslimit; i++ {\n        if !sieve[i] {\n            for j := 2 * i * (i + 1); j &lt;= sievebound; j += 2*i + 1 {\n                sieve[j] = true\n            }\n        }\n    }\n    plimit := int(1.3*float64(limit)) / int(math.Log(float64(limit)))\n    primes := make([]int, plimit)\n    p := 1\n    primes[0] = 2\n    for i := 1; i &lt;= sievebound; i++ {\n        if !sieve[i] {\n            primes[p] = 2*i + 1\n            p++\n            if p &gt;= plimit {\n                break\n            }\n        }\n    }\n    last := len(primes) - 1\n    for i := last; i &gt; 0; i-- {\n        if primes[i] != 0 {\n            break\n        }\n        last = i\n    }\n    return primes[0:last]\n}\n\n\n\nfunc main() {\n    fmt.Println(p12())\n}\n// Requires PrimesBelow from utils.go\nfunc p12() int {\n    n, dn, cnt := 3, 2, 0\n    primearray := PrimesBelow(1000000)\n    for cnt &lt;= 1001 {\n        n++\n        n1 := n\n        if n1%2 == 0 {\n            n1 /= 2\n        }\n        dn1 := 1\n        for i := 0; i &lt; len(primearray); i++ {\n            if primearray[i]*primearray[i] &gt; n1 {\n                dn1 *= 2\n                break\n            }\n            exponent := 1\n            for n1%primearray[i] == 0 {\n                exponent++\n                n1 /= primearray[i]\n            }\n            if exponent &gt; 1 {\n                dn1 *= exponent\n            }\n            if n1 == 1 {\n                break\n            }\n        }\n        cnt = dn * dn1\n        dn = dn1\n    }\n    return n * (n - 1) / 2\n}\n\ndef D(N):\n    if N == 1: return 1\n    sqrtN = int(N ** 0.5)\n    nf = 1\n    for d in range(2, sqrtN + 1):\n        if N % d == 0:\n            nf = nf + 1\n    return 2 * nf - (1 if sqrtN**2 == N else 0)\n\nL = 1000\nDt, n = 0, 0\n\nwhile Dt &lt;= L:\n    t = n * (n + 1) // 2\n    Dt = D(n/2)*D(n+1) if n%2 == 0 else D(n)*D((n+1)/2)\n    n = n + 1\n\nprint (t)\n",
            "#include &lt;iostream&gt;\n#include &lt;cmath&gt;\n#include &lt;tuple&gt;\n#include &lt;chrono&gt;\n\nusing namespace std;\n\n// Calculates the divisors of an integer by determining its prime factorisation.\n\nint get_divisors(long long n)\n{\n    int divisors_count = 1;\n\n    for(long long i = 2;\n        i &lt;= sqrt(n);\n        /* empty */)\n    {\n        int divisions = 0;\n        while(n % i == 0)\n        {\n            n /= i;\n            divisions++;\n        }\n\n        divisors_count *= (divisions + 1);\n\n        //here, we try to iterate more efficiently by skipping\n        //obvious non-primes like 4, 6, etc\n        if(i == 2)\n            i++;\n        else\n            i += 2;\n    }\n\n    if(n != 1) //n is a prime\n        return divisors_count * 2;\n    else\n        return divisors_count;\n}\n\nlong long euler12()\n{\n    //n and n + 1\n    long long n, n_p_1;\n\n    n = 1; n_p_1 = 2;\n\n    // divisors_x will store either the divisors of x or x/2\n    // (the later iff x is divisible by two)\n    long long divisors_n = 1;\n    long long divisors_n_p_1 = 2;\n\n    for(;;)\n    {\n        /* This loop has been unwound, so two iterations are completed at a time\n         * n and n + 1 have no prime factors in common and therefore we can\n         * calculate their divisors separately\n         */\n\n        long long total_divisors;                 //the divisors of the triangle number\n                                                  // n(n+1)/2\n\n        //the first (unwound) iteration\n\n        divisors_n_p_1 = get_divisors(n_p_1 / 2); //here n+1 is even and we\n\n        total_divisors =\n                  divisors_n\n                * divisors_n_p_1;\n\n        if(total_divisors &gt; 1000)\n            break;\n\n        //move n and n+1 forward\n        n = n_p_1;\n        n_p_1 = n + 1;\n\n        //fix the divisors\n        divisors_n = divisors_n_p_1;\n        divisors_n_p_1 = get_divisors(n_p_1);   //n_p_1 is now odd!\n\n        //now the second (unwound) iteration\n\n        total_divisors =\n                  divisors_n\n                * divisors_n_p_1;\n\n        if(total_divisors &gt; 1000)\n            break;\n\n        //move n and n+1 forward\n        n = n_p_1;\n        n_p_1 = n + 1;\n\n        //fix the divisors\n        divisors_n = divisors_n_p_1;\n        divisors_n_p_1 = get_divisors(n_p_1 / 2);   //n_p_1 is now even!\n    }\n\n    return (n * n_p_1) / 2;\n}\n\nint main()\n{\n    for(int i = 0; i &lt; 1000; i++)\n    {\n        using namespace std::chrono;\n        auto start = high_resolution_clock::now();\n        auto result = euler12();\n        auto end = high_resolution_clock::now();\n\n        double time_elapsed = duration_cast&lt;milliseconds&gt;(end - start).count();\n\n        cout &lt;&lt; result &lt;&lt; \" \" &lt;&lt; time_elapsed &lt;&lt; '\\n';\n    }\n    return 0;\n}\n",
            "// Return at least the number of factors of n.\nstatic uint64_t approxfactorcount (uint64_t n)\n{\n    uint64_t count = 1, add;\n\n#define CHECK(d)                            \\\n    do {                                    \\\n        if (n % d == 0) {                   \\\n            add = count;                    \\\n            do { n /= d; count += add; }    \\\n            while (n % d == 0);             \\\n        }                                   \\\n    } while (0)\n\n    CHECK ( 2); CHECK ( 3); CHECK ( 5); CHECK ( 7); CHECK (11); CHECK (13);\n    CHECK (17); CHECK (19); CHECK (23); CHECK (29);\n    if (n == 1) return count;\n    if (n &lt; 1ull * 31 * 31) return count * 2;\n    if (n &lt; 1ull * 31 * 31 * 37) return count * 4;\n    if (n &lt; 1ull * 31 * 31 * 37 * 37) return count * 8;\n    if (n &lt; 1ull * 31 * 31 * 37 * 37 * 41) return count * 16;\n    if (n &lt; 1ull * 31 * 31 * 37 * 37 * 41 * 43) return count * 32;\n    if (n &lt; 1ull * 31 * 31 * 37 * 37 * 41 * 43 * 47) return count * 64;\n    if (n &lt; 1ull * 31 * 31 * 37 * 37 * 41 * 43 * 47 * 53) return count * 128;\n    if (n &lt; 1ull * 31 * 31 * 37 * 37 * 41 * 43 * 47 * 53 * 59) return count * 256;\n    if (n &lt; 1ull * 31 * 31 * 37 * 37 * 41 * 43 * 47 * 53 * 59 * 61) return count * 512;\n    if (n &lt; 1ull * 31 * 31 * 37 * 37 * 41 * 43 * 47 * 53 * 59 * 61 * 67) return count * 1024;\n    if (n &lt; 1ull * 31 * 31 * 37 * 37 * 41 * 43 * 47 * 53 * 59 * 61 * 67 * 71) return count * 2048;\n    if (n &lt; 1ull * 31 * 31 * 37 * 37 * 41 * 43 * 47 * 53 * 59 * 61 * 67 * 71 * 73) return count * 4096;\n    return count * 1000000;\n}\n\n// Return the number of factors of n.\nstatic uint64_t factorcount (uint64_t n)\n{\n    uint64_t count = 1, add;\n\n    CHECK (2); CHECK (3);\n\n    uint64_t d = 5, inc = 2;\n    for (; d*d &lt;= n; d += inc, inc = (6 - inc))\n        CHECK (d);\n\n    if (n &gt; 1) count *= 2; // n must be a prime number\n    return count;\n}\n\n// Prints triangular numbers with record numbers of factors.\nstatic void printrecordnumbers (uint64_t limit)\n{\n    uint64_t record = 30000;\n\n    uint64_t count1, factor1;\n    uint64_t count2 = 1, factor2 = 1;\n\n    for (uint64_t n = 1; n &lt;= limit; ++n)\n    {\n        factor1 = factor2;\n        count1 = count2;\n\n        factor2 = n + 1; if (factor2 % 2 == 0) factor2 /= 2;\n        count2 = approxfactorcount (factor2);\n\n        if (count1 * count2 &gt; record)\n        {\n            uint64_t factors = factorcount (factor1) * factorcount (factor2);\n            if (factors &gt; record)\n            {\n                printf (\"%lluth triangular number = %llu has %llu factors\\n\", n, factor1 * factor2, factors);\n                record = factors;\n            }\n        }\n    }\n}\n",
            "zhengs-MacBook-Pro:workspace zhengzhibin$ time erl -noshell -s p12dist start\nThe result is: 842161320.\n\nreal    0m3.879s\nuser    0m14.553s\nsys     0m0.314s\nzhengs-MacBook-Pro:workspace zhengzhibin$ time erl -noshell -s euler12 solve\n842161320\n\nreal    0m10.125s\nuser    0m10.078s\nsys     0m0.046s\nzhengs-MacBook-Pro:workspace zhengzhibin$ time ./euler12.bin \n842161320\n\nreal    0m5.370s\nuser    0m5.328s\nsys     0m0.004s\nzhengs-MacBook-Pro:workspace zhengzhibin$\n",
            "#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\n\nint factorCount (long n)\n{\n    double square = sqrt (n);\n    int isquare = (int) square+1;\n    long candidate = 2;\n    int count = 1;\n    while(candidate &lt;= isquare &amp;&amp; candidate &lt;= n){\n        int c = 1;\n        while (n % candidate == 0) {\n           c++;\n           n /= candidate;\n        }\n        count *= c;\n        candidate++;\n    }\n    return count;\n}\n\nint main ()\n{\n    long triangle = 1;\n    int index = 1;\n    while (factorCount (triangle) &lt; 1001)\n    {\n        index ++;\n        triangle += index;\n    }\n    printf (&quot;%ld\\n&quot;, triangle);\n}\n"
        ]
    },
    {
        "question_id": 1653958,
        "question_code": "#ifndef HEADERFILE_H\n#define HEADERFILE_H\n\n#endif\n",
        "answer_code_snippets": [
            "HEADERFILE_H\nifndef",
            "#ifndef &lt;token&gt;\n/* code */\n#else\n/* code to include if the token is defined */\n#endif\n\n#ifndef\n#defined\n#else\n#else\n#endif\n#ifndef\n#ifndef _INCL_GUARD\n#define _INCL_GUARD\n#endif\n",
            "#ifndef __COMMON_H__\n#define __COMMON_H__\n//header file content\n#endif\n",
            "#ifndef\nHEADERFILE_H\n#define\nHEADERFILE_H\n#ifndef\n#endif\n#ifndef\n#ifndef\n#ifndef\n#ifndef\n#endif",
            "#ifndef ABOUTSCREEN_H\n#define ABOUTSCREEN_H\n\n#include &lt;fcntl.h&gt;\n#include &lt;unistd.h&gt;\n\n#define CHARGING_STATUS_FILE &quot;/cable.2/state&quot;\n\n#define LED_ON &quot;255&quot;\n#define LED_OFF &quot;0&quot;\n\nnamespace Ui\n{\n    class aboutScreen;\n}\n\nclass aboutScreen : public QWidget\n{\n    Q_OBJECT\n\npublic:\n    enum LedColors\n    {\n        OFF,\n        RED,\n        BLUE,\n        GREEN,\n        WHITE\n    };\n\n    explicit aboutScreen(QWidget *parent = 0, Ui::mainStackWidget *uiMainStackWidget = 0);\n    ~aboutScreen();\n    void init(void);\n    void writeLedStatus(QString, QString);\n\npublic slots:\n    void updateBatteryAndStorageStatus(void);\n\nprivate slots:\n    void on_backButton_pressed();\n    void on_backButton_released();\n\nprivate:\n    Ui::mainStackWidget *uiMainStackWidget;\n};\n\n#endif // ABOUTSCREEN_H\n"
        ]
    },
    {
        "question_id": 822323,
        "question_code": "",
        "answer_code_snippets": [
            "rand()\n#include &lt;time.h&gt;\n#include &lt;stdlib.h&gt;\n\nsrand(time(NULL));   // Initialization, should only be called once.\nint r = rand();      // Returns a pseudo-random integer between 0 and RAND_MAX.\n",
            "rand()\n&lt;stdlib.h&gt;\nRAND_MAX\nsrand(unsigned int seed)\n%\nrand()\n/* random int between 0 and 19 */\nint r = rand() % 20;\n\n/* Returns an integer in the range [0, n).\n *\n * Uses rand(), and so is affected-by/affects the same seed.\n */\nint randint(int n) {\n  if ((n - 1) == RAND_MAX) {\n    return rand();\n  } else {\n    // Supporting larger values for n would requires an even more\n    // elaborate implementation that combines multiple calls to rand()\n    assert (n &lt;= RAND_MAX)\n\n    // Chop off all of the values that would cause skew...\n    int end = RAND_MAX / n; // truncate skew\n    assert (end &gt; 0);\n    end *= n;\n\n    // ... and ignore results from rand() that fall above that limit.\n    // (Worst case the loop condition should succeed 50% of the time,\n    // so we can expect to bail out of this loop pretty quickly.)\n    int r;\n    while ((r = rand()) &gt;= end);\n\n    return r % n;\n  }\n}\n",
            "randombytes\n/dev/urandom\n/dev/random\n#include \"sodium.h\"\n\nint foo()\n{\n    char myString[32];\n    uint32_t myInt;\n\n    if (sodium_init() &lt; 0) {\n        /* panic! the library couldn't be initialized, it is not safe to use */\n        return 1; \n    }\n\n\n    /* myString will be an array of 32 random bytes, not null-terminated */        \n    randombytes_buf(myString, 32);\n\n    /* myInt will be a random number between 0 and 9 */\n    myInt = randombytes_uniform(10);\n}\n\nrandombytes_uniform()",
            "srand()\nsrand()\ntime()\nrand()\n    #include &lt;stdio.h&gt;\n\n    int random_number(int min_num, int max_num);\n\n    int main(void)\n    {\n        printf(&quot;Min : 1 Max : 40 %d\\n&quot;, random_number(1,40));\n        printf(&quot;Min : 100 Max : 1000 %d\\n&quot;,random_number(100,1000));\n        return 0;\n    }\n\n    int random_number(int min_num, int max_num)\n    {\n        int result = 0, low_num = 0, hi_num = 0;\n\n        if (min_num &lt; max_num)\n        {\n            low_num = min_num;\n            hi_num = max_num + 1; // include max_num in output\n        } else {\n            low_num = max_num + 1; // include max_num in output\n            hi_num = min_num;\n        }\n\n        srand(time(NULL));\n        result = (rand() % (hi_num - low_num)) + low_num;\n        return result;\n    }\n",
            "stdlib",
            "rand()\nrand()\nrand()\nsrand()\n#include &lt;stdint.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;openssl/rand.h&gt;\n\n/* Random integer in [0, limit) */\nunsigned int random_uint(unsigned int limit) {\n    union {\n        unsigned int i;\n        unsigned char c[sizeof(unsigned int)];\n    } u;\n\n    do {\n        if (!RAND_bytes(u.c, sizeof(u.c))) {\n            fprintf(stderr, \"Can't get random bytes!\\n\");\n            exit(1);\n        }\n    } while (u.i &lt; (-limit % limit)); /* u.i &lt; (2**size % limit) */\n    return u.i % limit;\n}\n\n/* Random double in [0.0, 1.0) */\ndouble random_double() {\n    union {\n        uint64_t i;\n        unsigned char c[sizeof(uint64_t)];\n    } u;\n\n    if (!RAND_bytes(u.c, sizeof(u.c))) {\n        fprintf(stderr, \"Can't get random bytes!\\n\");\n        exit(1);\n    }\n    /* 53 bits / 2**53 */\n    return (u.i &gt;&gt; 11) * (1.0/9007199254740992.0);\n}\n\nint main() {\n    printf(\"Dice: %d\\n\", (int)(random_uint(6) + 1));\n    printf(\"Double: %f\\n\", random_double());\n    return 0;\n}\n\nrand() % 10000\nrand()\nrand()\ndouble\nrand() / (double)RAND_MAX\nrand()\nRAND_bytes()\n/dev/urandom\n/dev/urandom\nsrand()\n/dev/urandom",
            "arc4random\nrand\narc4random\nuint32_t arc4random(void)\nvoid arc4random_buf(void *buf, size_t bytes)\nuint32_t arc4random_uniform(uint32_t limit)\nvoid arc4random_stir(void)\nvoid arc4random_addrandom(unsigned char *dat, int datlen)\n\narc4random\narc4random_buf\nbuf : void *\nbytes : size_t\narc4random_uniform\n0 &lt;= arc4random_uniform(limit) &lt; limit\narc4random_stir\n/dev/urandom\narc4random_addrandom\narc4random_addrandom\narc4random_stir\n/* This is C, not C++ */\n#include &lt;sys/types.h&gt;\n#include &lt;sys/stat.h&gt;\n#include &lt;fcntl.h&gt;\n#include &lt;errno.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;stdlib.h&gt; /* exit */\n#include &lt;stdio.h&gt; /* printf */\n\nint urandom_fd = -2;\n\nvoid urandom_init() {\n  urandom_fd = open(&quot;/dev/urandom&quot;, O_RDONLY);\n\n  if (urandom_fd == -1) {\n    int errsv = urandom_fd;\n    printf(&quot;Error opening [/dev/urandom]: %i\\n&quot;, errsv);\n    exit(1);\n  }\n}\n\nunsigned long urandom() {\n  unsigned long buf_impl;\n  unsigned long *buf = &amp;buf_impl;\n\n  if (urandom_fd == -2) {\n    urandom_init();\n  }\n\n  /* Read sizeof(long) bytes (usually 8) into *buf, which points to buf_impl */\n  read(urandom_fd, buf, sizeof(long));\n  return buf_impl;\n}\n\nurandom_init\n/dev/urandom\nurandom_fd\nurandom\nrand\nlong\n/dev/urandom\n/dev/urandom\n/dev/random\nopen\nurandom_init\nurandom_init\nurandom\n/dev/urandom\n/dev/random\nrand\nurandom\nrand\narc4random\n#define RAND_IMPL /* urandom(see large code block) | rand | arc4random */\n\nint myRandom(int bottom, int top){\n    return (RAND_IMPL() % (top - bottom)) + bottom;\n}\n",
            "rand\nrandom\nstdlib.h\nrand\nrandom\nrand\nrandom\nrandom\nrand\nrand\nrand",
            "rand()",
            "#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;time.h&gt;\n\n    #define randnum(min, max) \\\n        ((rand() % (int)(((max) + 1) - (min))) + (min))\n\nint main()\n{\n    srand(time(NULL));\n\n    printf(\"%d\\n\", randnum(1, 70));\n}\n\nrandnum",
            "srand(time(NULL))\n\nman srand\ntime\nsrand(time(NULL) | getHashOfString(outputName))\n\nclock_gettime\n#include&lt;time.h&gt;\nstruct timespec nanos;\nclock_gettime(CLOCK_MONOTONIC, &amp;nanos)\nsrand(nanos.tv_nsec);\n\n#include&lt;time.h&gt;\nstruct timespec nanos;\nclock_gettime(CLOCK_MONOTONIC, &amp;nanos)\nsrand(nanos.tv_nsec | getHashOfString(outputName));\n",
            "rand()\nsrand()\nint rand(void);\n\nvoid srand(unsigned seed);\n\nrandom()\nlong random(void);\n\nrandom()",
            "stdlib.h\nrand",
            "srand(time(NULL))\n#include &lt;time.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main(int argc, char **argv)\n{\n    srand((unsigned int)**main + (unsigned int)&amp;argc + (unsigned int)time(NULL));\n    srand(rand());\n\n    for (int i = 0; i &lt; 10; i++)\n        printf(\"%d\\n\", rand());\n}\n",
            "#include &lt;time.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main()\n{\n    srand(time(NULL));\n    int lowerLimit = 10, upperLimit = 50;\n    int r =  lowerLimit + rand() % (upperLimit - lowerLimit);\n    printf(\"%d\", r);\n}\n",
            "_rdrand64_step()\n#include &lt;immintrin.h&gt;\n\nuint64_t randVal;\nif(!_rdrand64_step(&amp;randVal)) {\n  // Report an error here: random number generation has failed!\n}\n// If no error occured, randVal contains a random 64-bit number\n",
            "rand()",
            "#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nvoid main() \n{\n    int visited[100];\n    int randValue, a, b, vindex = 0;\n\n    randValue = (rand() % 100) + 1;\n\n    while (vindex &lt; 100) {\n        for (b = 0; b &lt; vindex; b++) {\n            if (visited[b] == randValue) {\n                randValue = (rand() % 100) + 1;\n                b = 0;\n            }\n        }\n\n        visited[vindex++] = randValue;\n    }\n\n    for (a = 0; a &lt; 100; a++)\n        printf(\"%d \", visited[a]);\n}\n",
            "rand()\nrand()\nrand()\nrand()\nsrand()\nrandom(3)\nsrandom(3)\nrandom(3)\nrandom()\nrand()\nrandom()\nrandom()\nlrand48()\nmrand48()\narc4random()",
            "#include &lt;stdio.h&gt;\n#include &lt;dos.h&gt;\n\nint random(int range);\n\nint main(void)\n{\n    printf(\"%d\", random(10));\n    return 0;\n}\n\nint random(int range)\n{\n    struct time t;\n    int r;\n\n    gettime(&amp;t);\n    r = t.ti_sec % range;\n    return r;\n}\n",
            "#include&lt;stdio.h&gt;\n#include&lt;stdlib.h&gt;\n#include&lt;time.h&gt;\n\n//generate number in range [min,max)\nint random(int min, int max){\n    int number = min + rand() % (max - min);\n    return number; \n}\n\n//Driver code\nint main(){\n    srand(time(NULL));\n    for(int i = 1; i &lt;= 10; i++){\n        printf(\"%d\\t\", random(10, 100));\n    }\n    return 0;\n}\n",
            "urandom_open()\nint gUrandomFd = -1;\n\nint urandom_open(void)\n{\n    if (gUrandomFd == -1) {\n        gUrandomFd = open(\"/dev/urandom\", O_RDONLY);\n    }\n\n    if (gUrandomFd == -1) {\n        fprintf(stderr, \"Error opening /dev/urandom: errno [%d], strerrer [%s]\\n\",\n                  errno, strerror(errno));\n        return -1;\n    } else {\n        return 0;\n    }\n}\n\n\nvoid urandom_close(void)\n{\n    close(gUrandomFd);\n    gUrandomFd = -1;\n}\n\n\n//\n// This link essentially validates the merits of /dev/urandom:\n// http://sockpuppet.org/blog/2014/02/25/safely-generate-random-numbers/\n//\nint getRandomBuffer(uint8_t *buf, int size)\n{\n    int ret = 0; // Return value\n\n    if (gUrandomFd == -1) {\n        fprintf(stderr, \"Urandom (/dev/urandom) file not open\\n\");\n        return -1;\n    }\n\n    ret = read(gUrandomFd, buf, size);\n\n    if (ret != size) {\n        fprintf(stderr, \"Only read [%d] bytes, expected [%d]\\n\",\n                 ret, size);\n        return -1;\n    } else {\n        return 0;\n    }\n}\n",
            "rand()\nINT_MIN\nINT_MAX\nrand()\n0\nRAND_MAX\nconst int MIN = 1;\nconst int MAX = 1024;\n// Get a pseudo-random number between MIN and MAX, **inclusive**.\n// Seeding of the pseudo-random number generator automatically occurs\n// the very first time you call it.\nint random_num = utils_rand(MIN, MAX);\n\n#include &lt;assert.h&gt;\n#include &lt;stdbool.h&gt;\n#include &lt;stdlib.h&gt;\n\n/// \\brief      Use linear interpolation to rescale, or &quot;map&quot; value `val` from range\n///             `in_min` to `in_max`, inclusive, to range `out_min` to `out_max`, inclusive.\n/// \\details    Similar to Arduino's ingenious `map()` function:\n///             https://www.arduino.cc/reference/en/language/functions/math/map/\n///\n/// TODO(gabriel): turn this into a gcc statement expression instead to prevent the potential for\n/// the &quot;double evaluation&quot; bug. See `MIN()` and `MAX()` above.\n#define UTILS_MAP(val, in_min, in_max, out_min, out_max) \\\n    (((val) - (in_min)) * ((out_max) - (out_min)) / ((in_max) - (in_min)) + (out_min))\n\n/// \\brief      Obtain a pseudo-random integer value between `min` and `max`, **inclusive**.\n/// \\details    1. If `(max - min + 1) &gt; RAND_MAX`, then the range of values returned will be\n///             **scaled** to the range `max - min + 1`, and centered over the center of the\n///             range at `(min + max)/2`. Scaling the numbers means that in the case of scaling,\n///             not all numbers can even be reached. However, you will still be assured to have\n///             a random distribution of numbers across the full range.\n///             2. Also, the first time per program run that you call this function, it will\n///             automatically seed the pseudo-random number generator with your system's\n///             current time in seconds.\n/// \\param[in]  min         The minimum pseudo-random number you'd like, inclusive. Can be positive\n///                         OR negative.\n/// \\param[in]  max         The maximum pseudo-random number you'd like, inclusive. Can be positive\n///                         OR negative.\n/// \\return     A pseudo-random integer value between `min` and `max`, **inclusive**.\nint utils_rand(int min, int max)\n{\n    static bool first_run = true;\n    if (first_run)\n    {\n        // seed the pseudo-random number generator with the seconds time the very first run\n        time_t time_now_sec = time(NULL);\n        srand(time_now_sec);\n        first_run = false;\n    }\n\n    int range = max - min + 1;\n    int random_num = rand();  // random num from 0 to RAND_MAX, inclusive\n\n    if (range &gt; RAND_MAX)\n    {\n        static_assert(\n            sizeof(long int) &gt; sizeof(int),\n            &quot;This must be true or else the below mapping/scaling may have undefined overflow &quot;\n            &quot;and not work properly. In such a case, try casting to `long long int` instead of &quot;\n            &quot;just `long int`, and update this static_assert accordingly.&quot;);\n\n        random_num = UTILS_MAP((long int)random_num, (long int)0, (long int)RAND_MAX, (long int)min,\n                               (long int)max);\n        return random_num;\n    }\n\n    // This is presumably a faster approach than the map/scaling function above, so do this faster\n    // approach below whenever you don't **have** to do the more-complicated approach above.\n    random_num %= range;\n    random_num += min;\n\n    return random_num;\n}\n\n",
            "/dev/urandom\n/dev/random\nread\nfread\n/dev/random\n/dev/urandom\nentropy_avail\nioctl",
            "random()\nrandom_r()\nstruct random_data\ninitstate_r()\nrandom_r()\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#include &lt;time.h&gt;\n\nvoid xxx (void) {\n    unsigned int seed = (unsigned int) time(NULL);\n    char rnd_state[17] = {0};\n    struct random_data rnd_st_buf = {0};\n    initstate_r(seed, &amp;rnd_state[0], 17, &amp;rnd_st_buf);\n    for(size_t idx = 0; idx &lt; 8; idx++) {\n        int32_t rnd_int = 0;\n        char rnd_seq_str[6] = {0};\n        random_r(&amp;rnd_st_buf, &amp;rnd_int);\n        memcpy((char *)&amp;rnd_seq_str[0], (char *)&amp;rnd_int, 4);\n        printf(&quot;random number : 0x%08x,  \\n&quot;, rnd_int);\n    }\n}\n",
            "#include &lt;stdlib.h&gt;\n#include &lt;stdio.h&gt;\n\ntypedef double rand_type; // change double to int\n\nrand_type my_rand() {\n    char buff[sizeof(rand_type)];\n    for (size_t i = 0 ; i &lt; sizeof(rand_type) ; ++i)\n        buff[i] = (char) rand();\n    return *(rand_type *) buff;\n}\n\nint main() {\n    int i ; // srand as you want\n    for (i = 0 ; i &lt; 10 ; ++i)\n        printf(&quot;%g\\n&quot;, my_rand()); // change %g to %d\n    return 0 ;\n}\n",
            "#include &lt;mgl2/mgl_cf.h&gt;\nmgl_rnd()",
            "srand()\ntime.h\n#include&lt;time.h&gt;\nlong long random_in_range (int range) {\n  struct timespec t ;\n  clock_gettime ( CLOCK_REALTIME , &amp; t ) ;\n  return (t.tv_sec * 1000 + ( t.tv_nsec + 500000 ) / 1000000) % range ;\n}\n",
            "int random() {\n    static  unsigned long long int x = 4694882287132787932;\n    return x ^= x &lt;&lt; 10, x ^= x &gt;&gt; 13, (int)(x ^= x &gt;&gt; 10);\n}\n\n-2074755801\n2063439557\n1142195322\n\nunsigned long long int random() {\n    static  unsigned long long int x = 4694882287132787932;\n    return x ^= x &lt;&lt; 10, x ^= x &gt;&gt; 13, x ^= x &gt;&gt; 10;\n}\n"
        ]
    },
    {
        "question_id": 17307275,
        "question_code": "_Bool\nbool\nstdbool.h\nprintf\nbool x = true;\nprintf(\"%B\\n\", x);\n\ntrue\n",
        "answer_code_snippets": [
            "bool\nint\nint\nprintf()\n%d\nbool x = true;\nprintf(&quot;%d\\n&quot;, x); // prints 1\n\nprintf(&quot;Your boolean variable is: %s&quot;, x ? &quot;true&quot; : &quot;false&quot;);\n",
            "bool\nprintf(&quot;%s&quot;, x?&quot;true&quot;:&quot;false&quot;);\n",
            "bool\n#include &lt;stdio.h&gt;\n#include &lt;printf.h&gt;\n#include &lt;stdbool.h&gt;\n\nstatic int bool_arginfo(const struct printf_info *info, size_t n,\n    int *argtypes, int *size)\n{\n  if (n) {\n    argtypes[0] = PA_INT;\n    *size = sizeof(bool);\n  }\n  return 1;\n}\nstatic int bool_printf(FILE *stream, const struct printf_info *info,\n    const void *const *args)\n{\n  bool b =  *(const bool*)(args[0]);\n  int r = fputs(b ? \"true\" : \"false\", stream);\n  return r == EOF ? -1 : (b ? 4 : 5);\n}\nstatic int setup_bool_specifier()\n{\n  int r = register_printf_specifier('B', bool_printf, bool_arginfo);\n  return r;\n}\nint main(int argc, char **argv)\n{\n  int r = setup_bool_specifier();\n  if (r) return 1;\n  bool b = argc &gt; 1;\n  r = printf(\"The result is: %B\\n\", b);\n  printf(\"(written %d characters)\\n\", r);\n  return 0;\n}\n",
            "itoa()\n#define btoa(x) ((x)?\"true\":\"false\")\n\nbool x = true;\nprintf(\"%s\\n\", btoa(x));\n",
            "_Bool b = 1;\nprintf(\"%d\\n\", b);\n",
            "printf(\"%d\\n\", !!(42));\n\n#define MY_FLAG (1 &lt;&lt; 4)\nint flags = MY_FLAG;\nprintf(\"%d\\n\", !!(flags &amp; MY_FLAG));\n",
            "printf(\"%s\\n\", \"false\\0true\"+6*x);\n",
            "#include &lt;ios&gt;\n#include &lt;iostream&gt;\n\nbool b = IsSomethingTrue();\nstd::cout &lt;&lt; std::boolalpha &lt;&lt; b;\n"
        ]
    },
    {
        "question_id": 12887700,
        "question_code": "#ifdef __cplusplus",
        "answer_code_snippets": [
            "#include &lt;stdio.h&gt;\n\nstruct f { int x; };\n\nint main() {\n    f();\n}\n\nint f() {\n    return printf(&quot;hello&quot;);\n}\n\nf\nhello\nf\nstruct f\nstruct",
            "int a = 10 //* comment */ 2 \n        + 3;\n\n//\nint a = 10 + 3;\n\n/* comment */\n/\n2\nint a = 10 / 2 + 3;\n",
            "i\nint i = sizeof('a');\n\n#include &lt;stdio.h&gt;\n\nint  sz = 80;\n\nint main(void)\n{\n    struct sz { char c; };\n\n    int val = sizeof(sz);      // sizeof(int) in C,\n                               // sizeof(struct sz) in C++\n    printf(\"%d\\n\", val);\n    return 0;\n}\n",
            "int\ndouble\n#include &lt;stdio.h&gt;\n\nint main()\n{\n  auto j = 1.5;\n  printf(\"%d\", (int)sizeof(j));\n  return 0;\n}\n\nauto\nint\nauto",
            "#include &lt;stdio.h&gt;\nint main()\n{\n#if true\n    printf(\"true!\\n\");\n#else\n    printf(\"false!\\n\");\n#endif\n    return 0;\n}\n",
            "   char arr[100];\n   int s = sizeof(0, arr);       // The comma operator is used.\n\nsizeof(char*)\n   enum E { a, b, c };\n   sizeof(a) == sizeof(int);     // In C\n   sizeof(a) == sizeof(E);       // In C++\n\nsizeof(int)\nsizeof(E)\n   int f();           // int f(void) in C++\n                      // int f(*unknown*) in C\n",
            "1\n0\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main(void)\n{\n    int d = (int)(abs(0.6) + 0.5);\n    printf(\"%d\", d);\n    return 0;\n}\n\ndouble abs(double)\nabs(0.6)\n0.6\n0\nint abs(int)\nfabs\ndouble",
            "sizeof\n#include &lt;stdio.h&gt;\nint main() {\n    printf(\"%d\\n\", (int)sizeof !0);\n}\n\nsizeof(int)\nint",
            "#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    printf(\"%d\\n\", (int)sizeof('a'));\n    return 0;\n}\n\nsizeof(int)\n4",
            "//\nint f(int a, int b)\n{\n    return a //* blah */ b\n        ;\n}\n",
            "...\nint a = 4 //* */ 2\n        +2;\nprintf(\"%i\\n\",a);\n...\n",
            "#include &lt;stdio.h&gt;\n\nint x[1];\nint main(void) {\n    struct x { int a[2]; };\n    /* size of the array in C */\n    /* size of the struct in C++ */\n    printf(\"%d\\n\", (int)sizeof(x)); \n}\n",
            "#include &lt;stdio.h&gt;\n\nstruct fun{};\n\nint main()\n{\n    fun();  // In C, this calls the inline function from file 2 where as in C++\n            // this would create a variable of struct fun\n    return 0;\n}\n\n#include &lt;stdio.h&gt;\ninline void fun(void)\n{\n    printf(\"I am inline\\n\");\n} \n\nconst\nstatic\nextern\nextern",
            "#include &lt;stdio.h&gt;\n\nstruct A {\n    double a[32];\n};\n\nint main() {\n    struct B {\n        struct A {\n            short a, b;\n        } a;\n    };\n    printf(\"%d\\n\", sizeof(struct A));\n    return 0;\n}\n\n128\n32 * sizeof(double)\n4",
            "struct abort\n{\n    int x;\n};\n\nint main()\n{\n    abort();\n    return 0;\n}\n\nstruct exit\n{\n    int x;\n};\n\nint main()\n{\n    struct exit code;\n    code.x=1;\n\n    exit(code);\n\n    return 0;\n}\n",
            "#include &lt;cstdio&gt;\n\nvoid foo(int r)\n{\n  printf(\"I am C++\\n\");\n}\n\n#include &lt;stdio.h&gt;\n\nvoid foo(int r)\n{\n  printf(\"I am C\\n\");\n}\n\nextern void foo(int);\n\nint main(void)\n{\n  foo(1);\n  return 0;\n}\n\n$ diff main.cpp main.c\n$ gcc -o test main.cpp foo.cpp foo2.c\n$ ./test \nI am C++\n$ gcc -o test main.c foo.cpp foo2.c\n$ ./test \nI am C\n",
            "int main(void) {\n    const int dim = 5; \n    int array[dim];\n}\n\nsizeof array\nint main(void) {\n    const int dim = 5; \n    int array[dim] = {0};\n}\n",
            "#include &lt;stdio.h&gt;\n\ntypedef struct {} Foo;\n\nint main()\n{\n    printf(\"%zd\\n\", sizeof(Foo));\n    return 0;\n}\n",
            "=\nint a = 5;\na++ = 2;  /* error: lvalue required as left operand of assignment */\n++a = 2;  /* error: lvalue required as left operand of assignment */\n\n=\nint a = 5;\na++ = 2;  // error: lvalue required as left operand of assignment\n++a = 2;  // No error: a gets assigned to 2!\n\nint x = a;\nint x = ++a;\n\nint a;\na = 2;\n++a = 2;  // Valid in C++.\n"
        ]
    },
    {
        "question_id": 1716296,
        "question_code": "printf\nprintf",
        "answer_code_snippets": [
            "stdout\nstderr\nfprintf\nstderr\nfprintf(stderr, &quot;I will be printed immediately&quot;);\n\nstdout\nfflush\nprintf(&quot;Buffered, will be flushed&quot;);\nfflush(stdout); // Will now print everything in the stdout buffer\n\nsetbuf\nsetbuf(stdout, NULL);\n\nsetvbuf\nsetvbuf(stdout, NULL, _IONBF, 0); \n",
            "printf\nmyprog &gt;myfile.txt\n\nfflush (stdout)\nsetvbuf\nstdout\nfflush\nsetvbuf (stdout, NULL, _IONBF, BUFSIZ);\n\n7.19.3/3\nsetbuf\nsetvbuf",
            "fflush(stdout)\nfflush(NULL)\nNULL",
            "program A output\nprogram B output\nprogram B output\nprogram A output\nprogram B output\n\nproprogrgraam m AB  ououtputputt\nprproogrgram amB A  ououtputtput\nprogram B output\n",
            "printf(\"will print immediately to terminal\")",
            "setbuf(stdout, NULL);",
            "fprintf and write()\nfprintf()\nsetbuff(stream,NULL)\nfflush(FILE *stream)\nread()\nfscanf()\nfprintf()\nwrite()\nO_SYNC\nfsync(),fdatasync(),sync()"
        ]
    },
    {
        "question_id": 4955198,
        "question_code": "",
        "answer_code_snippets": [
            "p\nconst char* p = \"abc\";\n\np\np\nMemory Address (hex)    Variable name    Contents\n1000                                     'a' == 97 (ASCII)\n1001                                     'b' == 98\n1002                                     'c' == 99\n1003                                     0\n...\n2000-2003               p                1000 hex\n\np\np\np\nassert(*p == 'a');  // The first character at address p will be 'a'\nassert(p[1] == 'b'); // p[1] actually dereferences a pointer created by adding\n                     // p and 1 times the size of the things to which p points:\n                     // In this case they're char which are 1 byte in C...\nassert(*(p + 1) == 'b');  // Another notation for p[1]\n\n++p;  // Increment p so it's now 0x1001\nassert(*p == 'b');  // p == 0x1001 which is where the 'b' is...\n\nint x = 2;\nint* p_x = &amp;x;  // Put the address of the x variable into the pointer p_x\n*p_x = 4;       // Change the memory at the address in p_x to be 4\nassert(x == 4); // Check x is now 4\n\nx\n&amp;x\n-&gt;\ntypedef struct X { int i_; double d_; } X;\nX x;\nX* p = &amp;x;\np-&gt;d_ = 3.14159;  // Dereference and access data member x.d_\n(*p).d_ *= -1;    // Another equivalent notation for accessing x.d_\n\ndouble sizes[] = { 10.3, 13.4, 11.2, 19.4 };\ndouble* p = sizes;\nassert(p[0] == 10.3);  // Knows to look at all the bytes in the first double value\nassert(p[1] == 13.4);  // Actually looks at bytes from address p + 1 * sizeof(double)\n                       // (sizeof(double) is almost always eight bytes)\n++p;                   // Advance p by sizeof(double)\nassert(*p == 13.4);    // The double at memory beginning at address p has value 13.4\n*(p + 2) = 29.8;       // Change sizes[3] from 19.4 to 29.8\n                       // Note earlier ++p and + 2 here =&gt; sizes[3]\n\nmalloc\nint* p = (int*)malloc(sizeof(int)); // Get some memory somewhere...\n*p = 10;            // Dereference the pointer to the memory, then write a value in\nfn(*p);             // Call a function, passing it the value at address p\n(*p) += 3;          // Change the value, adding 3 to it\nfree(p);            // Release the memory back to the heap allocation library\n\nnew\ndelete\nint* p = new int(10); // Memory for one int with initial value 10\ndelete p;\n\np = new int[10];      // Memory for ten ints with unspecified initial value\ndelete[] p;\n\np = new int[10]();    // Memory for ten ints that are value initialised (to 0)\ndelete[] p;\n\nfree()\ndelete\nconst char* p = asprintf(\"name: %s\", name);  // Common but non-Standard printf-on-heap\n\n// Replace non-printable characters with underscores....\nfor (const char* q = p; *q; ++q)\n    if (!isprint(*q))\n        *q = '_';\n\nprintf(\"%s\\n\", p); // Only q was modified\nfree(p);\n\nconst size_t n = ...;\np += n;\n...\np -= n;  // Restore earlier value...\nfree(p);\n\nunique_ptr\n{\n    std::unique_ptr&lt;T&gt; p{new T(42, \"meaning\")};\n    call_a_function(p);\n    // The function above might throw, so delete here is unreliable, but...\n} // p's destructor's guaranteed to run \"here\", calling delete\n\nshared_ptr\n{\n    auto p = std::make_shared&lt;T&gt;(3.14, \"pi\");\n    number_storage1.may_add(p); // Might copy p into its container\n    number_storage2.may_add(p); // Might copy p into its container    } // p's destructor will only delete the T if neither may_add copied it\n\nNULL\n0\nnullptr\nconst char* p_filename = NULL; // Or \"= 0\", or \"= nullptr\" in C++\nint c;\nwhile ((c = getopt(argc, argv, \"f:\")) != -1)\n    switch (c) {\n      case f: p_filename = optarg; break;\n    }\nif (p_filename)  // Only NULL converts to false\n    ...   // Only get here if -f flag specified\n\n0\nbools\nfalse\nNULL\nstatic\nnew T();\nnew T(x, y, z);\nnew T;\n0\nNULL\nnullptr\n0\nNULL\nnullptr\nNULL\nint*\nint\nfloat*\nint\nint*",
            "int a = 10;\nint* ptr = &amp;a;\n\nprintf(\"%d\", *ptr); // With *ptr I'm dereferencing the pointer. \n                    // Which means, I am asking the value pointed at by the pointer.\n                    // ptr is pointing to the location in memory of the variable a.\n                    // In a's location, we have 10. So, dereferencing gives this value.\n\n// Since we have indirect control over a's location, we can modify its content using the pointer. This is an indirect way to access a.\n\n *ptr = 20;         // Now a's content is no longer 10, and has been modified to 20.\n",
            "int a=4 ;\nint *pA = &amp;a ;\nprintf( \"The REFERENCE/call number for the variable `a` is %p\\n\", pA ) ;\n\n// The * causes pA to DEREFERENCE...  `a` via \"callnumber\" `pA`.\nprintf( \"%d\\n\", *pA ) ; // prints 4.. \n",
            "void main() {   \n    int*    x;  // Allocate the pointer x\n    x = malloc(sizeof(int));    // Allocate an int pointee,\n                            // and set x to point to it\n    *x = 42;    // Dereference x to store 42 in its pointee   \n}\n",
            "char *p = NULL;\n*p;\n\np1 = &amp;(*p);\nsz = sizeof(*p);\n"
        ]
    },
    {
        "question_id": 11694546,
        "question_code": "*\n/\n+\n-\n%",
        "answer_code_snippets": [
            "+\n// replaces the + operator\nint add(int x, int y)\n{\n    while (x) {\n        int t = (x &amp; y) &lt;&lt; 1;\n        y ^= x;\n        x = t;\n    }\n    return y;\n}\n\nint divideby3(int num)\n{\n    int sum = 0;\n    while (num &gt; 3) {\n        sum = add(num &gt;&gt; 2, sum);\n        num = add(num &gt;&gt; 2, num &amp; 3);\n    }\n    if (num == 3)\n        sum = add(sum, 1);\n    return sum; \n}\n\nn = 4 * a + b\nn / 3 = a + (a + b) / 3\nsum += a\nn = a + b\na == 0 (n &lt; 4)\nsum += floor(n / 3);\nif n == 3, else 0",
            "#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main()\n{\n    FILE * fp=fopen(\"temp.dat\",\"w+b\");\n    int number=12346;\n    int divisor=3;\n    char * buf = calloc(number,1);\n    fwrite(buf,number,1,fp);\n    rewind(fp);\n    int result=fread(buf,divisor,number,fp);\n    printf(\"%d / %d = %d\", number, divisor, result);\n    free(buf);\n    fclose(fp);\n    return 0;\n}\n\nresult\ndouble\nfmod(number,divisor)\nfwrite\nnumber\nrewind\nfread\nnumber\ndivisor",
            "log(pow(exp(number),0.33333333333333333333)) /* :-) */\n",
            "#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main(int argc, char *argv[])\n{\n\n    int num = 1234567;\n    int den = 3;\n    div_t r = div(num,den); // div() is a standard C function.\n    printf(\"%d\\n\", r.quot);\n\n    return 0;\n}\n",
            "#include &lt;stdio.h&gt;\n\nint main() {\n  int dividend = -42, divisor = 5, quotient, remainder;\n\n  __asm__ ( \"cdq; idivl %%ebx;\"\n          : \"=a\" (quotient), \"=d\" (remainder)\n          : \"a\"  (dividend), \"b\"  (divisor)\n          : );\n\n  printf(\"%i / %i = %i, remainder: %i\\n\", dividend, divisor, quotient, remainder);\n  return 0;\n}\n",
            "// Note: itoa is non-standard but actual implementations\n// don't seem to handle negative when base != 10.\nint div3(int i) {\n    char str[42];\n    sprintf(str, \"%d\", INT_MIN); // Put minus sign at str[0]\n    if (i&gt;0)                     // Remove sign if positive\n        str[0] = ' ';\n    itoa(abs(i), &amp;str[1], 3);    // Put ternary absolute value starting at str[1]\n    str[strlen(&amp;str[1])] = '\\0'; // Drop last digit\n    return strtol(str, NULL, 3); // Read back result\n}\n",
            "+\n+\nunsigned div_by(unsigned const x, unsigned const by) {\n  unsigned floor = 0;\n  for (unsigned cmp = 0, r = 0; cmp &lt;= x;) {\n    for (unsigned i = 0; i &lt; by; i++)\n      cmp++; // that's not the + operator!\n    floor = r;\n    r++; // neither is this.\n  }\n  return floor;\n}\n\ndiv_by(100,3)\n100\n3\n++\nunsigned inc(unsigned x) {\n  for (unsigned mask = 1; mask; mask &lt;&lt;= 1) {\n    if (mask &amp; x)\n      x &amp;= ~mask;\n    else\n      return x &amp; mask;\n  }\n  return 0; // overflow (note that both x and mask are 0 here)\n}\n\n+\n-\n*\n/\n%\nunsigned add(char const zero[], unsigned const x, unsigned const y) {\n  // this exploits that &amp;foo[bar] == foo+bar if foo is of type char*\n  return (int)(uintptr_t)(&amp;((&amp;zero[x])[y]));\n}\n\nunsigned div_by(unsigned const x, unsigned const by) {\n  unsigned floor = 0;\n  for (unsigned cmp = 0, r = 0; cmp &lt;= x;) {\n    cmp = add(0,cmp,by);\n    floor = r;\n    r = add(0,r,1);\n  }\n  return floor;\n}\n\nadd\n*\ntype[]\ntype* const\n0x55555556\nint mul(int const x, int const y) {\n  return sizeof(struct {\n    char const ignore[y];\n  }[x]);\n}\n",
            "public static int div_by_3(long a) {\n    a &lt;&lt;= 30;\n    for(int i = 2; i &lt;= 32 ; i &lt;&lt;= 1) {\n        a = add(a, a &gt;&gt; i);\n    }\n    return (int) (a &gt;&gt; 32);\n}\n\npublic static long add(long a, long b) {\n    long carry = (a &amp; b) &lt;&lt; 1;\n    long sum = (a ^ b);\n    return carry == 0 ? sum : add(carry, sum);\n}\n\n1/3 = 1/4 + 1/16 + 1/64 + ...\n\na/3 = a * 1/3  \na/3 = a * (1/4 + 1/16 + 1/64 + ...)\na/3 = a/4 + a/16 + 1/64 + ...\na/3 = a &gt;&gt; 2 + a &gt;&gt; 4 + a &gt;&gt; 6 + ...\n\n11 + 6\n\n1011 + 0110  \nsum = 1011 ^ 0110 = 1101  \ncarry = (1011 &amp; 0110) &lt;&lt; 1 = 0010 &lt;&lt; 1 = 0100  \nNow you recurse!\n\n1101 + 0100  \nsum = 1101 ^ 0100 = 1001  \ncarry = (1101 &amp; 0100) &lt;&lt; 1 = 0100 &lt;&lt; 1 = 1000  \nAgain!\n\n1001 + 1000  \nsum = 1001 ^ 1000 = 0001  \ncarry = (1001 &amp; 1000) &lt;&lt; 1 = 1000 &lt;&lt; 1 = 10000  \nOne last time!\n\n0001 + 10000\nsum = 0001 ^ 10000 = 10001 = 17  \ncarry = (0001 &amp; 10000) &lt;&lt; 1 = 0\n\nDone!\n\n111\n 1011\n+0110\n-----\n10001\n\na / 3 = a/4 + a/4^2 + a/4^3 + ... + a/4^i + ... = f(a, i) + a * 1/3 * 1/4^i\nf(a, i) = a/4 + a/4^2 + ... + a/4^i\n\ndiv_by_3(a)\nx &lt;= floor(f(a, i)) &lt; a / 3\na = 3k",
            "0x55555556",
            "public static int DivideBy3(int a) {\n    bool negative = a &lt; 0;\n    if (negative) a = Negate(a);\n    int result;\n    int sub = 3 &lt;&lt; 29;\n    int threes = 1 &lt;&lt; 29;\n    result = 0;\n    while (threes &gt; 0) {\n        if (a &gt;= sub) {\n            a = Add(a, Negate(sub));\n            result = Add(result, threes);\n        }\n        sub &gt;&gt;= 1;\n        threes &gt;&gt;= 1;\n    }\n    if (negative) result = Negate(result);\n    return result;\n}\npublic static int Negate(int a) {\n    return Add(~a, 1);\n}\npublic static int Add(int a, int b) {\n    int x = 0;\n    x = a ^ b;\n    while ((a &amp; b) != 0) {\n        b = (a &amp; b) &lt;&lt; 1;\n        a = x;\n        x = a ^ b;\n    }\n    return x;\n}\n",
            "if (number == 0) return 0;\nif (number == 1) return 0;\nif (number == 2) return 0;\nif (number == 3) return 1;\nif (number == 4) return 1;\nif (number == 5) return 1;\nif (number == 6) return 2;\n\n/",
            "int DivBy3(int num) {\n    int result = 0;\n    int counter = 0;\n    while (1) {\n        if (num == counter)       //Modulus 0\n            return result;\n        counter = abs(~counter);  //++counter\n\n        if (num == counter)       //Modulus 1\n            return result;\n        counter = abs(~counter);  //++counter\n\n        if (num == counter)       //Modulus 2\n            return result;\n        counter = abs(~counter);  //++counter\n\n        result = abs(~result);    //++result\n    }\n}\n",
            "#include &lt;stdio.h&gt;\n#include &lt;stdint.h&gt;\n\nint main()\n{\n  uint32_t mod3[6] = { 0,1,2,0,1,2 };\n  uint32_t x = 1234567; // number to divide, and remainder at the end\n  uint32_t y = 0; // result\n  int bit = 31; // current bit\n  printf(\"X=%u   X/3=%u\\n\",x,x/3); // the '/3' is for testing\n\n  while (bit&gt;0)\n  {\n    printf(\"BIT=%d  X=%u  Y=%u\\n\",bit,x,y);\n    // decrement bit\n    int h = 1; while (1) { bit ^= h; if ( bit&amp;h ) h &lt;&lt;= 1; else break; }\n    uint32_t r = x&gt;&gt;bit;  // current remainder in 0..5\n    x ^= r&lt;&lt;bit;          // remove R bits from X\n    if (r &gt;= 3) y |= 1&lt;&lt;bit; // new output bit\n    x |= mod3[r]&lt;&lt;bit;    // new remainder inserted in X\n  }\n  printf(\"Y=%u\\n\",y);\n}\n",
            "DIV\nfp-compiler\ndivide_by_3.pas\nunit Divide_By_3;\ninterface\n    function div_by_3(n: integer): integer; cdecl; export;\nimplementation\n    function div_by_3(n: integer): integer; cdecl;\n    begin\n        div_by_3 := n div 3;\n    end;\nend.\n\nmain.c\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nextern int div_by_3(int n);\n\nint main(void) {\n    int n;\n    fputs(\"Enter a number: \", stdout);\n    fflush(stdout);\n    scanf(\"%d\", &amp;n);\n    printf(\"%d / 3 = %d\\n\", n, div_by_3(n));\n    return 0;\n}\n\nfpc divide_by_3.pas &amp;&amp; gcc divide_by_3.o main.c -o main\n\n$ ./main\nEnter a number: 100\n100 / 3 = 33\n",
            "int div3(int x)\n{\n  int reminder = abs(x);\n  int result = 0;\n  while(reminder &gt;= 3)\n  {\n     result++;\n\n     reminder--;\n     reminder--;\n     reminder--;\n  }\n  return result;\n}\n",
            "#include &lt;stdio.h&gt;\n\nint main()\n{\n    int aNumber = 500;\n    int gResult = 0;\n\n    int aLoop = 0;\n\n    int i = 0;\n    for(i = 0; i &lt; aNumber; i++)\n    {\n        if(aLoop == 3)\n        {\n           gResult++;\n           aLoop = 0;\n        }  \n        aLoop++;\n    }\n\n    printf(\"Reulst of %d / 3 = %d\", aNumber, gResult);\n\n    return 0;\n}\n",
            "#include &lt;stdio.h&gt;\n\nunsigned sub(unsigned two, unsigned one);\nunsigned bitdiv(unsigned top, unsigned bot);\nunsigned sub(unsigned two, unsigned one)\n{\nunsigned bor;\nbor = one;\ndo      {\n        one = ~two &amp; bor;\n        two ^= bor;\n        bor = one&lt;&lt;1;\n        } while (one);\nreturn two;\n}\n\nunsigned bitdiv(unsigned top, unsigned bot)\n{\nunsigned result, shift;\n\nif (!bot || top &lt; bot) return 0;\n\nfor(shift=1;top &gt;= (bot&lt;&lt;=1); shift++) {;}\nbot &gt;&gt;= 1;\n\nfor (result=0; shift--; bot &gt;&gt;= 1 ) {\n        result &lt;&lt;=1;\n        if (top &gt;= bot) {\n                top = sub(top,bot);\n                result |= 1;\n                }\n        }\nreturn result;\n}\n\nint main(void)\n{\nunsigned arg,val;\n\nfor (arg=2; arg &lt; 40; arg++) {\n        val = bitdiv(arg,3);\n        printf(\"Arg=%u Val=%u\\n\", arg, val);\n        }\nreturn 0;\n}\n",
            "/\neval\nfunction div3 (n) {\n    var div = String.fromCharCode(47);\n    return eval([n, div, 3].join(\"\"));\n}\n",
            "irb(main):101:0&gt; div3 = -&gt; n { s = '%0' + n.to_s + 's'; (s % '').gsub('   ', ' ').size }\n=&gt; #&lt;Proc:0x0000000205ae90@(irb):101 (lambda)&gt;\nirb(main):102:0&gt; div3[12]\n=&gt; 4\nirb(main):103:0&gt; div3[666]\n=&gt; 222\n\nC",
            "&lt;?php\n    $a = 12345;\n    $b = bcdiv($a, 3);   \n?&gt;\n\n&gt; SELECT 12345 DIV 3;\n\na:= 12345;\nb:= a div 3;\n\nmov  r8, 3\nxor  rdx, rdx   \nmov  rax, 12345\nidiv r8\n",
            "int divideByThree(int num)\n{\n  return (fma(num, 1431655766, 0) &gt;&gt; 32);\n}\n\nmath.h",
            "* / + - %\n#!/usr/bin/env python3\n\nprint('''#include &lt;stdint.h&gt;\n#include &lt;stdio.h&gt;\nconst int32_t div_by_3(const int32_t input)\n{\n''')\n\nfor i in range(-2**31, 2**31):\n    print('    if(input == %d) return %d;' % (i, i / 3))\n\n\nprint(r'''\n    return 42; // impossible\n}\nint main()\n{\n    const int32_t number = 8;\n    printf(\"%d / 3 = %d\\n\", number, div_by_3(number));\n}\n''')\n",
            "x/3 = (x/4) / (1-1/4)\n\nx/(1-1/y)\n  = x * (1+y) / (1-y^2)\n  = x * (1+y) * (1+y^2) / (1-y^4)\n  = ...\n  = x * (1+y) * (1+y^2) * (1+y^4) * ... * (1+y^(2^i)) / (1-y^(2^(i+i))\n  = x * (1+y) * (1+y^2) * (1+y^4) * ... * (1+y^(2^i))\n\nint div3(int x) {\n    x &lt;&lt;= 6;    // need more precise\n    x += x&gt;&gt;2;  // x = x * (1+(1/2)^2)\n    x += x&gt;&gt;4;  // x = x * (1+(1/2)^4)\n    x += x&gt;&gt;8;  // x = x * (1+(1/2)^8)\n    x += x&gt;&gt;16; // x = x * (1+(1/2)^16)\n    return (x+1)&gt;&gt;8; // as (1-(1/2)^32) very near 1,\n                     // we plus 1 instead of div (1-(1/2)^32)\n}\n\n+",
            "#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\n\nint main()\n{\n    int number = 8;//Any +ve no.\n    int temp = 3, result = 0;\n    while(temp &lt;= number){\n        temp = fma(temp, 1, 3); //fma(a, b, c) is a library function and returns (a*b) + c.\n        result = fma(result, 1, 1);\n    } \n    printf(\"\\n\\n%d divided by 3 = %d\\n\", number, result);\n}\n",
            "private int dividedBy3(int n) {\n        List&lt;Object&gt; a = new Object[n].ToList();\n        List&lt;Object&gt; b = new List&lt;object&gt;();\n        while (a.Count &gt; 2) {\n            a.RemoveRange(0, 3);\n            b.Add(new Object());\n        }\n        return b.Count;\n    }\n",
            "[02:31:59] [william@relativity ~]$ cat div3.c\n#import &lt;stdio.h&gt;\n#import &lt;Accelerate/Accelerate.h&gt;\n\nint main() {\n    float multiplicand = 123456.0;\n    float multiplier = 0.333333;\n    printf(\"%f * %f == \", multiplicand, multiplier);\n    cblas_sscal(1, multiplier, &amp;multiplicand, 1);\n    printf(\"%f\\n\", multiplicand);\n}\n\n[02:32:07] [william@relativity ~]$ clang div3.c -framework Accelerate -o div3 &amp;&amp; ./div3\n123456.000000 * 0.333333 == 41151.957031\n",
            "log(pow(exp(numerator),pow(denominator,-1)))",
            "with Ada.Text_IO;\n\nprocedure Divide_By_3 is\n\n   protected type Divisor_Type is\n      entry Poke;\n      entry Finish;\n   private\n      entry Release;\n      entry Stop_Emptying;\n      Emptying : Boolean := False;\n   end Divisor_Type;\n\n   protected type Collector_Type is\n      entry Poke;\n      entry Finish;\n   private\n      Emptying : Boolean := False;\n   end Collector_Type;\n\n   task type Input is\n   end Input;\n   task type Output is\n   end Output;\n\n   protected body Divisor_Type is\n      entry Poke when not Emptying and Stop_Emptying'Count = 0 is\n      begin\n         requeue Release;\n      end Poke;\n      entry Release when Release'Count &gt;= 3 or Emptying is\n         New_Output : access Output;\n      begin\n         if not Emptying then\n            New_Output := new Output;\n            Emptying := True;\n            requeue Stop_Emptying;\n         end if;\n      end Release;\n      entry Stop_Emptying when Release'Count = 0 is\n      begin\n         Emptying := False;\n      end Stop_Emptying;\n      entry Finish when Poke'Count = 0 and Release'Count &lt; 3 is\n      begin\n         Emptying := True;\n         requeue Stop_Emptying;\n      end Finish;\n   end Divisor_Type;\n\n   protected body Collector_Type is\n      entry Poke when Emptying is\n      begin\n         null;\n      end Poke;\n      entry Finish when True is\n      begin\n         Ada.Text_IO.Put_Line (Poke'Count'Img);\n         Emptying := True;\n      end Finish;\n   end Collector_Type;\n\n   Collector : Collector_Type;\n   Divisor : Divisor_Type;\n\n   task body Input is\n   begin\n      Divisor.Poke;\n   end Input;\n\n   task body Output is\n   begin\n      Collector.Poke;\n   end Output;\n\n   Cur_Input : access Input;\n\n   -- Input value:\n   Number : Integer := 18;\nbegin\n   for I in 1 .. Number loop\n      Cur_Input := new Input;\n   end loop;\n   Divisor.Finish;\n   Collector.Finish;\nend Divide_By_3;\n"
        ]
    },
    {
        "question_id": 2649334,
        "question_code": "",
        "answer_code_snippets": [
            "-------------------------------------------------------------------------\n|  +-  |    Shared(dynamic)       |   Static Library (Linkages)         |\n-------------------------------------------------------------------------\n|Pros: | less memory use          |   an executable, using own libraries|\n|      |                          |     ,coming with the program,       |\n|      |                          |   doesn't need to worry about its   |\n|      |                          |   compilebility subject to libraries|\n-------------------------------------------------------------------------\n|Cons: | implementations of       |   bigger memory uses                |\n|      | libraries may be altered |                                     |\n|      | subject to OS  and its   |                                     |\n|      | version, which may affect|                                     |\n|      | the compilebility and    |                                     |\n|      | runnability of the code  |                                     |\n-------------------------------------------------------------------------\n"
        ]
    },
    {
        "question_id": 558122,
        "question_code": "static\nstatic\nstatic\nvoid print_matrix\na.c\na.h\n\"a.c\"\n\"print_matrix@@....) already defined in a.obj\"\nstatic void print_matrix\n.c\nmain.c\n.h\n.c",
        "answer_code_snippets": [
            "static\nC\nstatic",
            "static\n#include &lt;stdio.h&gt;\n\n/* Undefined behavior: already defined in main.\n * Binutils 2.24 gives an error and refuses to link.\n * https://stackoverflow.com/questions/27667277/why-does-borland-compile-with-multiple-definitions-of-same-object-in-different-c\n */\n/*void f() { puts(\"a f\"); }*/\n\n/* OK: only declared, not defined. Will use the one in main. */\nvoid f(void);\n\n/* OK: only visible to this file. */\nstatic void sf() { puts(\"a sf\"); }\n\nvoid a() {\n    f();\n    sf();\n}\n\n#include &lt;stdio.h&gt;\n\nvoid a(void);        \n\nvoid f() { puts(\"main f\"); }\n\nstatic void sf() { puts(\"main sf\"); }\n\nvoid m() {\n    f();\n    sf();\n}\n\nint main() {\n    m();\n    a();\n    return 0;\n}\n\ngcc -c a.c -o a.o\ngcc -c main.c -o main.o\ngcc -o main main.o a.o\n./main\n\nmain f\nmain sf\nmain f\na sf\n\nsf\nf\nstatic\nstatic\nthis\nstatic\nstatic\ninternal linkage\ninternal linkage\nSTB_LOCAL\nint f() { return 0; }\nstatic int sf() { return 0; }\n\nreadelf -s main.o\n\nNum:    Value          Size Type    Bind   Vis      Ndx Name\n  5: 000000000000000b    11 FUNC    LOCAL  DEFAULT    1 sf\n  9: 0000000000000000    11 FUNC    GLOBAL DEFAULT    1 f\n\nValue\n.bss\nSTB_LOCAL\nstatic\nSTB_GLOBAL\n-O3\nsf\nextern\nstatic\nextern",
            "add(int a, b)",
            ".cpp\nstatic functions\nstatic member function",
            "static\nexternal\n.c\n.cpp\nstatic\nstatic\n.c\n.cpp\nstatic\nstatic\nstatic\nstatic",
            "Person* tom = new Person();\ntom-&gt;setName(\"Tom\");\n\nPerson* tom = Person::createNewPerson();\n",
            "#include &lt;stdio.h&gt;\n\nstatic void test() \n{\n    ghost(); // This is an unexist function.\n}\n\nint main()\n{\n    int ret = 0;\n\n#ifdef TEST\n#else\n    test();\n#endif\n    return (ret);\n} \n\ngcc -o main main.c\n\ngcc -DTEST -O2 -o main main.c\n"
        ]
    },
    {
        "question_id": 5431941,
        "question_code": "feof()\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint\nmain(int argc, char **argv)\n{\n    char *path = &quot;stdin&quot;;\n    FILE *fp = argc &gt; 1 ? fopen(path=argv[1], &quot;r&quot;) : stdin;\n\n    if( fp == NULL ){\n        perror(path);\n        return EXIT_FAILURE;\n    }\n\n    while( !feof(fp) ){  /* THIS IS WRONG */\n        /* Read and process data from fileâ¦ */\n    }\n    if( fclose(fp) != 0 ){\n        perror(path);\n        return EXIT_FAILURE;\n    }\n    return EXIT_SUCCESS;\n}\n",
        "answer_code_snippets": [
            "while(!feof(file))\nwhile(!feof(file))\n  for (;;) {\n      size_t n = fread(buf, 1, bufsize, infile);\n      consume(buf, n);\n      if (n == 0) { break; }\n  }\n\nn\nscanf\n  for (int a, b, c; scanf(&quot;%d %d %d&quot;, &amp;a, &amp;b, &amp;c) == 3; ) {\n      consume(a, b, c);\n  }\n\nscanf\n  for (int n; std::cin &gt;&gt; n; ) {\n      consume(n);\n  }\n\nstd::cin\ngood()\n  for (std::string line; std::getline(std::cin, line); ) {\n      consume(line);\n  }\n\nstd::cin\nwrite(2)\n  char const * p = buf;\n  ssize_t n = bufsize;\n  for (ssize_t k = bufsize; (k = write(fd, p, n)) &gt; 0; p += k, n -= k) {}\n  if (n != 0) { /* error, failed to write complete buffer */ }\n\nk\ngetline()\n  char *buffer = NULL;\n  size_t bufsiz = 0;\n  ssize_t nbytes;\n  while ((nbytes = getline(&amp;buffer, &amp;bufsiz, fp)) != -1)\n  {\n      /* Use nbytes of data in buffer */\n  }\n  free(buffer);\n\nnbytes\n-1\n  std::string input = &quot;   123   &quot;;   // example\n\n  std::istringstream iss(input);\n  int value;\n  if (iss &gt;&gt; value &gt;&gt; std::ws &amp;&amp; iss.get() == EOF) {\n      consume(value);\n  } else {\n      // error, &quot;input&quot; is not parsable as an integer\n  }\n\niss\nvalue\niss.get()\nstrto*l",
            "/* WARNING: demonstration of bad coding technique!! */\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nFILE *Fopen(const char *path, const char *mode);\n\nint\nmain(int argc, char **argv)\n{\n    FILE *in = argc &gt; 1 ? Fopen(argv[1], &quot;r&quot;) : stdin;\n    unsigned count = 0;\n\n    /* WARNING: this is a bug */\n    while( !feof(in) ) {  /* This is WRONG! */\n        fgetc(in);\n        count++;\n    }\n    printf(&quot;Number of characters read: %u\\n&quot;, count);\n    return EXIT_SUCCESS;\n}\n\nFILE *\nFopen(const char *path, const char *mode)\n{\n    FILE *f = fopen(path, mode);\n    if( f == NULL ) {\n        perror(path);\n        exit(EXIT_FAILURE);\n    }\n    return f;\n}\n\n$ ./a.out &lt; /dev/null\nNumber of characters read: 1\n\nfeof()\nfgetc()\nEOF\nfeof()\nfeof()\nfeof()\nfeof()\nfread()\nfeof\nferror\nfgetc\nEOF\nfeof()\nfgetc\nEOF\nfeof()\nfread()\nfscanf()\nfgetc()\nfeof()\nfgetc()\nEOF\nfeof()\nwhile(!feof(p))\nferror()\nwhile(!feof(p) &amp;&amp; !ferror(p))\nwhile(!feof(f))\nfeof\nferror\n#include &lt;assert.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint\nmain(int argc, char **argv)\n{\n    FILE *in = stdin;\n    unsigned count = 0;\n\n    while( getc(in) != EOF ){\n        count++;\n    }\n    if( feof(in) ){\n        printf(&quot;Number of characters read: %u\\n&quot;, count);\n    } else if( ferror(in) ){\n        perror(&quot;stdin&quot;);\n    } else {\n        assert(0);\n    }\n    return EXIT_SUCCESS;\n}\n",
            "while (!feof(f))\nwhile (!feof(f))",
            "feof()\nwhile (fgets(line, sizeof(line), file)) {\n    /* note that fgets don't strip the terminating \\n, checking its\n       presence allow to handle lines longer that sizeof(line), not showed here */\n    ...\n}\nif (ferror(file)) {\n   /* IO failure */\n} else if (feof(file)) {\n   /* format error (not possible with fgets, but would be with fscanf) or end of file */\n} else {\n   /* format error (not possible with fgets, but would be with fscanf) */\n}\n",
            "feof(F)\nF\nF\nEOF\n^D\nfeof",
            "feof()\nFILE\ntrue\nfgetc()\n#include &lt;stdio.h&gt;\n\nint main(int argc, char *argv[])\n{\n  FILE *in = fopen(\"testfile.txt\", \"r\");\n\n  while(1) {\n    char c = fgetc(in);\n    if (feof(in)) break;\n    printf(\"%c\", c);\n  }\n\n  fclose(in);\n  return 0;\n}\n\n#include &lt;stdio.h&gt;\n\nint main(int argc, char *argv[])\n{\n  FILE *in = fopen(\"testfile.txt\", \"r\");\n\n  while(!feof(in)) {\n    printf(\"%c\", fgetc(in));\n  }\n\n  fclose(in);\n  return 0;\n}\n"
        ]
    },
    {
        "question_id": 1674032,
        "question_code": "static const int var = 5;\n\n#define var 5\n\nenum { var = 5 };\n",
        "answer_code_snippets": [
            "static const int var = 5;\n#define var 5\nenum { var = 5 };",
            "static const\n\n#ifdef VAR // Very bad name, not long enough, too general, etc..\n  static int const var = VAR;\n#else\n  static int const var = 5; // default value\n#endif\n\n__FILE__\n__LINE__",
            "#define\nenum\nconst\nconst\nconst int\ncase\nconst int\nconst\nconst\n#define\nenum\nconst\nconst\nstatic",
            "static const\n#define\n#define\nstatic const",
            "#define\n#define MAXLEN 5\n\nvoid foo(void) {\n   int bar[MAXLEN];\n}\n\nstatic const\nconst int maxlen = 5;\n\nvoid foo() {\n   int bar[maxlen];\n}\n\nstatic\nconst",
            "const\nconst\nstatic int const NUMBER_OF_FINGERS_PER_HAND = 5;\nstatic int const NUMBER_OF_HANDS = 2;\n\n// initializer element is not constant, this does not work.\nstatic int const NUMBER_OF_FINGERS = NUMBER_OF_FINGERS_PER_HAND \n                                     * NUMBER_OF_HANDS;\n\nstatic uint8_t const ARRAY_SIZE = 16;\nstatic int8_t const lookup_table[ARRAY_SIZE] = {\n    1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16}; // ARRAY_SIZE not a constant!\n\nconst",
            "static const\n#define var 5\nint foo[var];\nstatic const int var = 5;\nstatic const\n#define\n#define",
            "#define PI 3.1416\n\nconst double PI = 3.1416; //or static const...\n",
            "#define var 5\nmystruct.var\nstruct mystruct {\n    int var;\n};\n\n#define var 5\n\nint main() {\n    struct mystruct foo;\n    foo.var = 1;\n    return 0;\n}\n\n#define",
            "#include &lt;stdio.h&gt;\n\nenum {ENUM_DEFINED=16};\nenum {ENUM_DEFINED=32};\n\n#define DEFINED_DEFINED 16\n#define DEFINED_DEFINED 32\n\nint main(int argc, char *argv[]) {\n\n   printf(\"%d, %d\\n\", DEFINED_DEFINED, ENUM_DEFINED);\n\n   return(0);\n}\n\nmain.c:6:7: error: redefinition of enumerator 'ENUM_DEFINED'\nenum {ENUM_DEFINED=32};\n      ^\nmain.c:5:7: note: previous definition is here\nenum {ENUM_DEFINED=16};\n      ^\nmain.c:9:9: warning: 'DEFINED_DEFINED' macro redefined [-Wmacro-redefined]\n#define DEFINED_DEFINED 32\n        ^\nmain.c:8:9: note: previous definition is here\n#define DEFINED_DEFINED 16\n        ^\n",
            "const int const_value = 5;\n\nconst int const_value = 5;\nint *mutable_value = (int*) &amp;const_value;\n*mutable_value = 3;\nprintf(\"%i\", const_value); // The output may be 5 or 3, depending on the compiler.\n\n#define CONST_VALUE 5\n",
            "static const\n#define",
            "#define\nenum {number_ten = 10};\n",
            "#define mymax 100\n\nprintf(\"address of constant is %p\",&amp;mymax);\nconst int mymax_var=100\n\nprintf(\"address of constant is %p\",&amp;mymax_var);",
            "const int\n#define",
            "#define\n#define\n#define myValue 7\nmyValue\n7"
        ]
    }
]