[
    {
        "question_id": 1642028,
        "question_code": "comp.lang.c++.moderated\n#include &lt;stdio.h&gt;\nint main()\n{\n    int x = 10;\n    while (x --&gt; 0) // x goes to 0\n    {\n        printf(&quot;%d &quot;, x);\n    }\n}\n\n9 8 7 6 5 4 3 2 1 0\n",
        "answer_code_snippets": [
            "--&gt;\n--\n&gt;\nx\nx\n0\n&gt;\nwhile( (x--) &gt; 0 )\n",
            "x\n0\nwhile (x --\\\n            \\\n             \\\n              \\\n               &gt; 0)\n     printf(\"%d \", x);\n",
            "--\n&gt;",
            "x\nint x = 10;\n\nwhile( 0 &lt;---- x )\n{\n   printf(&quot;%d &quot;, x);\n}\n\n8 6 4 2 \nint x = 100;\n\nwhile( 0 &lt;-------------------- x )\n{\n   printf(&quot;%d &quot;, x);\n}\n\n90 80 70 60 50 40 30 20 10 ",
            "while (x-- &gt; 0)\n\nx--\nx = x-1\nx\nwhile(x &gt; 0) {\n    x = x-1;\n    // logic\n}\nx--;   // The post decrement done when x &lt;= 0\n",
            "#include &lt;stdio.h&gt;\n\nint main(void) {\n    int x = 10;\n    while (x-- &gt; 0) { // x goes to 0\n        printf(&quot;%d &quot;, x);\n    }\n    return 0;\n}\n\n--\n&gt;",
            "--&gt;\n--&gt;\nx\n0",
            "#define as ;while\n\nint main(int argc, char* argv[])\n{\n    int n = atoi(argv[1]);\n    do printf(\"n is %d\\n\", n) as ( n --&gt; 0);\n    return 0;\n}\n",
            "x--&gt;0\n\ntoken 1: x\ntoken 2: --\ntoken 3: &gt;\ntoken 4: 0\nconclude: x-- &gt; 0\n\na-----b\n\ntoken 1: a\ntoken 2: --\ntoken 3: --\ntoken 4: -\ntoken 5: b\nconclude: (a--)-- - b\n",
            "while(x--)",
            "\"--&gt;\"\n\"for (x = 10; x &gt; 0; x --)\"",
            "&gt;\n9 8 7 6 5 4 3 2 1 0\n\n#include &lt;stdio.h&gt;\nint main(void)\n{\n    int x = 10;\n\n    while( --x&gt; 0 ) // x goes to 0\n    {\n        printf(\"%d \", x);\n    }\n    return 0;\n}\n\n9 8 7 6 5 4 3 2 1\n",
            "#include &lt;iostream&gt;\nint main()\n{\n    int x = 10;\n\n    while( x --&gt; 0 ) // x goes to 0\n    {\n        std::cout &lt;&lt; x;\n    }\n}\n\nwhile( x-- &gt; 0 )\nwhile( x &gt; 0)\nx--\nx\nwhile( x &gt; 0 ) \n{\n    x--;\n    std::cout &lt;&lt; x;\n}\n",
            "--\n&gt;\nx\nx&gt;0 ?",
            "--\n&gt;\n--&gt;",
            "--\n&gt;\n#include&lt;stdio.h&gt;\n\nint main()\n{\n    int x = 10;\n\n    while (x-- &gt; 0)\n        printf(&quot;%d &quot;,x);\n\n    return 0;\n}\n\n9 8 7 6 5 4 3 2 1 0            \n",
            "a---b\n(a--) - b\nx--&gt;0\n(x--)&gt;0",
            "x\n--&gt;\n(x--) &gt; 0\nx\n--&gt;    x--&gt;0\n++&gt;    x++&gt;0\n--&gt;=   x--&gt;=0\n++&gt;=   x++&gt;=0\n",
            "int x = 10;\nwhile( --x&gt; 0 )\n    printf(&quot;%d &quot;, x);\n",
            "#include &lt;stdio.h&gt;\n\nint main() {\n    int x = 10;\n    while (x &gt; 0) {\n        printf(&quot;%d &quot;, x);\n        x = x - 1;\n    }\n}\n\nx--\n&gt;\noperator",
            "()\n{}\n--\n&gt;\nint abc(){\n    int a = 5\n    while((a--) &gt; 0){ // Decrement and comparison both at once\n        // Code\n    }\n}\n\na\na\n0\nint abc() {\n    int a = 5;\n    while(a &gt; 0) {\n        a = a -1 // Decrement inside loop\n        // Code\n    }\n}\n",
            "(x --&gt; 0)\n(x-- &gt; 0)\n(x --&gt;)\nOutput: 9 8 7 6 5 4 3 2 1 0\n(-- x &gt; 0)\n(--x &gt; 0)\nOutput: 9 8 7 6 5 4 3 2 1\n(--\\\n    \\\n     x &gt; 0)\n\nOutput:  9 8 7 6 5 4 3 2 1\n(\\\n  \\\n   x --&gt; 0)\n\nOutput: 9 8 7 6 5 4 3 2 1 0\n(\\\n  \\\n   x --&gt; 0\n          \\\n           \\\n            )\n\nOutput: 9 8 7 6 5 4 3 2 1 0\n(\n x \n  --&gt; \n      0\n       )\n\nOutput: 9 8 7 6 5 4 3 2 1 0",
            "--&gt;\n--\n&gt;\n#include &lt;stdio.h&gt;\nint main() {\n    int x = 10;\n    while (x-- &gt; 0) { // x goes to 0\n        printf(&quot;%d &quot;, x);\n    }\n}\n\n10\n0\n10\n0\nx\nx\n-1\nx\nsize_t\nfor (i = length-1; i &gt;= 0; i--)\nwhile (x --&gt; 0)\nfor (;;)\nwhile (1)\nwhile (l)",
            "--&gt;\n-&gt;\n--&gt;\nwhile(x-- &gt;0)\nwhile(x--)\n0",
            "--\n while (x-- &gt; 0) // x goes to 0\n {\n     printf(&quot;%d &quot;, x);\n }\n\n(x &gt; 0) // 10 &gt; 0\nx-- // x = 9\nx=1\nx = 0\nx = 0\n(x &gt; 0 )",
            "while((x--) &gt; 0)\n"
        ]
    },
    {
        "question_id": 1711631,
        "question_code": "/*************************************************************\n    Baseline code to experiment with SQLite performance.\n\n    Input data is a 28 MB TAB-delimited text file of the\n    complete Toronto Transit System schedule/route info\n    from http://www.toronto.ca/open/datasets/ttc-routes/\n\n**************************************************************/\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;time.h&gt;\n#include &lt;string.h&gt;\n#include &quot;sqlite3.h&quot;\n\n#define INPUTDATA &quot;C:\\\\TTC_schedule_scheduleitem_10-27-2009.txt&quot;\n#define DATABASE &quot;c:\\\\TTC_schedule_scheduleitem_10-27-2009.sqlite&quot;\n#define TABLE &quot;CREATE TABLE IF NOT EXISTS TTC (id INTEGER PRIMARY KEY, Route_ID TEXT, Branch_Code TEXT, Version INTEGER, Stop INTEGER, Vehicle_Index INTEGER, Day Integer, Time TEXT)&quot;\n#define BUFFER_SIZE 256\n\nint main(int argc, char **argv) {\n\n    sqlite3 * db;\n    sqlite3_stmt * stmt;\n    char * sErrMsg = 0;\n    char * tail = 0;\n    int nRetCode;\n    int n = 0;\n\n    clock_t cStartClock;\n\n    FILE * pFile;\n    char sInputBuf [BUFFER_SIZE] = &quot;\\0&quot;;\n\n    char * sRT = 0;  /* Route */\n    char * sBR = 0;  /* Branch */\n    char * sVR = 0;  /* Version */\n    char * sST = 0;  /* Stop Number */\n    char * sVI = 0;  /* Vehicle */\n    char * sDT = 0;  /* Date */\n    char * sTM = 0;  /* Time */\n\n    char sSQL [BUFFER_SIZE] = &quot;\\0&quot;;\n\n    /*********************************************/\n    /* Open the Database and create the Schema */\n    sqlite3_open(DATABASE, &amp;db);\n    sqlite3_exec(db, TABLE, NULL, NULL, &amp;sErrMsg);\n\n    /*********************************************/\n    /* Open input file and import into Database*/\n    cStartClock = clock();\n\n    pFile = fopen (INPUTDATA,&quot;r&quot;);\n    while (!feof(pFile)) {\n\n        fgets (sInputBuf, BUFFER_SIZE, pFile);\n\n        sRT = strtok (sInputBuf, &quot;\\t&quot;);     /* Get Route */\n        sBR = strtok (NULL, &quot;\\t&quot;);            /* Get Branch */\n        sVR = strtok (NULL, &quot;\\t&quot;);            /* Get Version */\n        sST = strtok (NULL, &quot;\\t&quot;);            /* Get Stop Number */\n        sVI = strtok (NULL, &quot;\\t&quot;);            /* Get Vehicle */\n        sDT = strtok (NULL, &quot;\\t&quot;);            /* Get Date */\n        sTM = strtok (NULL, &quot;\\t&quot;);            /* Get Time */\n\n        /* ACTUAL INSERT WILL GO HERE */\n\n        n++;\n    }\n    fclose (pFile);\n\n    printf(&quot;Imported %d records in %4.2f seconds\\n&quot;, n, (clock() - cStartClock) / (double)CLOCKS_PER_SEC);\n\n    sqlite3_close(db);\n    return 0;\n}\n\nsprintf(sSQL, &quot;INSERT INTO TTC VALUES (NULL, '%s', '%s', '%s', '%s', '%s', '%s', '%s')&quot;, sRT, sBR, sVR, sST, sVI, sDT, sTM);\nsqlite3_exec(db, sSQL, NULL, NULL, &amp;sErrMsg);\n\nsqlite3_exec(db, &quot;BEGIN TRANSACTION&quot;, NULL, NULL, &amp;sErrMsg);\n\npFile = fopen (INPUTDATA,&quot;r&quot;);\nwhile (!feof(pFile)) {\n\n    ...\n\n}\nfclose (pFile);\n\nsqlite3_exec(db, &quot;END TRANSACTION&quot;, NULL, NULL, &amp;sErrMsg);\n\nsqlite3_prepare_v2\nsqlite3_bind_text\n/* Open input file and import into the database */\ncStartClock = clock();\n\nsprintf(sSQL, &quot;INSERT INTO TTC VALUES (NULL, @RT, @BR, @VR, @ST, @VI, @DT, @TM)&quot;);\nsqlite3_prepare_v2(db,  sSQL, BUFFER_SIZE, &amp;stmt, &amp;tail);\n\nsqlite3_exec(db, &quot;BEGIN TRANSACTION&quot;, NULL, NULL, &amp;sErrMsg);\n\npFile = fopen (INPUTDATA,&quot;r&quot;);\nwhile (!feof(pFile)) {\n\n    fgets (sInputBuf, BUFFER_SIZE, pFile);\n\n    sRT = strtok (sInputBuf, &quot;\\t&quot;);   /* Get Route */\n    sBR = strtok (NULL, &quot;\\t&quot;);        /* Get Branch */\n    sVR = strtok (NULL, &quot;\\t&quot;);        /* Get Version */\n    sST = strtok (NULL, &quot;\\t&quot;);        /* Get Stop Number */\n    sVI = strtok (NULL, &quot;\\t&quot;);        /* Get Vehicle */\n    sDT = strtok (NULL, &quot;\\t&quot;);        /* Get Date */\n    sTM = strtok (NULL, &quot;\\t&quot;);        /* Get Time */\n\n    sqlite3_bind_text(stmt, 1, sRT, -1, SQLITE_TRANSIENT);\n    sqlite3_bind_text(stmt, 2, sBR, -1, SQLITE_TRANSIENT);\n    sqlite3_bind_text(stmt, 3, sVR, -1, SQLITE_TRANSIENT);\n    sqlite3_bind_text(stmt, 4, sST, -1, SQLITE_TRANSIENT);\n    sqlite3_bind_text(stmt, 5, sVI, -1, SQLITE_TRANSIENT);\n    sqlite3_bind_text(stmt, 6, sDT, -1, SQLITE_TRANSIENT);\n    sqlite3_bind_text(stmt, 7, sTM, -1, SQLITE_TRANSIENT);\n\n    sqlite3_step(stmt);\n\n    sqlite3_clear_bindings(stmt);\n    sqlite3_reset(stmt);\n\n    n++;\n}\nfclose (pFile);\n\nsqlite3_exec(db, &quot;END TRANSACTION&quot;, NULL, NULL, &amp;sErrMsg);\n\nprintf(&quot;Imported %d records in %4.2f seconds\\n&quot;, n, (clock() - cStartClock) / (double)CLOCKS_PER_SEC);\n\nsqlite3_finalize(stmt);\nsqlite3_close(db);\n\nreturn 0;\n\nsqlite3_clear_bindings\nsqlite3_reset\nsynchronous = OFF\n/* Open the database and create the schema */\nsqlite3_open(DATABASE, &amp;db);\nsqlite3_exec(db, TABLE, NULL, NULL, &amp;sErrMsg);\nsqlite3_exec(db, &quot;PRAGMA synchronous = OFF&quot;, NULL, NULL, &amp;sErrMsg);\n\nPRAGMA journal_mode = MEMORY\n/* Open the database and create the schema */\nsqlite3_open(DATABASE, &amp;db);\nsqlite3_exec(db, TABLE, NULL, NULL, &amp;sErrMsg);\nsqlite3_exec(db, &quot;PRAGMA journal_mode = MEMORY&quot;, NULL, NULL, &amp;sErrMsg);\n\n/* Open the database and create the schema */\nsqlite3_open(DATABASE, &amp;db);\nsqlite3_exec(db, TABLE, NULL, NULL, &amp;sErrMsg);\nsqlite3_exec(db, &quot;PRAGMA synchronous = OFF&quot;, NULL, NULL, &amp;sErrMsg);\nsqlite3_exec(db, &quot;PRAGMA journal_mode = MEMORY&quot;, NULL, NULL, &amp;sErrMsg);\n\n#define DATABASE &quot;:memory:&quot;\n\nchar*\nwhile\nstrtok()\nsqlite3_bind_text()\npFile = fopen (INPUTDATA,&quot;r&quot;);\nwhile (!feof(pFile)) {\n\n    fgets (sInputBuf, BUFFER_SIZE, pFile);\n\n    sqlite3_bind_text(stmt, 1, strtok (sInputBuf, &quot;\\t&quot;), -1, SQLITE_TRANSIENT); /* Get Route */\n    sqlite3_bind_text(stmt, 2, strtok (NULL, &quot;\\t&quot;), -1, SQLITE_TRANSIENT);    /* Get Branch */\n    sqlite3_bind_text(stmt, 3, strtok (NULL, &quot;\\t&quot;), -1, SQLITE_TRANSIENT);    /* Get Version */\n    sqlite3_bind_text(stmt, 4, strtok (NULL, &quot;\\t&quot;), -1, SQLITE_TRANSIENT);    /* Get Stop Number */\n    sqlite3_bind_text(stmt, 5, strtok (NULL, &quot;\\t&quot;), -1, SQLITE_TRANSIENT);    /* Get Vehicle */\n    sqlite3_bind_text(stmt, 6, strtok (NULL, &quot;\\t&quot;), -1, SQLITE_TRANSIENT);    /* Get Date */\n    sqlite3_bind_text(stmt, 7, strtok (NULL, &quot;\\t&quot;), -1, SQLITE_TRANSIENT);    /* Get Time */\n\n    sqlite3_step(stmt);        /* Execute the SQL Statement */\n    sqlite3_clear_bindings(stmt);    /* Clear bindings */\n    sqlite3_reset(stmt);        /* Reset VDBE */\n\n    n++;\n}\nfclose (pFile);\n\nSELECT\nsqlite3_exec(db, &quot;CREATE  INDEX 'TTC_Stop_Index' ON 'TTC' ('Stop')&quot;, NULL, NULL, &amp;sErrMsg);\nsqlite3_exec(db, &quot;BEGIN TRANSACTION&quot;, NULL, NULL, &amp;sErrMsg);\n...\n\n...\nsqlite3_exec(db, &quot;END TRANSACTION&quot;, NULL, NULL, &amp;sErrMsg);\nsqlite3_exec(db, &quot;CREATE  INDEX 'TTC_Stop_Index' ON 'TTC' ('Stop')&quot;, NULL, NULL, &amp;sErrMsg);\n",
        "answer_code_snippets": [
            "pragma journal_mode\nNORMAL\nOFF\nOFF/MEMORY\nPRAGMA page_size\nCREATE INDEX\nINTEGER PRIMARY KEY\n!feof(file)",
            "SQLITE_STATIC\nSQLITE_TRANSIENT\nSQLITE_TRANSIENT\nSQLITE_STATIC",
            "sqlite3_clear_bindings(stmt)\nsqlite3_clear_bindings",
            "SELECT COUNT(*) FROM table\n\nSELECT * FROM table ORDER BY _ROWID_ LIMIT &lt;limit&gt; OFFSET &lt;offset&gt;\n\n&lt;limit&gt;\n&lt;offset&gt;\nint limit = (count + n_threads - 1)/n_threads;\n\nint offset = thread_index * limit\n",
            "PRAGMA cache_size=10000;",
            "PRAGMA journal_mode = WAL\nINSERT\nPRAGMA auto_vacuum = 0",
            "CREATE TABLE mySEQUENCE (\n    id INTEGER PRIMARY KEY --AUTOINCREMENT\n    ,dummy INT \n);\n\n\nINSERT INTO mySEQUENCE (dummy) VALUES (1);\nSELECT last_insert_rowid(); --&gt; 1\n\nINSERT INTO mySEQUENCE (dummy) VALUES (2);\nSELECT last_insert_rowid(); --&gt; 2\n\nDELETE FROM mySEQUENCE WHERE id &gt; 1;\nSELECT last_insert_rowid(); --&gt; 2\n\nINSERT INTO mySEQUENCE (dummy) VALUES (3);\nSELECT last_insert_rowid(); --&gt; 2\n\nSELECT * FROM mySEQUENCE;\nid  dummy\n1   1\n2   3\n\nDELETE FROM mySEQUENCE; -- clean it\nINSERT INTO mySEQUENCE (dummy) VALUES (4);\nSELECT last_insert_rowid(); --&gt; 1\n\nSELECT * FROM mySEQUENCE;\nid  dummy\n1   4\n",
            "private SQLiteDatabase database;\ndatabase = dbHelper.getWritableDatabase();\n\npublic int bulkInsert(@NonNull Uri uri, @NonNull ContentValues[] values) {\n\ndatabase.beginTransaction();\n\nfor (ContentValues value : values)\n db.insert(\"TABLE_NAME\", null, value);\n\ndatabase.setTransactionSuccessful();\ndatabase.endTransaction();\n\n}\n\nApp.getAppContext().getContentResolver().bulkInsert(contentUriTable,\n            contentValuesArray);\n"
        ]
    },
    {
        "question_id": 47981,
        "question_code": "",
        "answer_code_snippets": [
            "|\nn\nnumber\n1\n// Can be whatever unsigned integer type you want, but\n// it's important to use the same type everywhere to avoid\n// performance issues caused by mixing integer types.\ntypedef unsigned long Uint;\n\n// In C++, this can be template.\n// In C11, you can make it generic with _Generic, or with macros prior to C11.\ninline Uint bit_set(Uint number, Uint n) {\n    return number | ((Uint)1 &lt;&lt; n);\n}\n\nUint\n&amp;\nn\nnumber\n0\ninline Uint bit_clear(Uint number, Uint n) {\n    return number &amp; ~((Uint)1 &lt;&lt; n);\n}\n\n~\n^\nn\nnumber\ninline Uint bit_toggle(Uint number, Uint n) {\n    return number ^ ((Uint)1 &lt;&lt; n);\n}\n\nnumber\nn\n// bool requires #include &lt;stdbool.h&gt; prior to C23\ninline bool bit_check(Uint number, Uint n) {\n    return (number &gt;&gt; n) &amp; (Uint)1;\n}\n\nbit_clear\nbit_set\ninline Uint bit_set_to(Uint number, Uint n, bool x) {\n    return (number &amp; ~((Uint)1 &lt;&lt; n)) | ((Uint)x &lt;&lt; n);\n}\n",
            "std::bitset&lt;N&gt;\nboost::dynamic_bitset\n#include &lt;bitset&gt;\n#include &lt;iostream&gt;\n\nint main()\n{\n    std::bitset&lt;5&gt; x;\n\n    x[1] = 1;\n    x[2] = 0;\n    // Note x[0-4]  valid\n\n    std::cout &lt;&lt; x &lt;&lt; std::endl;\n}\n\n./a.out\n\n00010\n",
            "struct bits {\n    unsigned int a:1;\n    unsigned int b:1;\n    unsigned int c:1;\n};\n\nstruct bits mybits;\n\nmybits.b = 1;\nmybits.c = 0;\n\nmybits.a = !mybits.a;\nmybits.b = ~mybits.b;\nmybits.c ^= 1;  /* all work */\n\nif (mybits.c)  //if mybits.c is non zero the next line below will execute\n",
            "/* a=target variable, b=bit number to act upon 0-n */\n#define BIT_SET(a,b) ((a) |= (1ULL&lt;&lt;(b)))\n#define BIT_CLEAR(a,b) ((a) &amp;= ~(1ULL&lt;&lt;(b)))\n#define BIT_FLIP(a,b) ((a) ^= (1ULL&lt;&lt;(b)))\n#define BIT_CHECK(a,b) (!!((a) &amp; (1ULL&lt;&lt;(b))))        // '!!' to make sure this returns 0 or 1\n\n#define BITMASK_SET(x, mask) ((x) |= (mask))\n#define BITMASK_CLEAR(x, mask) ((x) &amp;= (~(mask)))\n#define BITMASK_FLIP(x, mask) ((x) ^= (mask))\n#define BITMASK_CHECK_ALL(x, mask) (!(~(x) &amp; (mask)))\n#define BITMASK_CHECK_ANY(x, mask) ((x) &amp; (mask))\n",
            "enum\nenum ThingFlags = {\n  ThingMask  = 0x0000,\n  ThingFlag0 = 1 &lt;&lt; 0,\n  ThingFlag1 = 1 &lt;&lt; 1,\n  ThingError = 1 &lt;&lt; 8,\n}\n\nthingstate |= ThingFlag1;\nthingstate &amp;= ~ThingFlag0;\nif (thing &amp; ThingError) {...}\n",
            "/*\n**  Bit set, clear, and test operations\n**\n**  public domain snippet by Bob Stout\n*/\n\ntypedef enum {ERROR = -1, FALSE, TRUE} LOGICAL;\n\n#define BOOL(x) (!(!(x)))\n\n#define BitSet(arg,posn) ((arg) | (1L &lt;&lt; (posn)))\n#define BitClr(arg,posn) ((arg) &amp; ~(1L &lt;&lt; (posn)))\n#define BitTst(arg,posn) BOOL((arg) &amp; (1L &lt;&lt; (posn)))\n#define BitFlp(arg,posn) ((arg) ^ (1L &lt;&lt; (posn)))\n\n0000 0000 0000 0000 0000 0000 0000 0001 binary.\n\n0000 0000 0000 0000 0000 0001 0000 0000 binary.\n\n#define BOOL(x) (!(!(x)))\n\n#define BitSet(arg,posn) ((arg) | (1L &lt;&lt; (posn)))\n#define BitClr(arg,posn) ((arg) &amp; ~(1L &lt;&lt; (posn)))\n#define BitTst(arg,posn) BOOL((arg) &amp; (1L &lt;&lt; (posn)))\n#define BitFlp(arg,posn) ((arg) ^ (1L &lt;&lt; (posn)))\n\nint bitmanip(int word)\n{\n      word = BitSet(word, 2);\n      word = BitSet(word, 7);\n      word = BitClr(word, 3);\n      word = BitFlp(word, 9);\n      return word;\n}\n\n----[ TEST.OUT (disassembled) ]-----------------------------------------------\n\nModule: C:\\BINK\\tst.c\nGroup: 'DGROUP' CONST,CONST2,_DATA,_BSS\n\nSegment: _TEXT  BYTE   00000008 bytes\n 0000  0c 84             bitmanip_       or      al,84H    ; set bits 2 and 7\n 0002  80 f4 02                          xor     ah,02H    ; flip bit 9 of EAX (bit 1 of AH)\n 0005  24 f7                             and     al,0f7H\n 0007  c3                                ret\n\nNo disassembly errors\n\n----[ finis ]-----------------------------------------------------------------\n",
            "value is 0x55;\nbitnum : 3rd.\n\n&amp;\n0101 0101\n&amp;\n0000 1000\n___________\n0000 0000 (mean 0: False). It will work fine if the third bit is 1 (then the answer will be True)\n\n0101 0101\n^\n0000 1000\n___________\n0101 1101 (Flip the third bit without affecting other bits)\n\n|\n0101 0101\n|\n0000 1000\n___________\n0101 1101 (set the third bit without affecting other bits)\n",
            "unsigned char\nsize_t\n#define BITOP(a,b,op) \\\n ((a)[(size_t)(b)/(8*sizeof *(a))] op ((size_t)1&lt;&lt;((size_t)(b)%(8*sizeof *(a)))))\n\nBITOP(array, bit, |=);\n\nBITOP(array, bit, &amp;=~);\n\nBITOP(array, bit, ^=);\n\nif (BITOP(array, bit, &amp;)) ...\n",
            "num = 55\nn = 4\nnth\nnum\nn\n&amp;\nbit = (num &gt;&gt; n) &amp; 1;\n\n       0011 0111 (55 in decimal)\n    &gt;&gt;         4 (right shift 4 times)\n-----------------\n       0000 0011\n     &amp; 0000 0001 (1 in decimal)\n-----------------\n    =&gt; 0000 0001 (final result)\n\nn\n|\nnum\nnum |= 1 &lt;&lt; n;    // Equivalent to num = (1 &lt;&lt; n) | num;\n\n       0000 0001 (1 in decimal)\n    &lt;&lt;         4 (left shift 4 times)\n-----------------\n       0001 0000\n     | 0011 0111 (55 in decimal)\n-----------------\n    =&gt; 0001 0000 (final result)\n\nn\n1 &lt;&lt; n\n~ (1 &lt;&lt; n)\n&amp;\nnum\nnum &amp; (~ (1 &lt;&lt; n))\nnum &amp;= ~(1 &lt;&lt; n);    // Equivalent to num = num &amp; ~(1 &lt;&lt; n);\n\n       0000 0001 (1 in decimal)\n    &lt;&lt;         4 (left shift 4 times)\n-----------------\n     ~ 0001 0000\n-----------------\n       1110 1111\n     &amp; 0011 0111 (55 in decimal)\n-----------------\n    =&gt; 0010 0111 (final result)\n\n^\nnum ^= 1 &lt;&lt; n;    // Equivalent to num = num ^ (1 &lt;&lt; n);\n\n0 ^ 1 =&gt; 1\n1 ^ 1 =&gt; 0\n       0000 0001 (1 in decimal)\n    &lt;&lt;         4 (left shift 4 times)\n-----------------\n       0001 0000\n     ^ 0011 0111 (55 in decimal)\n-----------------\n    =&gt; 0010 0111 (final result)\n",
            "struct HwRegister {\n    unsigned int errorFlag:1;  // one-bit flag field\n    unsigned int Mode:3;       // three-bit mode field\n    unsigned int StatusCode:4;  // four-bit status code\n};\n\nstruct HwRegister CR3342_AReg;\n",
            "#define bit_test(x, y)  ( ( ((const char*)&amp;(x))[(y)&gt;&gt;3] &amp; 0x80 &gt;&gt; ((y)&amp;0x07)) &gt;&gt; (7-((y)&amp;0x07) ) )\n\nint main(void)\n{\n    unsigned char arr[8] = { 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF };\n\n    for (int ix = 0; ix &lt; 64; ++ix)\n        printf(\"bit %d is %d\\n\", ix, bit_test(arr, ix));\n\n    return 0;\n}\n",
            "#define BITS 8\n#define BIT_SET(  p, n) (p[(n)/BITS] |=  (0x80&gt;&gt;((n)%BITS)))\n#define BIT_CLEAR(p, n) (p[(n)/BITS] &amp;= ~(0x80&gt;&gt;((n)%BITS)))\n#define BIT_ISSET(p, n) (p[(n)/BITS] &amp;   (0x80&gt;&gt;((n)%BITS)))\n",
            "{\n    unsigned int data = 0x000000F0;\n    int bitpos = 4;\n    int bitvalue = 1;\n    unsigned int bit = data;\n    bit = (bit&gt;&gt;bitpos)&amp;0x00000001;\n    int invbitvalue = 0x00000001&amp;(~bitvalue);\n    printf(\"%x\\n\",bit);\n\n    if (bitvalue == 0)\n    {\n        if (bit == 0)\n            printf(\"%x\\n\", data);\n        else\n        {\n             data = (data^(invbitvalue&lt;&lt;bitpos));\n             printf(\"%x\\n\", data);\n        }\n    }\n    else\n    {\n        if (bit == 1)\n            printf(\"elseif %x\\n\", data);\n        else\n        {\n            data = (data|(bitvalue&lt;&lt;bitpos));\n            printf(\"else %x\\n\", data);\n        }\n    }\n}\n",
            "const unsigned char TQuickByteMask[8] =\n{\n   0x01, 0x02, 0x04, 0x08,\n   0x10, 0x20, 0x40, 0x80,\n};\n\n\n/** Set bit in any sized bit mask.\n *\n * @return    none\n *\n * @param     bit    - Bit number.\n * @param     bitmap - Pointer to bitmap.\n */\nvoid TSetBit( short bit, unsigned char *bitmap)\n{\n    short n, x;\n\n    x = bit / 8;        // Index to byte.\n    n = bit % 8;        // Specific bit in byte.\n\n    bitmap[x] |= TQuickByteMask[n];        // Set bit.\n}\n\n\n/** Reset bit in any sized mask.\n *\n * @return  None\n *\n * @param   bit    - Bit number.\n * @param   bitmap - Pointer to bitmap.\n */\nvoid TResetBit( short bit, unsigned char *bitmap)\n{\n    short n, x;\n\n    x = bit / 8;        // Index to byte.\n    n = bit % 8;        // Specific bit in byte.\n\n    bitmap[x] &amp;= (~TQuickByteMask[n]);    // Reset bit.\n}\n\n\n/** Toggle bit in any sized bit mask.\n *\n * @return   none\n *\n * @param   bit    - Bit number.\n * @param   bitmap - Pointer to bitmap.\n */\nvoid TToggleBit( short bit, unsigned char *bitmap)\n{\n    short n, x;\n\n    x = bit / 8;        // Index to byte.\n    n = bit % 8;        // Specific bit in byte.\n\n    bitmap[x] ^= TQuickByteMask[n];        // Toggle bit.\n}\n\n\n/** Checks specified bit.\n *\n * @return  1 if bit set else 0.\n *\n * @param   bit    - Bit number.\n * @param   bitmap - Pointer to bitmap.\n */\nshort TIsBitSet( short bit, const unsigned char *bitmap)\n{\n    short n, x;\n\n    x = bit / 8;    // Index to byte.\n    n = bit % 8;    // Specific bit in byte.\n\n    // Test bit (logigal AND).\n    if (bitmap[x] &amp; TQuickByteMask[n])\n        return 1;\n\n    return 0;\n}\n\n\n/** Checks specified bit.\n *\n * @return  1 if bit reset else 0.\n *\n * @param   bit    - Bit number.\n * @param   bitmap - Pointer to bitmap.\n */\nshort TIsBitReset( short bit, const unsigned char *bitmap)\n{\n    return TIsBitSet(bit, bitmap) ^ 1;\n}\n\n\n/** Count number of bits set in a bitmap.\n *\n * @return   Number of bits set.\n *\n * @param    bitmap - Pointer to bitmap.\n * @param    size   - Bitmap size (in bits).\n *\n * @note    Not very efficient in terms of execution speed. If you are doing\n *        some computationally intense stuff you may need a more complex\n *        implementation which would be faster (especially for big bitmaps).\n *        See (http://graphics.stanford.edu/~seander/bithacks.html).\n */\nint TCountBits( const unsigned char *bitmap, int size)\n{\n    int i, count = 0;\n\n    for (i=0; i&lt;size; i++)\n        if (TIsBitSet(i, bitmap))\n            count++;\n\n    return count;\n}\n\nTSetBit( n, &amp;my_int);\n",
            "int ToggleNthBit ( unsigned char n, int num )\n{\n    if(num &amp; (1 &lt;&lt; n))\n        num &amp;= ~(1 &lt;&lt; n);\n    else\n        num |= (1 &lt;&lt; n);\n\n    return num;\n}\n",
            "set_bit  Atomically set a bit in memory\nclear_bit  Clears a bit in memory\nchange_bit  Toggle a bit in memory\ntest_and_set_bit  Set a bit and return its old value\ntest_and_clear_bit  Clear a bit and return its old value\ntest_and_change_bit  Change a bit and return its old value\ntest_bit  Determine whether a bit is set\n",
            "sizeof()\nbool IsGph[256], IsNotGph[256];\n\n// Initialize boolean array to detect printable characters\nfor(i=0; i&lt;sizeof(IsGph); i++) {\n    IsGph[i] = isgraph((unsigned char)i);\n}\n\nIsGph[i] =1\nIsGph[i] =0\n// Initialize boolean array to detect UN-printable characters,\n// then call function to toggle required bits true, while initializing a 2nd\n// boolean array as the complement of the 1st.\nfor(i=0; i&lt;sizeof(IsGph); i++) {\n    if(IsGph[i]) {\n        IsNotGph[i] = 0;\n    } \n    else {\n        IsNotGph[i] = 1;\n    }\n}\n",
            "bitset\n#include &lt;iostream&gt;\n#include &lt;bitset&gt;\n#include &lt;string&gt;\n\nusing namespace std;\nint main() {\n  bitset&lt;8&gt; byte(std::string(\"10010011\");\n\n  // Set Bit\n  byte.set(3); // 10010111\n\n  // Clear Bit\n  byte.reset(2); // 10010101\n\n  // Toggle Bit\n  byte.flip(7); // 00010101\n\n  cout &lt;&lt; byte &lt;&lt; endl;\n\n  return 0;\n}\n",
            "int set_nth_bit(int num, int n){    \n    return (num | 1 &lt;&lt; n);\n}\n\nint clear_nth_bit(int num, int n){    \n    return (num &amp; ~( 1 &lt;&lt; n));\n}\n\nint toggle_nth_bit(int num, int n){    \n    return num ^ (1 &lt;&lt; n);\n}\n\nint check_nth_bit(int num, int n){    \n    return num &amp; (1 &lt;&lt; n);\n}\n",
            "1\nnumber\n1\nx\n1 &lt;&lt; x\nx\n~\n// Assume 32 bit int/unsigned\nunsigned long long number = foo();\n\nunsigned x = 40; \nnumber |= (1 &lt;&lt; x);  // UB\nnumber ^= (1 &lt;&lt; x);  // UB\nnumber &amp;= ~(1 &lt;&lt; x); // UB\n\nx = 10;\nnumber &amp;= ~(1 &lt;&lt; x); // Wrong mask, not wide enough\n\n1ull\n(uintmax_t)1\nnumber |= (1ull &lt;&lt; x);\nnumber |= ((uintmax_t)1 &lt;&lt; x);\n\nnumber |= (type_of_number)1 &lt;&lt; x;\n\n1\nnumber\nnumber |= (number*0 + 1) &lt;&lt; x;\n",
            "SET_FLAG(Status, Flag)            ((Status) |= (Flag))\nCLEAR_FLAG(Status, Flag)          ((Status) &amp;= ~(Flag))\nINVALID_FLAGS(ulFlags, ulAllowed) ((ulFlags) &amp; ~(ulAllowed))\nTEST_FLAGS(t,ulMask, ulBit)       (((t)&amp;(ulMask)) == (ulBit))\nIS_FLAG_SET(t,ulMask)             TEST_FLAGS(t,ulMask,ulMask)\nIS_FLAG_CLEAR(t,ulMask)           TEST_FLAGS(t,ulMask,0)\n",
            "namespace bit {\n  template &lt;typename T1, typename T2&gt;\n  constexpr inline T1 bitmask(T2 bit) \n  {return (T1)1 &lt;&lt; bit;}\n  template &lt;typename T1, typename T3, typename ...T2&gt;\n  constexpr inline T1 bitmask(T3 bit, T2 ...bits) \n  {return ((T1)1 &lt;&lt; bit) | bitmask&lt;T1&gt;(bits...);}\n\n  /** Set these bits (others retain their state) */\n  template &lt;typename T1, typename ...T2&gt;\n  constexpr inline void set (T1 &amp;variable, T2 ...bits) \n  {variable |= bitmask&lt;T1&gt;(bits...);}\n  /** Set only these bits (others will be cleared) */\n  template &lt;typename T1, typename ...T2&gt;\n  constexpr inline void setOnly (T1 &amp;variable, T2 ...bits) \n  {variable = bitmask&lt;T1&gt;(bits...);}\n  /** Clear these bits (others retain their state) */\n  template &lt;typename T1, typename ...T2&gt;\n  constexpr inline void clear (T1 &amp;variable, T2 ...bits) \n  {variable &amp;= ~bitmask&lt;T1&gt;(bits...);}\n  /** Flip these bits (others retain their state) */\n  template &lt;typename T1, typename ...T2&gt;\n  constexpr inline void flip (T1 &amp;variable, T2 ...bits) \n  {variable ^= bitmask&lt;T1&gt;(bits...);}\n  /** Check if any of these bits are set */\n  template &lt;typename T1, typename ...T2&gt;\n  constexpr inline bool isAnySet(const T1 &amp;variable, T2 ...bits) \n  {return variable &amp; bitmask&lt;T1&gt;(bits...);}\n  /** Check if all these bits are set */\n  template &lt;typename T1, typename ...T2&gt;\n  constexpr inline bool isSet (const T1 &amp;variable, T2 ...bits) \n  {return ((variable &amp; bitmask&lt;T1&gt;(bits...)) == bitmask&lt;T1&gt;(bits...));}\n  /** Check if all these bits are not set */\n  template &lt;typename T1, typename ...T2&gt;\n  constexpr inline bool isNotSet (const T1 &amp;variable, T2 ...bits) \n  {return ((variable &amp; bitmask&lt;T1&gt;(bits...)) != bitmask&lt;T1&gt;(bits...));}\n}\n\n#include &lt;iostream&gt;\n#include &lt;bitset&gt; // for console output of binary values\n\n// and include the code above of course\n\nusing namespace std;\n\nint main() {\n  uint8_t v = 0b1111'1100;\n  bit::set(v, 0);\n  cout &lt;&lt; bitset&lt;8&gt;(v) &lt;&lt; endl;\n\n  bit::clear(v, 0,1);\n  cout &lt;&lt; bitset&lt;8&gt;(v) &lt;&lt; endl;\n\n  bit::flip(v, 0,1);\n  cout &lt;&lt; bitset&lt;8&gt;(v) &lt;&lt; endl;\n\n  bit::clear(v, 0,1,2,3,4,5,6,7);\n  cout &lt;&lt; bitset&lt;8&gt;(v) &lt;&lt; endl;\n\n  bit::flip(v, 0,7);\n  cout &lt;&lt; bitset&lt;8&gt;(v) &lt;&lt; endl;\n}\n",
            "public class BitwiseOperations {\n\n    public static void main(String args[]) {\n\n        setABit(0, 4);    // Set the 4th bit, 0000 -&gt; 1000 [8]\n        clearABit(16, 5); // Clear the 5th bit, 10000 -&gt; 00000 [0]\n        toggleABit(8, 4); // Toggle the 4th bit, 1000 -&gt; 0000 [0]\n        checkABit(8, 4);  // Check the 4th bit 1000 -&gt; true\n    }\n\n    public static void setABit(int input, int n) {\n        input = input | (1 &lt;&lt; n-1);\n        System.out.println(input);\n    }\n\n\n    public static void clearABit(int input, int n) {\n        input = input &amp; ~(1 &lt;&lt; n-1);\n        System.out.println(input);\n    }\n\n    public static void toggleABit(int input, int n) {\n        input = input ^ (1 &lt;&lt; n-1);\n        System.out.println(input);\n    }\n\n    public static void checkABit(int input, int n) {\n        boolean isSet = ((input &gt;&gt; n-1) &amp; 1) == 1;\n        System.out.println(isSet);\n    }\n}\n\n8\n0\n0\ntrue\n",
            "#define INT_BIT (unsigned int) (sizeof(unsigned int) * 8U) //number of bits in unsigned int\n\nint main(void)\n{\n    \n    unsigned int k = 5; //k is the bit position; here it is the 5th bit from the LSb (0th bit)\n    \n    unsigned int regA = 0x00007C7C; //we perform bitwise operations on regA\n    \n    regA |= (1U &lt;&lt; k);    //Set kth bit\n    \n    regA &amp;= ~(1U &lt;&lt; k);   //Clear kth bit\n    \n    regA ^= (1U &lt;&lt; k);    //Toggle kth bit\n    \n    regA = (regA &lt;&lt; k) | regA &gt;&gt; (INT_BIT - k); //Rotate left by k bits\n    \n    regA = (regA &gt;&gt; k) | regA &lt;&lt; (INT_BIT - k); //Rotate right by k bits\n\n    return 0;   \n}\n\n",
            "#include &lt;stdio.h&gt;\n#include &lt;stdbool.h&gt;\n\ntypedef unsigned long Uint;\n\nUint bit_set(Uint number, Uint n);\nUint bit_clear(Uint number, Uint n);\nUint bit_toggle(Uint number, Uint n);\nbool bit_check(Uint number, Uint n);\nUint bit_set_to(Uint number, Uint n, bool x);\nvoid print_binary(Uint number, int total_bits);\n\nint main() {\n    Uint number = 29; // Example number in binary: 00011101\n    Uint n = 3;       // Example: bit position 3 (starting from 0)\n\n    printf(&quot;Initial number: %lu (binary: &quot;, number);\n    print_binary(number, 8);  // Print number in binary\n\n    // Set nth bit to 1\n    printf(&quot;\\nSetting bit %lu...\\n&quot;, n);\n    number = bit_set(number, n);\n    printf(&quot;Number after setting bit %lu: %lu (binary: &quot;, n, number);\n    print_binary(number, 8);\n\n    // Clear nth bit (set to 0)\n    printf(&quot;\\nClearing bit %lu...\\n&quot;, n);\n    number = bit_clear(number, n);\n    printf(&quot;Number after clearing bit %lu: %lu (binary: &quot;, n, number);\n    print_binary(number, 8);\n\n    // Toggle nth bit\n    printf(&quot;\\nToggling bit %lu...\\n&quot;, n);\n    number = bit_toggle(number, n);\n    printf(&quot;Number after toggling bit %lu: %lu (binary: &quot;, n, number);\n    print_binary(number, 8);\n\n    // Check nth bit\n    printf(&quot;\\nChecking bit %lu...\\n&quot;, n);\n    bool is_set = bit_check(number, n);\n    printf(&quot;Bit %lu is %s\\n&quot;, n, is_set ? &quot;set (1)&quot; : &quot;clear (0)&quot;);\n\n    // Set nth bit to specific value (example: set to 1)\n    printf(&quot;\\nSetting bit %lu to 1...\\n&quot;, n);\n    number = bit_set_to(number, n, true);\n    printf(&quot;Number after setting bit %lu to 1: %lu (binary: &quot;, n, number);\n    print_binary(number, 8);\n\n    // Set nth bit to specific value (example: set to 0)\n    printf(&quot;\\nSetting bit %lu to 0...\\n&quot;, n);\n    number = bit_set_to(number, n, false);\n    printf(&quot;Number after setting bit %lu to 0: %lu (binary: &quot;, n, number);\n    print_binary(number, 8);\n\n    return 0;\n}\n\nUint bit_set(Uint number, Uint n) {\n    return number | ((Uint)1 &lt;&lt; n);\n}\n\nUint bit_clear(Uint number, Uint n) {\n    return number &amp; ~((Uint)1 &lt;&lt; n);\n}\n\nUint bit_toggle(Uint number, Uint n) {\n    return number ^ ((Uint)1 &lt;&lt; n);\n}\n\nbool bit_check(Uint number, Uint n) {\n    return (number &gt;&gt; n) &amp; (Uint)1;\n}\n\nUint bit_set_to(Uint number, Uint n, bool x) {\n    return (number &amp; ~((Uint)1 &lt;&lt; n)) | ((Uint)x &lt;&lt; n);\n}\n\nvoid print_binary(Uint number, int total_bits) {\n    for (int i = total_bits - 1; i &gt;= 0; i--) {\n        printf(&quot;%lu&quot;, (number &gt;&gt; i) &amp; 1);\n    }\n    printf(&quot;)\\n&quot;);\n}\n",
            "number = (((number | (1 &lt;&lt; n)) ^ (1 &lt;&lt; n))) | (x &lt;&lt; n);\n\n((number | (1 &lt;&lt; n)\n|\n(...) ^ (1 &lt;&lt; n)\n(...) | x &lt;&lt; n)\nx",
            "char bitfield;\n\n// Start at 0th position\n\nvoid chang_n_bit(int n, int value)\n{\n    bitfield = (bitfield | (1 &lt;&lt; n)) &amp; (~( (1 &lt;&lt; n) ^ (value &lt;&lt; n) ));\n}\n\nvoid chang_n_bit(int n, int value)\n{\n    bitfield = (bitfield | (1 &lt;&lt; n)) &amp; ((value &lt;&lt; n) | ((~0) ^ (1 &lt;&lt; n)));\n}\n\nvoid chang_n_bit(int n, int value)\n{\n    if(value)\n        bitfield |= 1 &lt;&lt; n;\n    else\n        bitfield &amp;= ~0 ^ (1 &lt;&lt; n);\n}\n\nchar get_n_bit(int n)\n{\n    return (bitfield &amp; (1 &lt;&lt; n)) ? 1 : 0;\n}\n"
        ]
    },
    {
        "question_id": 21593,
        "question_code": "include\n#include &lt;filename&gt;\n#include &quot;filename&quot;",
        "answer_code_snippets": [
            "#include &lt;filename&gt;\n#include &quot;filename&quot;",
            "#include &lt;h-char-sequence&gt; new-line\n\n&lt;\n&gt;\n#include \"q-char-sequence\" new-line\n\n\"\n#include &lt;h-char-sequence&gt; new-line\n\n&gt;\n#include pp-tokens new-line\n\ninclude\n&lt;\n&gt;\n\"\n&gt;\n\"",
            "#include \"file\"\n#include &lt;file&gt;\n#include\n#include",
            "#include \"file.h\"\n./file.h\n.\n#include\n#include &lt;file.h&gt;\n/usr/include/file.h\n/usr/include",
            "#include &lt;file.h&gt;\nfile.h\n#include &quot;file&quot;\nfile\n-I\n-I\nincludes\nmyheader.h\n#include &lt;myheader.h&gt;\n-I .\n-I\n#include &quot;myheader.h&quot;\nmyheader.h\ninclude",
            "‘#include’\n#include &lt;file&gt;\n-I\n#include \"file\"\n&lt;file&gt;\n-iquote\n‘#include’\n#include &lt;x/*y&gt;\nx/*y\n#include \"x\\n\\\\y\"\n‘/’\n‘/’",
            "\"mypath/myfile\" is short for ./mypath/myfile\n\n.\n#include\ndefault_include_paths\n&lt;mypath/myfile&gt; is short for &lt;defaultincludepaths&gt;/mypath/myfile\n\n./\n&lt;default_include_paths&gt;\nmypath/myfile",
            "&lt;file&gt;\n-I\n\"file\"\n-I\n# include &lt;h-char-sequence&gt; new-line\n# include \"q-char-sequence\" new-line\n# include &lt;h-char-sequence&gt; new-line\n\"xxx\"\n&lt;xxx&gt;",
            "#include &lt;h-char-sequence&gt; new-line\n\n&lt;\n&gt;\n#include \"q-char-sequence\" new-line\n\n\"\n#include &lt;h-char-sequence&gt; new-line\n\n&gt;\n#include pp-tokens new-line\n\ninclude\n&lt;\n&gt;\n\"\n&gt;\n\"\n&lt;stdio.h&gt;\n#include \"...\"\n#include\n#include &lt;...&gt;",
            "#include \"\"\n#include &lt;&gt;",
            "&quot;myApp.hpp&quot;\n&lt;libHeader.hpp&gt;\n/I\nINCLUDE\n#include &quot;../../MyProgDir/SourceDir1/someFile.hpp&quot;\n\n&quot;./myHeader.h&quot;\n/I\nINCLUDE\n/I\nINCLUDE",
            "#include &lt;list&gt;\n#include &lt;xxx&gt;",
            "#include &lt;&gt;\n#include &lt;iostream&gt;\n\n#include \" \"\nmyfile.h\n#include \"myfile.h\"\n",
            "#include \"filename\" // User defined header\n#include &lt;filename&gt; // Standard library header.\n\nSeller.h\n#ifndef SELLER_H     // Header guard\n#define SELLER_H     // Header guard\n\n#include &lt;string&gt;\n#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n\nclass Seller\n{\n    private:\n        char name[31];\n        double sales_total;\n\n    public:\n        Seller();\n        Seller(char[], double);\n        char*getName();\n\n#endif\n\nSeller.cpp\nSeller.h\n#include \"Seller.h\"\n",
            "#include &lt;abc.h&gt;\n\n#include \"xyz.h\"\n\n-I",
            "&quot;&quot;\n./\ngcc -v -o a a.c\n\n// a.c\n#include &quot;stdio.h&quot;\nint main() {\n        int a = 3;\n        printf(&quot;a = %d\\n&quot;, a);\n        return 0;\n\n}\n\n// b.c\n#include &lt;stdio.h&gt;\nint main() {\n        int a = 3;\n        printf(&quot;a = %d\\n&quot;, a);\n        return 0;\n\n}\n\nstdio.h\n// stdio.h\ninline int foo()\n{\n        return 10;\n}\n\na.c\nb.c\nd.c\n// d.c\n#include &lt;stdio.h&gt;\n#include &quot;stdio.h&quot;\nint main()\n{\n        int a = 0;\n\n        a = foo();\n\n        printf(&quot;a=%d\\n&quot;, a);\n\n        return 0;\n}\n",
            "#include &lt;file&gt; \n\n#include &quot;file&quot; \n",
            "#include &lt;filename&gt;\n/usr/include\n/usr/local/include\n#include \"filename\"",
            "#include &lt;filename&gt;\n#include &quot;path-to-file/filename&quot;",
            "#include &lt;filename&gt;\n#include \"filename\"\n#include &lt;filename&gt;\n#include &lt;filename&gt;",
            "cpp -v /dev/null -o /dev/null",
            "#include &lt;myFilename&gt;\n#include &quot;myFilename&quot;",
            "#include\"filename\"\n#include&lt;filename&gt;\n\n#include\"mylib.h\"\n\nmylib.h\n#include&lt;mylib.h&gt;\n\nmylib.h"
        ]
    },
    {
        "question_id": 605845,
        "question_code": "malloc\nint *sieve = malloc(sizeof(*sieve) * length);\n\nint *sieve = (int *) malloc(sizeof(*sieve) * length);\n",
        "answer_code_snippets": [
            "void *\n&lt;stdlib.h&gt;\nint\nint\nint *sieve = malloc(length * sizeof *sieve);\n\nsizeof\nsizeof\nlength\nsizeof\nsizeof\nlength\nint *sieve = malloc(sizeof *sieve * length);\n\nsizeof\nsize_t\nmalloc(sizeof *sieve * length * width)\nmalloc(length * width * sizeof *sieve)\nlength * width\nwidth\nlength\nsize_t",
            "malloc\nmalloc\nint *sieve = malloc(sizeof *sieve * length);\n\nsieve",
            "type *\ntype **\n#include\nmalloc()",
            "#ifdef __cplusplus\n# define MALLOC(type) ((type *)malloc(sizeof(type)))\n# define CALLOC(count, type) ((type *)calloc(count, sizeof(type)))\n#else\n# define MALLOC(type) (malloc(sizeof(type)))\n# define CALLOC(count, type) (calloc(count, sizeof(type)))\n#endif\n# define FREE(pointer) free(pointer)\n\nint *sieve = MALLOC(int); // allocate single int =&gt; compare to stack int sieve = ???;\nint *sieve_arr = CALLOC(4, int); // allocate 4 times size of int =&gt; compare to stack (int sieve_arr[4] = {0, 0, 0, 0};\n// do something with the ptr or the value\nFREE(sieve);\nFREE(sieve_arr);\n",
            "malloc",
            "void",
            "malloc\nmalloc\nvoid*\nnew\nmalloc()\n&lt;stdlib.h&gt;\n&lt;stdlib.h&gt;\nint\nmalloc",
            "void *",
            "malloc()\nvoid *\nchar *",
            "malloc\nvoid*\nvoid*",
            "malloc\nvoid *",
            "malloc\nmalloc\nvoid*",
            "#include &lt;stdlib.h&gt;\n#define NEW_ARRAY(ptr, n) (ptr) = malloc((n) * sizeof *(ptr))\n#define NEW(ptr) NEW_ARRAY((ptr), 1)\n\nNEW_ARRAY(sieve, length);\n\n#define LEN(arr) (sizeof (arr) / sizeof (arr)[0])\n\nint i, a[100];\n\nfor (i = 0; i &lt; LEN(a); i++) {\n   ...\n}\n",
            "#include &lt;stdlib.h&gt;\nmalloc()\nmalloc()\nint\nsizeof(int) != sizeof(int*)\nstdlib.h\nmalloc()\nstdlib.h\nmalloc()\n_Alignof (max_align_t)\n_Alignof (max_align_t)\nmalloc()",
            "malloc()\nvoid *\n#include &lt;stdlib.h&gt;\nlong x = 5;\ndouble *p = (double *)&amp;x;\ndouble y = *p;\n\nstruct foo { int x; };\nstruct bar { int x; int y; };\nstruct bar b = { 1, 2};\nstruct foo *p = (struct foo *)&amp;b;\nint z = p-&gt;x;\n\nvoid *\nint x = 5;\nprintf(\"%p\\n\", (void *)&amp;x);\n\nprintf()\nvoid *",
            "double d;\nvoid *p = &amp;d;\nint *q = p;\n\nmalloc\nunsigned char *\nvoid *\nchar *\nunsigned char *\nmemset\nmemcpy\nmalloc\nvoid *\n/* In a header somewhere */\n#ifdef __cplusplus\n#define strip_qual(TYPE, EXPR) (const_cast&lt;TYPE&gt;(EXPR))\n#define convert(TYPE, EXPR) (static_cast&lt;TYPE&gt;(EXPR))\n#define coerce(TYPE, EXPR) (reinterpret_cast&lt;TYPE&gt;(EXPR))\n#else\n#define strip_qual(TYPE, EXPR) ((TYPE) (EXPR))\n#define convert(TYPE, EXPR) ((TYPE) (EXPR))\n#define coerce(TYPE, EXPR) ((TYPE) (EXPR))\n#endif\n\ngrep\nstrip_qual\nconst\nvolatile\n-Wold-style-cast\n(type)\nmalloc",
            "g_new\ng_new0\ng_new\ng_new0\ng_new\ng_new0\nmalloc\ncalloc\n0",
            "-Wall\nauto\n-Wall\n-std=c++11\nstdlib.h\nmalloc\nmalloc\nvoid*\nT*\nauto memblock=static_cast&lt;T*&gt;(malloc(n*sizeof(T))); //Mult may overflow...\n",
            "void *\n&lt;stdlib.h&gt;\nmalloc",
            "malloc\nmalloc()\nptr = (T*)malloc(sizeof(T));\nptr = malloc(sizeof *ptr);\nptr\nptr\nnew\n#define NEW(T) ((T*)malloc(sizeof(T)))\n...\nptr = NEW(T);\n\nptr\nvoid*\nptr\nptr\nvoid*",
            "malloc\nmalloc\nmalloc"
        ]
    },
    {
        "question_id": 7825055,
        "question_code": "!ErrorHasOccured() ??!??! HandleError();\n\n??!??!\n??!??!",
        "answer_code_snippets": [
            "??!\n|\n!ErrorHasOccured() || HandleError();\n\nif (ErrorHasOccured())\n    HandleError();\n",
            "{ | } ~ \n\n??!\n|\n||",
            "??!??!\n??!\n??!\n||\nTrigraph   Replaces\n\n??(        [\n??)        ]\n??&lt;        {\n??&gt;        }\n??/        \\\n??'        ^\n??=        #\n??!        |\n??-        ~\n\n??(??)\n[]\n??(??)??(??)\n[][]\ncpp\ntrigr.c\nvoid main(){ const char *s = &quot;??!??!&quot;; } \n\ncpp -trigraphs trigr.c \n\nvoid main(){ const char *s = &quot;||&quot;; }\n\n-trigraphs\ncpp",
            "??!\n|\n??!??!\n||"
        ]
    },
    {
        "question_id": 1041866,
        "question_code": "extern \"C\"\nextern \"C\" {\n   void foo();\n}\n",
        "answer_code_snippets": [
            "extern &quot;C&quot;\nextern &quot;C&quot;\nextern &quot;C&quot;\nextern &quot;C&quot; void foo(int);\nextern &quot;C&quot;\n{\n   void g(char);\n   int i;\n}\n\nextern &quot;C&quot;\nextern &quot;C&quot;\nextern &quot;C&quot;\nextern &quot;C&quot;\nstatic\nextern &quot;C&quot;",
            "#ifdef __cplusplus\nextern &quot;C&quot; {\n#endif\n\n// all of your legacy C code here\n\n#ifdef __cplusplus\n}\n#endif\n\n__cplusplus\nextern &quot;C&quot; {\n#include &quot;legacy_C_header.h&quot;\n}\n",
            "g++\nvoid f() {}\nvoid g();\n\nextern &quot;C&quot; {\n    void ef() {}\n    void eg();\n}\n\n/* Prevent g and eg from being optimized away. */\nvoid h() { g(); eg(); }\n\ng++ -c -std=c++11 -Wall -Wextra -pedantic -o main.o main.cpp\nreadelf -s main.o\n\n     8: 0000000000000000     7 FUNC    GLOBAL DEFAULT    1 _Z1fv\n     9: 0000000000000007     7 FUNC    GLOBAL DEFAULT    1 ef\n    10: 000000000000000e    17 FUNC    GLOBAL DEFAULT    1 _Z1hv\n    11: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND _GLOBAL_OFFSET_TABLE_\n    12: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND _Z1gv\n    13: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND eg\n\nef\neg\n$ c++filt _Z1fv\nf()\n$ c++filt _Z1hv\nh()\n$ c++filt _Z1gv\ng()\n\nNdx = UND\nextern &quot;C&quot;\ng++\ngcc\ng++\ngcc\nextern C\nextern &quot;C&quot; {\n    // Overloading.\n    // error: declaration of C function ‘void f(int)’ conflicts with\n    void f();\n    void f(int i);\n\n    // Templates.\n    // error: template with C linkage\n    template &lt;class C&gt; void f(C i) { }\n}\n\n#include &lt;cassert&gt;\n\n#include &quot;c.h&quot;\n\nint main() {\n    assert(f() == 1);\n}\n\n#ifndef C_H\n#define C_H\n\n/* This ifdef allows the header to be used from both C and C++ \n * because C does not know what this extern &quot;C&quot; thing is. */\n#ifdef __cplusplus\nextern &quot;C&quot; {\n#endif\nint f();\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n\n#include &quot;c.h&quot;\n\nint f(void) { return 1; }\n\ng++ -c -o main.o -std=c++98 main.cpp\ngcc -c -o c.o -std=c89 c.c\ng++ -o main.out main.o c.o\n./main.out\n\nextern &quot;C&quot;\nmain.cpp:6: undefined reference to `f()'\n\ng++\nf\ngcc\n#include &lt;assert.h&gt;\n\n#include &quot;cpp.h&quot;\n\nint main(void) {\n    assert(f_int(1) == 2);\n    assert(f_float(1.0) == 3);\n    return 0;\n}\n\n#ifndef CPP_H\n#define CPP_H\n\n#ifdef __cplusplus\n// C cannot see these overloaded prototypes, or else it would get confused.\nint f(int i);\nint f(float i);\nextern &quot;C&quot; {\n#endif\nint f_int(int i);\nint f_float(float i);\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n\n#include &quot;cpp.h&quot;\n\nint f(int i) {\n    return i + 1;\n}\n\nint f(float i) {\n    return i + 2;\n}\n\nint f_int(int i) {\n    return f(i);\n}\n\nint f_float(float i) {\n    return f(i);\n}\n\ngcc -c -o main.o -std=c89 -Wextra main.c\ng++ -c -o cpp.o -std=c++98 cpp.cpp\ng++ -o main.out main.o cpp.o\n./main.out\n\nextern &quot;C&quot;\nmain.c:6: undefined reference to `f_int'\nmain.c:7: undefined reference to `f_float'\n\ng++\ngcc\nextern &quot;c&quot;\ncstdio\n#pragma GCC system_header\n/usr/include/unistd.h\n__BEGIN_DECLS\n__BEGIN_DECLS\n#include &lt;features.h&gt;",
            "dlsym()\ndlopen()",
            "extern &quot;C&quot;\n#include &lt;stdio.h&gt;\n    \n// Two functions are defined with the same name\n//   but have different parameters\n\nvoid printMe(int a) {\n  printf(&quot;int: %i\\n&quot;, a);\n}\n\nvoid printMe(char a) {\n  printf(&quot;char: %c\\n&quot;, a);\n}\n    \nint main() {\n  printMe('a');\n  printMe(1);\n  return 0;\n}\n\nprintMe\nint a\nchar a\nprintMe\nextern &quot;C&quot;\ninclude\nextern &quot;C&quot;\nextern &quot;C&quot; void printMe(int a);",
            "extern \"C\" {\nstruct method {\n    int virtual;\n};\n}\n",
            "extern &quot;C&quot;",
            "extern \"C\"\nextern \"language\" function-prototype\n\nextern \"language\"\n{\n     function-prototype\n};\n\n#include&lt;iostream&gt;\nusing namespace std;\n\nextern \"C\"\n{\n     #include&lt;stdio.h&gt;    // Include C Header\n     int n;               // Declare a Variable\n     void func(int,int);  // Declare a function (function prototype)\n}\n\nint main()\n{\n    func(int a, int b);   // Calling function . . .\n    return 0;\n}\n\n// Function definition . . .\nvoid func(int m, int n)\n{\n    //\n    //\n}\n",
            "#include &lt;stdio.h&gt;\n\nconst char* get_message2(void); \nint get_message2(char*); \n\nint main() {\n   char test[] = &quot;BBBBBBB&quot;;\n   get_message2(test);\n   return 0;\n}\n\nconst char* get_message2() {\n    char test[] = &quot;AAAAAAA&quot;;\n    return &quot;message2&quot;;\n};\n\nint get_message2(char* arg) {\n    char test[] = &quot;CCCCCCC&quot;;\n   return 0;\n}\n\ndrazen@HP-ProBook-640G1:~/proba$ readelf  -a proba | grep message\n    34: 0000000000001199    70 FUNC    GLOBAL DEFAULT   16 _Z12get_message2v\n    36: 00000000000011df    72 FUNC    GLOBAL DEFAULT   16 _Z12get_message2Pc\n\nextern &quot;C&quot;\nconst char* get_message2(void); \nextern &quot;C&quot; {\n   int get_message2(char*); \n}\n\nint get_message2(char*);\ndrazen@HP-ProBook-640G1:~/proba$ readelf  -a proba | grep message\n    32: 00000000000011df    72 FUNC    GLOBAL DEFAULT   16 get_message2\n    35: 0000000000001199    70 FUNC    GLOBAL DEFAULT   16 _Z12get_message2v\n",
            "#include &lt;string.h&gt;\n#include &lt;windows.h&gt;\n\nusing namespace std;\n\n#define DLL extern \"C\" __declspec(dllexport)\n//I defined DLL for dllexport function\nDLL main ()\n{\n    MessageBox(NULL,\"Hi from DLL\",\"DLL\",MB_OK);\n}\n\n#include &lt;string.h&gt;\n#include &lt;windows.h&gt;\n\nusing namespace std;\n\ntypedef LPVOID (WINAPI*Function)();//make a placeholder for function from dll\nFunction mainDLLFunc;//make a variable for function placeholder\n\nint main()\n{\n    char winDir[MAX_PATH];//will hold path of above dll\n    GetCurrentDirectory(sizeof(winDir),winDir);//dll is in same dir as exe\n    strcat(winDir,\"\\\\exmple.dll\");//concentrate dll name with path\n    HINSTANCE DLL = LoadLibrary(winDir);//load example dll\n    if(DLL==NULL)\n    {\n        FreeLibrary((HMODULE)DLL);//if load fails exit\n        return 0;\n    }\n    mainDLLFunc=(Function)GetProcAddress((HMODULE)DLL, \"main\");\n    //defined variable is used to assign a function from dll\n    //GetProcAddress is used to locate function with pre defined extern name \"DLL\"\n    //and matcing function name\n    if(mainDLLFunc==NULL)\n    {\n        FreeLibrary((HMODULE)DLL);//if it fails exit\n        return 0;\n    }\n    mainDLLFunc();//run exported function \n    FreeLibrary((HMODULE)DLL);\n}\n",
            "extern &quot;C&quot;\nextern &quot;C&quot;\nvoid cf () {}\n\nvoid cppf () {}\n\ndumpbin /symbols\n01A 00000000 SECT7  notype ()    External     | _cf\n01B 00000000 SECT5  notype ()    External     | ?cppf@@YAXXZ (void __cdecl cppf(void))\n\ntypedef struct {\n  int a;\n  int b;\n}\nCppStruct;\n\nextern &quot;C&quot; {\n  typedef struct {\n    int a;\n    int b;\n    int c;\n  }\n  CStruct;\n  CStruct cCStruct;\n  CppStruct cCppStruct;\n}\nCStruct cppCStruct;\nCppStruct cppCppStruct;\n\ndumpbin /symbols\n009 00000000 SECT3  notype       External     | _cCStruct\n00A 0000000C SECT3  notype       External     | _cCppStruct\n00B 00000014 SECT3  notype       External     | ?cppCStruct@@3UCStruct@@A (struct CStruct cppCStruct)\n00C 00000020 SECT3  notype       External     | ?cppCppStruct@@3UCppStruct@@A (struct CppStruct cppCppStruct)\n\ndumpbin\nextern &quot;C&quot;\nextern &quot;C&quot;\nextern CppStruct ifcStruct;\nextern int       ifcVar;\n/* ... */\n\nextern &quot;C&quot;\n{\nCppStruct ifcStruct;\nint       ifcVar = 0;\n}\n\ndumpbin /symbols\n00C 00000000 SECT4  notype       External     | ?ifcStruct@@3UCppStruct@@A (struct CppStruct ifcStruct)\n00D 00000008 SECT4  notype       External     | ?ifcVar@@3HA (int ifcVar)\n\nextern &quot;C&quot;\ntest.cpp(20): error C2732: linkage specification contradicts earlier specification for 'ifcf'\ntest.cpp(20): note: see declaration of 'ifcf'\n\nextern &quot;C&quot;\nextern &quot;C&quot; __declspec(dllexport) IKlass* __cdecl create_klass()\nextern &quot;C&quot;\ncreate_klass\n__declspec(dllexport)\ncreate_klass\ncreate_klass\n__cdecl\n__stdcall\niklass_factory",
            "C\nextern \"C\"",
            "extern &quot;c&quot;\n#include &lt;stdio.h&gt;\nextern &quot;C&quot;{\n\n\nstruct myint{\n    int i;\n};\n\nstruct myint2\n{\n    int a;\n    myint2(int a): a(a) {};\n    operator myint() const {return myint{a};}\n};\n\n}\n\nvoid f1(myint i){\n    printf(&quot;%d&quot;, i.i);\n}\n\nint main(){\n    myint2 a(1);\n    f1(a);\n}\n\nnm\nmain"
        ]
    },
    {
        "question_id": 1143262,
        "question_code": "const int *\nconst int * const\nint * const",
        "answer_code_snippets": [
            "int*\nint const *\nint * const\nint const * const\nconst\nconst int *\nint const *\nconst int * const\nint const * const\nint **\nint ** const\nint * const *\nint const **\nint * const * const\nconst\nint a = 5, b = 10, c = 15;\n\nconst int* foo;     // pointer to constant int.\nfoo = &amp;a;           // assignment to where foo points to.\n\n/* dummy statement*/\n*foo = 6;           // the value of a can´t get changed through the pointer.\n\nfoo = &amp;b;           // the pointer foo can be changed.\n\n\n\nint *const bar = &amp;c;  // constant pointer to int \n                      // note, you actually need to set the pointer \n                      // here because you can't change it later ;)\n\n*bar = 16;            // the value of c can be changed through the pointer.    \n\n/* dummy statement*/\nbar = &amp;a;             // not possible because bar is a constant pointer.           \n\nfoo\nconst char\nbar\nT* const\nNULL",
            "typedef\ntypedef char *ASTRING;\nconst ASTRING astring;\n\nastring\nchar * const\nconst char *\nconst",
            "const X* p\nX* const p\nconst X* const p\nconst X* p\nX* const p\nconst X* const p",
            "int var0 = 0;\nconst int &amp;ptr1 = var0;\nptr1 = 8; // Error\nvar0 = 6; // OK\n\nint var1 = 1;\nint var2 = 0;\n\nint *const ptr2 = &amp;var1;\nptr2 = &amp;var2; // Error\n\nint const * ptr3 = &amp;var2;\n*ptr3 = 4; // Error\n\nint var3 = 0;\nint var4 = 0;\nconst int * const ptr4 = &amp;var3;\n*ptr4 = 1;     // Error\n ptr4 = &amp;var4; // Error\n",
            "const\nconst\nconst int*\nint const*\nconst int* const\nint const* const",
            "const\nconst\nconst int Constant1=96; \n\nConstant1\n#define\nconst\nconst int * Constant2 \n\nConstant2\nint const * Constant2\n\nint * const Constant3\n\nConstant3\nint const * const Constant4\n\nConstant4",
            "const\nint\nchar\nfloat\nconst int *p\n*p\np\nint const *p\n*p\np\nint *p const\nint *const p\np\np\np\nconst int *p const\nconst int const *p\n*p\nconst int *const p\n*p\np\np\np\nint const *p const\nint const int *p\nint const const *p\n*p\nint const *p\nint const *const p\n*p\np\np\np",
            "const\nconst\nconst\nconst",
            "Type\nPtr_\ntemplate&lt; class Type &gt;\nusing Ptr_ = Type*;\n\nPtr_&lt;char&gt;\nchar\nPtr_&lt;const char&gt;\nconst char\nconst Ptr_&lt;const char&gt;\nconst\nconst char",
            "const\n*\nconst\n*\nconst\nconst\n*\nconst",
            "TYPE const &amp;\nTYPE&amp; TYPE::operator=(const TYPE &amp;rhs) { ... return *this; }\nTYPE &amp;  const\nconst\nTYPE const &amp;\nbool TYPE::operator==(const TYPE &amp;rhs) const { ... }\nconst TYPE TYPE::operator+(const TYPE &amp;rhs) const { ... }\nT const&amp; operator[] (unsigned i) const;\ninline T&amp; operator[] (unsigned i) {\n  return const_cast&lt;char&amp;&gt;( \n     static_cast&lt;const TYPE&amp;&gt;(*this)[](i)\n  );\n}\nint const &amp;",
            "const int *ptr=&amp;i;\n\nint const *ptr=&amp;i;\n\nconst\n*\nint *const ptr=&amp;i;\n\n const int *ptr1=&amp;i, *ptr2=&amp;j;\n\nint const *ptr1=&amp;i, *const ptr2=&amp;j;\n",
            "const\n*\nconst int\nint const\nconst\n*\nconst int *p\nint x = 5;\nconst int *p = &amp;x;\nx = 6; //legal\nprintf(\"%d\", *p) // prints 6\n*p = 7; //error \n",
            "int const v\nconst int v",
            "x\nint *p;\nint const *p;\nint * const p;\nint const * const p;\nint **pp;\nint ** const pp;\nint * const *pp;\nint const **pp;\nint * const * const pp;\nint const ** const pp;\nint const * const *pp;\nint const * const * const pp;\n// Example 1\nint x;\nx = 10;\nint *p = NULL;\np = &amp;x;\nint **pp = NULL;\npp = &amp;p;\nprintf(\"%d\\n\", **pp);\n\n// Example 2\nint x;\nx = 10;\nint *p = NULL;\np = &amp;x;\nint ** const pp = &amp;p; // Definition must happen during declaration\nprintf(\"%d\\n\", **pp);\n\n// Example 3\nint x;\nx = 10;\nint * const p = &amp;x; // Definition must happen during declaration\nint * const *pp = NULL;\npp = &amp;p;\nprintf(\"%d\\n\", **pp);\n\n// Example 4\nint const x = 10; // Definition must happen during declaration\nint const * p = NULL;\np = &amp;x;\nint const **pp = NULL;\npp = &amp;p;\nprintf(\"%d\\n\", **pp);\n\n// Example 5\nint x;\nx = 10;\nint * const p = &amp;x; // Definition must happen during declaration\nint * const * const pp = &amp;p; // Definition must happen during declaration\nprintf(\"%d\\n\", **pp);\n\n// Example 6\nint const x = 10; // Definition must happen during declaration\nint const *p = NULL;\np = &amp;x;\nint const ** const pp = &amp;p; // Definition must happen during declaration\nprintf(\"%d\\n\", **pp);\n\n// Example 7\nint const x = 10; // Definition must happen during declaration\nint const * const p = &amp;x; // Definition must happen during declaration\nint const * const *pp = NULL;\npp = &amp;p;\nprintf(\"%d\\n\", **pp);\n\n// Example 8\nint const x = 10; // Definition must happen during declaration\nint const * const p = &amp;x; // Definition must happen during declaration\nint const * const * const pp = &amp;p; // Definition must happen during declaration\nprintf(\"%d\\n\", **pp);\n\nint x = 10;\nint *p = &amp;x;\nint **pp = &amp;p;\nint ***ppp = &amp;pp;\nint ****pppp = &amp;ppp;\n\nprintf(\"%d \\n\", ****pppp);\n",
            "const\nconst\nconst\nconst\nconst\nint const *foo;\nint * const bar;\nconst\nvoid func(int param)\nvoid func(int const param)\nvoid func(int &amp;param)\nfunc\nparam\nvoid func(int const &amp;param)\nfunc\nparam\nvoid func(int *param)\nvoid func(int const *param)\nnullptr\nfunc\nnullptr\nparam\nnullptr",
            "const int*\nint\nint\nconst int * const\nint\nint\nint const *\nint\nconst int*\nint\nint * const\nint\nint\nint",
            "int i;\ni\nint\ni\nint *p;\np\n*\nint\np\nconst int *p;\np\n*\nconst int\np\nint *const p;\np\n*\nint\np\nconst int *const p;\np\n*\nconst int\np\nint a[3];\na\nint\na\nint *a[3];\na\nint *\na\nint (*a)[3];\na\n*a\n*a\n*a\na\nint i = (*a)[1];\nint (*a)[3][2];\noperator()()\noperator*()\nint *f();\nf\nint i = *f();\nint (*fp)();\nfp\n*fp\nfp\noperator()()\nfp\nint *(*fp)();\nint (*(*fp)())[3];\n(*fp) \n#include &lt;iostream&gt;\nusing namespace std;\n\nint (*f())[3]\n{\n  static int arr[3] = {1,2,3};\n  return &amp;arr;\n}\n\nint (*(*fp)())[3] = &amp;f;\n\nint main()\n{\n  for(int i=0; i&lt;3; i++)\n  {\n    cout &lt;&lt; (*(*fp)())[i] &lt;&lt; endl;\n  }\n}\n",
            "type\n*\nname\nint *i\ni\nint\nconst int *i\ni\nconst int\nint *const i\nconst i\nint\nint const *i",
            "const int a=3,b;\n\na=4;  // give error\nb=5;  // give error as b is also const int \n\nyou have to intialize while declaring itself as no way to assign\nit afterwards.\n\ntype a.    p is ptr to const int\n\ntype b.    p is const ptr to int \n \ntype c.    p is const ptr to const int\n\nif * comes before int \n\n1. const int *\n\n2. const const int *\n\n*const int p      [Error]\n*int const p      [Error]\n\nconst int *p      type a. p is ptr to const int \nconst *int p      [Error]\n\nint const *p      type a. \nint * const p     type b. p is const ptr to int\n\n* int const const p     [Error]\n* const int const p     [Error]\n* const const int p     [Error]\n \n\nint const const *p      type a. p is ptr to const int\nint const * const p     type c. p is const ptr to const int\nint * const const p     type b. p is const ptr to int\n\nconst const int *p     type a.\nconst const * int p    [Error]\n\nconst int const *p      type a.\nconst int * const p     type c.\n\nconst * int const p    [Error]\nconst * const int p    [Error]\n\nconst int *p\nint const *p\n\nint const const *p\nconst const int  *p\nconst int  const *p\n\nint * const p\nint * const const p;\n\nint const * const p\nconst int * const p\n\n1. const int * p        total arrangemets (6)   [Errors] (3)\n2. const const int * p  total arrangemets (12)  [Errors] (6)\n\nhere p is ptr to const int  (type a.) \nbut p2 is just const int please note that it is not ptr\n\nsimilarly \nhere p is const ptr to int  (type b.)   \nbut p2 is just int not even cost int\n\nhere p is const ptr to const int  (type c.)\nbut p2 is just const int. \n"
        ]
    },
    {
        "question_id": 381542,
        "question_code": "a[5] == 5[a]\na[5] == 5[a]",
        "answer_code_snippets": [
            "[]\na[b] == *(a + b)\na[5]\n*(a + 5)\n\n5[a]\n*(5 + a)\n\na\na[5]\na\n*(a + 5)",
            "a[i]\n*(a + i)",
            "p[i]\n*(p+i)\n*(i+p)\n[]\ni[p]\narray[i]\nx + y == y + x\n+\ni + p\ni[p]\n+\npointer operator+(pointer p, integer i);\n\npointer operator+(integer i, pointer p);\n\nunsigned\narr[3]\n3[arr]",
            " (\"ABCD\"[2] == 2[\"ABCD\"]) &amp;&amp; (2[\"ABCD\"] == 'C') &amp;&amp; (\"ABCD\"[2] == 'C')\n\nX[Y]\n*(X+Y)\n+=\n++\nA = B + C\nA += C\nC\n1",
            "sizeof",
            "x == x\ndouble zero = 0.0;\ndouble a[] = { 0,0,0,0,0, zero/zero}; // NaN\ncout &lt;&lt; (a[5] == 5[a] ? \"true\" : \"false\") &lt;&lt; endl;\n\nfalse\n",
            "int a[] = { 2 , 3 , 3 , 2 , 4 };\nint s = sizeof a / sizeof *a;  //  s == 5\n\nfor(int i = 0 ; i &lt; s ; ++i) {  \n           \n    cout &lt;&lt; a[a[a[i]]] &lt;&lt; endl;\n    // ... is equivalent to ...\n    cout &lt;&lt; i[a][a][a] &lt;&lt; endl;  // but I prefer this one, it's easier to increase the level of indirection (without loop)\n    \n}\n",
            "int a[10];\nint* p = a;\n\na.out\na\np",
            "a[5] == *(a + 5)\n\n5[a] == *(5 + a)\n\na[5] == 5[a].",
            "0[x]\nclass Sub\n{\npublic:\n    int operator [](size_t nIndex)\n    {\n        return 0;\n    }   \n};\n\nint main()\n{\n    Sub s;\n    s[0];\n    0[s]; // ERROR \n}\n\nclass int\n{\n   int operator[](const Sub&amp;);\n};\n",
            "a[i]\n*(a + i)\n(a + i)\n(i + a)\n*(i + a)\n*(a + i)\n*(i + a)\ni[a]\nchar a[20];\n\na[3] = 'x';\n\n3[a] = 'x';\n",
            "a\nint\nint\na\na[5]\nBase Address of your Array a + (5*size of(data type for array a))\ni.e. 1000 + (5*2) = 1010\n\n5[a]\nBase Address of your Array a + (size of(data type for array a)*5)\ni.e. 1000 + (2*5) = 1010 \n\na[5] = 5[a]\na[-5]\nBase Address of your Array a + (-5 * size of(data type for array a))\ni.e. 1000 + (-5*2) = 990\n",
            "let V = vec 10\n\nlet J = V!5\n\nJ = !(V + 5)\nV!5\n5!V\n!\nsizeof",
            "arr[3]\n3[arr]\n*(arr + 3)\n*(3 + arr)\n[arr]3\n[3]arr\n(arr + 3)*\n(3 + arr)*",
            "a[i]\ni[a]\n*(a+i)\n",
            "!X\nX!Y\n!(X+Y)\nX!Y\nX[Y]\n!(X+Y)",
            "a[i]\n*(a+i)\n5[a]\n*(5+a)\ntrue",
            "a[5] = *(a + 5)\n5[a] = *(5 + a) = *(a + 5)",
            "array[array[head].next].prev\n\nhead[array].next[array].prev\n\ng(f(x))\nx.f().g()\ng[f[x]]\n(x[f])[g]\nx[xs].y[ys].z[zs]\nzs[ys[xs[x].y].z]",
            " int a[]={10,20,30,40,50};\n int *p=a;\n printf(&quot;%d\\n&quot;,*p++);//output will be 10\n printf(&quot;%d\\n&quot;,*a++);//will give an error\n\np\na\np++\na++\na[2]\n2[a]\n*(a+2)\n*(2+a)"
        ]
    },
    {
        "question_id": 9229601,
        "question_code": "/usr/include/linux/kernel.h\n/* Force a compilation error if condition is true, but also produce a\n   result (of value 0 and type size_t), so the expression can be used\n   e.g. in a structure initializer (or where-ever else comma expressions\n   aren't permitted). */\n#define BUILD_BUG_ON_ZERO(e) (sizeof(struct { int:-!!(e); }))\n#define BUILD_BUG_ON_NULL(e) ((void *)sizeof(struct { int:-!!(e); }))\n\n:-!!\n/usr/include/linux/build_bug.h",
        "answer_code_snippets": [
            "BUILD_BUG_OR_ZERO\n...ON_ZERO\nsizeof(struct { int: -!!(e); }))\n\n(e)\ne\n!!(e)\n0\ne == 0\n1\n-!!(e)\n0\n0\n-1\nstruct{int: -!!(0);} --&gt; struct{int: 0;}\nstruct{int: -!!(1);} --&gt; struct{int: -1;}\nsizeof\nsize_t\ne\nassert",
            ":\n!!\n0\n1\n-\nBUILD_BUG_ON_ZERO\n-!!(e)\n-!!(e)\nsize_t\nBUILD_BUG_ON_NULL\nint",
            "assert()\nassert()\n_Static_assert()",
            "#define MY_COMPILETIME_ASSERT(test)              \\\n    do {                                         \\\n        extern void you_did_something_bad(void); \\\n        if (!(test))                             \\\n            you_did_something_bad(void);         \\\n    } while (0)\n\nerror\n#define MAKE_SURE_THIS_IS_FIVE(number)                          \\\n    do {                                                        \\\n        extern void this_isnt_five(void) __attribute__((error(  \\\n                &quot;I asked for five and you gave me &quot; #number))); \\\n        if ((number) != 5)                                      \\\n            this_isnt_five();                                   \\\n    } while (0)\n\ncompiletime_assert\nbug.h\n#define ANY_NUMBER_BUT_FIVE(number)                           \\\n    ({                                                        \\\n        typeof(number) n = (number);                          \\\n        extern void this_number_is_five(void) __attribute__(( \\\n                error(&quot;I told you not to give me a five!&quot;))); \\\n        if (n == 5)                                           \\\n            this_number_is_five();                            \\\n        n;                                                    \\\n    })\n\n__builtin_constant_p()",
            "0\n-1\n-!!1\n-1"
        ]
    },
    {
        "question_id": 12135518,
        "question_code": "if (a &lt; 901)\nif (a &lt;= 900)",
        "answer_code_snippets": [
            "test\ncmp\nEFLAGS\nJcc\njne\nZF = 0\njz\nZF = 1\njg\nZF = 0 and SF = OF\n$ gcc -m32 -S -masm=intel test.c\n    if (a &lt; b) {\n        // Do something 1\n    }\n\n    mov     eax, DWORD PTR [esp+24]      ; a\n    cmp     eax, DWORD PTR [esp+28]      ; b\n    jge     .L2                          ; jump if a is &gt;= b\n    ; Do something 1\n.L2:\n\n    if (a &lt;= b) {\n        // Do something 2\n    }\n\n    mov     eax, DWORD PTR [esp+24]      ; a\n    cmp     eax, DWORD PTR [esp+28]      ; b\n    jg      .L5                          ; jump if a is &gt; b\n    ; Do something 2\n.L5:\n\njg\njge\nJcc\nJcc\n      Latency   Throughput\nJcc     N/A        0.5\n\nJcc\njcc\nJcc\nEFLAGS\ndouble\nint\n        fld     QWORD PTR [esp+32]\n        fld     QWORD PTR [esp+40]\n        fucomip st, st(1)              ; Compare ST(0) and ST(1), and set CF, PF, ZF in EFLAGS\n        fstp    st(0)\n        seta    al                     ; Set al if above (CF=0 and ZF=0).\n        test    al, al\n        je      .L2\n        ; Do something 1\n.L2:\n\n        fld     QWORD PTR [esp+32]\n        fld     QWORD PTR [esp+40]\n        fucomip st, st(1)              ; (same thing as above)\n        fstp    st(0)\n        setae   al                     ; Set al if above or equal (CF=0).\n        test    al, al\n        je      .L5\n        ; Do something 2\n.L5:\n        leave\n        ret\n",
            "Comparison     Subtraction\n----------     -----------\nA &lt; B      --&gt; A - B &lt; 0\nA = B      --&gt; A - B = 0\nA &gt; B      --&gt; A - B &gt; 0\n\nA &lt; B\nComparison     Subtraction  Carry Bit  Zero Bit\n----------     -----------  ---------  --------\nA &lt; B      --&gt; A - B &lt; 0    0          0\nA = B      --&gt; A - B = 0    1          1\nA &gt; B      --&gt; A - B &gt; 0    1          0\n\nA &lt; B\n;; Implementation of \"if (A &lt; B) goto address;\"\ncmp  A, B          ;; compare A to B\nbcz  address       ;; Branch if Carry is Zero to the new address\n\n;; Implementation of \"if (A &lt;= B) goto address;\"\ncmp A, B           ;; compare A to B\nbcz address        ;; branch if A &lt; B\nbzs address        ;; also, Branch if the Zero bit is Set\n",
            "&lt;\n&lt;=\n&lt;=\n&lt;",
            "if(a &lt; 901)\ncmpl  $900, -4(%rbp)\njg .L2\n\nif(a &lt;=901)\ncmpl  $901, -4(%rbp)\njg .L3\n\nif\nint b;\nif(a &lt; b)\ncmpl  -4(%rbp), %eax\njge   .L2\n\nif(a &lt;=b)\ncmpl  -4(%rbp), %eax\njg .L3\n",
            "int compare_strict(double a, double b) { return a &lt; b; }\n\ncr\nint compare_loose(double a, double b) { return a &lt;= b; }\n\ncompare_strict\ncror\ncompare_loose\ncompare_strict\nint compare_loose(double a, double b) { return ! (a &gt; b); }\n\nNaN1 &lt;= NaN2\nNaN1 &gt; NaN2",
            "a &gt; 0\na &gt;= 1\n0\nCMP\nOR\n&lt;",
            "&lt;\n&lt;=",
            "a &lt; 901\na &lt;= 900\n&lt;\n&lt;=\ncmp r0, #0x00f000\ncmp r0, #0x00efff\ncmp\ncmn\n&lt;=\n&lt;\n&lt;=\n&lt;=\n&lt;\n++i &lt;= size\nvoid foo(unsigned size) {\n    unsigned upper_bound = size - 1;  // or any calculation that could produce UINT_MAX\n    for(unsigned i=0 ; i &lt;= upper_bound ; i++)\n        ...\n\ni &lt;= size\nsize=0\nupper_bound=UINT_MAX\ni &lt;= UINT_MAX\nsize=0\ni &lt; size\nif(!size) skip the loop;\ndo{...}while(--size);\nfor( i&lt;size )\ni\nsize==0\ni &lt;= n\nsum(1 .. n)\nn * (n+1) / 2\nunsigned sum_1_to_n_finite(unsigned n) {\n    unsigned total = 0;\n    for (unsigned i = 0 ; i &lt; n+1 ; ++i)\n        total += i;\n    return total;\n}\n\n # clang7.0 -O3 closed-form\n    cmp     edi, -1       # n passed in EDI: x86-64 System V calling convention\n    je      .LBB1_1       # if (n == UINT_MAX) return 0;  // C++ loop runs 0 times\n          # else fall through into the closed-form calc\n    mov     ecx, edi         # zero-extend n into RCX\n    lea     eax, [rdi - 1]   # n-1\n    imul    rax, rcx         # n * (n-1)             # 64-bit\n    shr     rax              # n * (n-1) / 2\n    add     eax, edi         # n + (stuff / 2) = n * (n+1) / 2   # truncated to 32-bit\n    ret          # computed without possible overflow of the product before right shifting\n.LBB1_1:\n    xor     eax, eax\n    ret\n\nunsigned sum_1_to_n_naive(unsigned n) {\n    unsigned total = 0;\n    for (unsigned i = 0 ; i&lt;=n ; ++i)\n        total += i;\n    return total;\n}\n\n# clang7.0 -O3\nsum_1_to_n(unsigned int):\n    xor     ecx, ecx           # i = 0\n    xor     eax, eax           # retval = 0\n.LBB0_1:                       # do {\n    add     eax, ecx             # retval += i\n    add     ecx, 1               # ++1\n    cmp     ecx, edi\n    jbe     .LBB0_1            # } while( i&lt;n );\n    ret\n\ni\n# &quot;naive&quot; inner loop\n.L3:\n    add     eax, 1       # do {\n    paddd   xmm0, xmm1    # vect_total_4.6, vect_vec_iv_.5\n    paddd   xmm1, xmm2    # vect_vec_iv_.5, tmp114\n    cmp     edx, eax      # bnd.1, ivtmp.14     # bound and induction-variable tmp, I think.\n    ja      .L3 #,       # }while( n &gt; i )\n\n &quot;finite&quot; inner loop\n  # before the loop:\n  # xmm0 = 0 = totals\n  # xmm1 = {0,1,2,3} = i\n  # xmm2 = set1_epi32(4)\n .L13:                # do {\n    add     eax, 1       # i++\n    paddd   xmm0, xmm1    # total[0..3] += i[0..3]\n    paddd   xmm1, xmm2    # i[0..3] += 4\n    cmp     eax, edx\n    jne     .L13      # }while( i != upper_limit );\n\n     then horizontal sum xmm0\n     and peeled cleanup for the last n%3 iterations, or something.\n     \n\nn\nsub eax,1\njnz\nadd eax,1",
            "a + 1\na - 1",
            "&gt;=\n&lt;=\n&gt;\n&lt;\nmsb\na &gt;= b\na-b &gt;= 0\na-b\na &lt;= b\n0 &lt;= b-a\nb-a\na &lt; b\na-b &lt; 0\na-b\na &gt; b\n0 &gt; b-a\nb-a\na &gt;= b\nmsb(a-b)==0\na &lt;= b\nmsb(b-a)==0\na &gt;  b\nmsb(b-a)==1\na &lt;  b\nmsb(a-b)==1\n==0\n==1\n==0\nmsb\na &gt;= b\na&gt;b || a==b"
        ]
    },
    {
        "question_id": 36827659,
        "question_code": "",
        "answer_code_snippets": [
            "new\ndelete\nnew",
            "objdump",
            "log(n)\nn",
            ".data\n.bss\nstatic\n=\n.data\n.bss",
            "x==42\nx\nx\nvolatile\n... code that checks system state\nif (system_state_favors_activation)\n{\n  prepare_for_activation();\n  ... code that checks system state again\n  if (system_state_is_valid)\n  {\n    if (system_state_favors_activation)\n      trigger_activation();\n  }\n  else\n    perform_safety_shutdown_and_restart();\n}\ncancel_preparations();\n\nprepare_for_activation()\nprepare_for_activation()\nprepare_for_activation()\nprepare_for_activation()\ntrigger_activation()\ntrigger_activation()\nprepare_for_activation()\ncancel_preparations()\nprepare_for_activation()\ntrigger_activation()",
            "x\nx1\nx2\nx3\n(x1 == x2) ? x2 : x3",
            "n\nn",
            "uint32_t\ndouble\nint64_t\nSAFE_uint32_t",
            "nb_error_recoverable == (x-2)",
            "lw $3, 0x0($2)\n$2\n$3\nnop",
            "gcc\n-mmitigate-rop\n-fstack-protector-all\n-­D_FORTIFY_SOURCE=2\n-Wl,-z,relro,-z,now\n-Wl,-z,noexecstack"
        ]
    },
    {
        "question_id": 840501,
        "question_code": "",
        "answer_code_snippets": [
            "int addInt(int n, int m) {\n    return n+m;\n}\n\nint\nint\nint (*functionPtr)(int,int);\n\nfunctionPtr = &amp;addInt;\n\nint sum = (*functionPtr)(2, 3); // sum == 5\n\nint add2to3(int (*functionPtr)(int, int)) {\n    return (*functionPtr)(2, 3);\n}\n\n// this is a function called functionFactory which receives parameter n\n// and returns a pointer to another function which receives two ints\n// and it returns another int\nint (*functionFactory(int n))(int, int) {\n    printf(\"Got parameter %d\", n);\n    int (*functionPtr)(int,int) = &amp;addInt;\n    return functionPtr;\n}\n\ntypedef\ntypedef int (*myFuncDef)(int, int);\n// note that the typedef name is indeed myFuncDef\n\nmyFuncDef functionFactory(int n) {\n    printf(\"Got parameter %d\", n);\n    myFuncDef functionPtr = &amp;addInt;\n    return functionPtr;\n}\n",
            "String s1 = newString();\ns1-&gt;set(s1, \"hello\");\n\n-&gt;\nnew\nString\n\"hello\"\nString\nstruct\nString\ntypedef struct String_Struct* String;\n\nstruct String_Struct\n{\n    char* (*get)(const void* self);\n    void (*set)(const void* self, char* value);\n    int (*length)(const void* self);\n};\n\nchar* getString(const void* self);\nvoid setString(const void* self, char* value);\nint lengthString(const void* self);\n\nString newString();\n\nString\nString\nnewString\nString newString()\n{\n    String self = (String)malloc(sizeof(struct String_Struct));\n\n    self-&gt;get = &amp;getString;\n    self-&gt;set = &amp;setString;\n    self-&gt;length = &amp;lengthString;\n\n    self-&gt;set(self, \"\");\n\n    return self;\n}\n\ngetString\nget\nchar* getString(const void* self_obj)\n{\n    return ((String)self_obj)-&gt;internal-&gt;value;\n}\n\ninternal\nstruct\ns1-&gt;set(\"hello\");\ns1-&gt;set(s1, \"hello\")\nString\nImmutableString\nset\nget\nlength\nchar*\ntypedef struct ImmutableString_Struct* ImmutableString;\n\nstruct ImmutableString_Struct\n{\n    String base;\n\n    char* (*get)(const void* self);\n    int (*length)(const void* self);\n};\n\nImmutableString newImmutableString(const char* value);\n\nset\nImmutableString\nImmutableString\nnewImmutableString\nImmutableString newImmutableString(const char* value)\n{\n    ImmutableString self = (ImmutableString)malloc(sizeof(struct ImmutableString_Struct));\n\n    self-&gt;base = newString();\n\n    self-&gt;get = self-&gt;base-&gt;get;\n    self-&gt;length = self-&gt;base-&gt;length;\n\n    self-&gt;base-&gt;set(self-&gt;base, (char*)value);\n\n    return self;\n}\n\nImmutableString\nget\nlength\nString.get\nString.length\nbase\nString\nlength\n0\nImmutableString\nlength\nlength\nlength\nImmutableString\nlengthOverrideMethod\nint lengthOverrideMethod(const void* self)\n{\n    return 0;\n}\n\nlength\nlengthOverrideMethod\nImmutableString newImmutableString(const char* value)\n{\n    ImmutableString self = (ImmutableString)malloc(sizeof(struct ImmutableString_Struct));\n\n    self-&gt;base = newString();\n\n    self-&gt;get = self-&gt;base-&gt;get;\n    self-&gt;length = &amp;lengthOverrideMethod;\n\n    self-&gt;base-&gt;set(self-&gt;base, (char*)value);\n\n    return self;\n}\n\nlength\nImmutableString\nString\nlength\nlengthOverrideMethod",
            "0xC3\nret\nnasm\nint eax = ((int(*)())(\"\\xc3 &lt;- This returns the value of the EAX register\"))();\n\nint a = 10, b = 20;\n((void(*)(int*,int*))\"\\x8b\\x44\\x24\\x04\\x8b\\x5c\\x24\\x08\\x8b\\x00\\x8b\\x1b\\x31\\xc3\\x31\\xd8\\x31\\xc3\\x8b\\x4c\\x24\\x04\\x89\\x01\\x8b\\x4c\\x24\\x08\\x89\\x19\\xc3 &lt;- This swaps the values of a and b\")(&amp;a,&amp;b);\n\n((int(*)())\"\\x66\\x31\\xc0\\x8b\\x5c\\x24\\x04\\x66\\x40\\x50\\xff\\xd3\\x58\\x66\\x3d\\xe8\\x03\\x75\\xf4\\xc3\")(&amp;function); // calls function with 1-&gt;1000\n\nconst char* lol = \"\\x8b\\x5c\\x24\\x4\\x3d\\xe8\\x3\\x0\\x0\\x7e\\x2\\x31\\xc0\\x83\\xf8\\x64\\x7d\\x6\\x40\\x53\\xff\\xd3\\x5b\\xc3\\xc3 &lt;- Recursively calls the function at address lol.\";\ni = ((int(*)())(lol))(lol);\n\n.rodata\n.rdata\nmprotect()\nVirtualProtect()\ngcc -z execstack\n// at global scope\nconst char swap[] = \"\\x8b\\x44\\x24\\x04\\x8b\\x5c\\x24\\x08\\x8b\\x00\\x8b\\x1b\\x31\\xc3\\x31\\xd8\\x31\\xc3\\x8b\\x4c\\x24\\x04\\x89\\x01\\x8b\\x4c\\x24\\x08\\x89\\x19\\xc3 &lt;- This swaps the values of a and b\";\n\ngcc -c -m32 foo.c\nobjdump -D -rwC -Mintel\n00000000 &lt;swap&gt;:\n   0:   8b 44 24 04             mov    eax,DWORD PTR [esp+0x4]   # load int *a arg from the stack\n   4:   8b 5c 24 08             mov    ebx,DWORD PTR [esp+0x8]   # ebx = b\n   8:   8b 00                   mov    eax,DWORD PTR [eax]       # dereference: eax = *a\n   a:   8b 1b                   mov    ebx,DWORD PTR [ebx]\n   c:   31 c3                   xor    ebx,eax                # pointless xor-swap\n   e:   31 d8                   xor    eax,ebx                # instead of just storing with opposite registers\n  10:   31 c3                   xor    ebx,eax\n  12:   8b 4c 24 04             mov    ecx,DWORD PTR [esp+0x4]  # reload a from the stack\n  16:   89 01                   mov    DWORD PTR [ecx],eax     # store to *a\n  18:   8b 4c 24 08             mov    ecx,DWORD PTR [esp+0x8]\n  1c:   89 19                   mov    DWORD PTR [ecx],ebx\n  1e:   c3                      ret    \n\n  not shown: the later bytes are ASCII text documentation\n  they're not executed by the CPU because the ret instruction sends execution back to the caller\n",
            "#include &lt;stdio.h&gt;\n#define MAX_COLORS  256\n\ntypedef struct {\n    char* name;\n    int red;\n    int green;\n    int blue;\n} Color;\n\nColor Colors[MAX_COLORS];\n\n\nvoid eachColor (void (*fp)(Color *c)) {\n    int i;\n    for (i=0; i&lt;MAX_COLORS; i++)\n        (*fp)(&amp;Colors[i]);\n}\n\nvoid printColor(Color* c) {\n    if (c-&gt;name)\n        printf(\"%s = %i,%i,%i\\n\", c-&gt;name, c-&gt;red, c-&gt;green, c-&gt;blue);\n}\n\nint main() {\n    Colors[0].name=\"red\";\n    Colors[0].red=255;\n    Colors[1].name=\"blue\";\n    Colors[1].blue=255;\n    Colors[2].name=\"black\";\n\n    eachColor(printColor);\n}\n",
            "ID\n*D\nD(&lt;parameters&gt;)\n&lt;\n&gt;\nID\ntypedef int ReturnFunction(char);\ntypedef int ParameterFunction(void);\nReturnFunction *f(ParameterFunction *p);\n\n[\n]\nfunction taking \n    [pointer to [function taking [void] returning [int]]] \nreturning\n    [pointer to [function taking [char] returning [int]]]\n\nD1(char);\n\nD1\n*D2\n*D2\n*-operator\n()\n*(D2(char p))\n*D2\n(*D2)(char);\n\nD2\n&lt;parameters&gt;\nD3(&lt;parameters&gt;)\n(*D3(&lt;parameters&gt;))(char)\n\nD3\nchar\nvoid\n(*D3(   (*ID1)(void)))(char)\n\nD2\nID1\nID1\nint\nint (*ID0(int (*ID1)(void)))(char)\n\nID0\n&lt;\n&gt;\nID0(&lt;parameters&gt;)\n\n*ID0(&lt;parameters&gt;)\n\n&lt;\n&gt;\n(*ID0(&lt;parameters&gt;))(char)\n\n*\n(char)\n&lt;\n&gt;\n&lt;\n&gt;\npointer to: *ID1\n... function taking void returning: (*ID1)(void)\n\nint\nint (*ID0(int (*ID1)(void)))(char)\n\nint v = (*ID0(some_function_pointer))(some_char);\n",
            "printf\n// First, undefine all macros associated with version.h\n#undef DEBUG_VERSION\n#undef RELEASE_VERSION\n#undef INVALID_VERSION\n\n\n// Define which version we want to use\n#define DEBUG_VERSION       // The current version\n// #define RELEASE_VERSION  // To be uncommented when finished debugging\n\n#ifndef __VERSION_H_      /* prevent circular inclusions */\n    #define __VERSION_H_  /* by using protection macros */\n    void board_init();\n    void noprintf(const char *c, ...); // mimic the printf prototype\n#endif\n\n// Mimics the printf function prototype. This is what I'll actually \n// use to print stuff to the screen\nvoid (* zprintf)(const char*, ...); \n\n// If debug version, use printf\n#ifdef DEBUG_VERSION\n    #include &lt;stdio.h&gt;\n#endif\n\n// If both debug and release version, error\n#ifdef DEBUG_VERSION\n#ifdef RELEASE_VERSION\n    #define INVALID_VERSION\n#endif\n#endif\n\n// If neither debug or release version, error\n#ifndef DEBUG_VERSION\n#ifndef RELEASE_VERSION\n    #define INVALID_VERSION\n#endif\n#endif\n\n#ifdef INVALID_VERSION\n    // Won't allow compilation without a valid version define\n    #error \"Invalid version definition\"\n#endif\n\nversion.c\nversion.h\n#include \"version.h\"\n\n/*****************************************************************************/\n/**\n* @name board_init\n*\n* Sets up the application based on the version type defined in version.h.\n* Includes allowing or prohibiting printing to STDOUT.\n*\n* MUST BE CALLED FIRST THING IN MAIN\n*\n* @return    None\n*\n*****************************************************************************/\nvoid board_init()\n{\n    // Assign the print function to the correct function pointer\n    #ifdef DEBUG_VERSION\n        zprintf = &amp;printf;\n    #else\n        // Defined below this function\n        zprintf = &amp;noprintf;\n    #endif\n}\n\n/*****************************************************************************/\n/**\n* @name noprintf\n*\n* simply returns with no actions performed\n*\n* @return   None\n*\n*****************************************************************************/\nvoid noprintf(const char* c, ...)\n{\n    return;\n}\n\nversion.h\nvoid (* zprintf)(const char *, ...);\nversion.c\nboard_init()\nzprintf\nversion.h\nzprintf = &printf;\nzprintf = &noprint;\n#include \"version.h\"\n#include &lt;stdlib.h&gt;\nint main()\n{\n    // Must run board_init(), which assigns the function\n    // pointer to an actual function\n    board_init();\n\n    void *ptr = malloc(100); // Allocate 100 bytes of memory\n    // malloc returns NULL if unable to allocate the memory.\n\n    if (ptr == NULL)\n    {\n        zprintf(\"Unable to allocate memory\\n\");\n        return 1;\n    }\n\n    // Other things to do...\n    return 0;\n}\n\nprintf\nversion.h",
            "typedef\n#include &lt;stdio.h&gt;\n\n#define NUM_A 1\n#define NUM_B 2\n\n// define a function pointer type\ntypedef int (*two_num_operation)(int, int);\n\n// an actual standalone function\nstatic int sum(int a, int b) {\n    return a + b;\n}\n\n// use function pointer as param,\nstatic int sum_via_pointer(int a, int b, two_num_operation funp) {\n    return (*funp)(a, b);\n}\n\n// use function pointer as return value,\nstatic two_num_operation get_sum_fun() {\n    return &amp;sum;\n}\n\n// test - use function pointer as variable,\nvoid test_pointer_as_variable() {\n    // create a pointer to function,\n    two_num_operation sum_p = &amp;sum;\n    // call function via pointer\n    printf(\"pointer as variable:\\t %d + %d = %d\\n\", NUM_A, NUM_B, (*sum_p)(NUM_A, NUM_B));\n}\n\n// test - use function pointer as param,\nvoid test_pointer_as_param() {\n    printf(\"pointer as param:\\t %d + %d = %d\\n\", NUM_A, NUM_B, sum_via_pointer(NUM_A, NUM_B, &amp;sum));\n}\n\n// test - use function pointer as return value,\nvoid test_pointer_as_return_value() {\n    printf(\"pointer as return value:\\t %d + %d = %d\\n\", NUM_A, NUM_B, (*get_sum_fun())(NUM_A, NUM_B));\n}\n\nint main() {\n    test_pointer_as_variable();\n    test_pointer_as_param();\n    test_pointer_as_return_value();\n\n    return 0;\n}\n",
            "#include&lt;stdio.h&gt;\nvoid (*print)() ;//Declare a  Function Pointers\nvoid sayhello();//Declare The Function Whose Address is to be passed\n                //The Functions should Be of Same Type\nint main()\n{\n print=sayhello;//Addressof sayhello is assigned to print\n print();//print Does A call To The Function \n return 0;\n}\n\nvoid sayhello()\n{\n printf(\"\\n Hello World\");\n}\n",
            "int func (int a, char *pStr);    // declares a function\n\nint (*pFunc)(int a, char *pStr);  // declares or defines a function pointer\n\nint (*pFunc2) ();                 // declares or defines a function pointer, no parameter list specified.\n\nint (*pFunc3) (void);             // declares or defines a function pointer, no arguments.\n\nfunc\nint\nchar *\nint\npFunc\nint\nchar *\nint\nfunc()\npFunc\npFunc = func;\nint *pfunc(int a, char *pStr);    // declares a function that returns int pointer\nint (*pFunc)(int a, char *pStr);  // declares a function pointer that returns an int\n\nint (*pFunc) (int a, char *pStr);    // declare a simple function pointer variable\nint (*pFunc[55])(int a, char *pStr); // declare an array of 55 function pointers\nint (**pFunc)(int a, char *pStr);    // declare a pointer to a function pointer variable\nstruct {                             // declare a struct that contains a function pointer\n    int x22;\n    int (*pFunc)(int a, char *pStr);\n} thing = {0, func};                 // assign values to the struct variable\nchar * xF (int x, int (*p)(int a, char *pStr));  // declare a function that has a function pointer as an argument\nchar * (*pxF) (int x, int (*p)(int a, char *pStr));  // declare a function pointer that points to a function that has a function pointer as an argument\n\nint sum (int a, int b, ...);\nint (*psum)(int a, int b, ...);\n\nint  sum ();      // nothing specified in the argument list so could be anything or nothing\nint (*psum)();\nint  sum2(void);  // void specified in the argument list so no parameters when calling this function\nint (*psum2)(void);\n\nint sum (int a, char *b);\nint (*psplsum) (int a, int b);\npsplsum = sum;               // generates a compiler warning\npsplsum = (int (*)(int a, int b)) sum;   // no compiler warning, cast to function pointer\npsplsum = (int *(int a, int b)) sum;     // compiler error of bad cast generated, parenthesis are required.\n\nif\nstatic int func1(int a, int b) {\n    return a + b;\n}\n\nstatic int func2(int a, int b, char *c) {\n    return c[0] + a + b;\n}\n\nstatic int func3(int a, int b, char *x) {\n    return a + b;\n}\n\nstatic char *func4(int a, int b, char *c, int (*p)())\n{\n    if (p == func1) {\n        p(a, b);\n    }\n    else if (p == func2) {\n        p(a, b, c);      // warning C4047: '==': 'int (__cdecl *)()' differs in levels of indirection from 'char *(__cdecl *)(int,int,char *)'\n    } else if (p == func3) {\n        p(a, b, c);\n    }\n    return c;\n}\n\nvoid\nint(*p[])() = {       // an array of function pointers\n    func1, func2, func3\n};\nint(**pp)();          // a pointer to a function pointer\n\n\np[0](a, b);\np[1](a, b, 0);\np[2](a, b);      // oops, left off the last argument but it compiles anyway.\n\nfunc4(a, b, 0, func1);\nfunc4(a, b, 0, func2);  // warning C4047: 'function': 'int (__cdecl *)()' differs in levels of indirection from 'char *(__cdecl *)(int,int,char *)'\nfunc4(a, b, 0, func3);\n\n    // iterate over the array elements using an array index\nfor (i = 0; i &lt; sizeof(p) / sizeof(p[0]); i++) {\n    func4(a, b, 0, p[i]);\n}\n    // iterate over the array elements using a pointer\nfor (pp = p; pp &lt; p + sizeof(p)/sizeof(p[0]); pp++) {\n    (*pp)(a, b, 0);          // pointer to a function pointer so must dereference it.\n    func4(a, b, 0, *pp);     // pointer to a function pointer so must dereference it.\n}\n\nnamespace\nstruct\nstatic\nnamespace\ntypedef struct {\n   int (*func1) (int a, int b);             // pointer to function that returns an int\n   char *(*func2) (int a, int b, char *c);  // pointer to function that returns a pointer\n} FuncThings;\n\nextern const FuncThings FuncThingsGlobal;\n\n#include \"header.h\"\n\n// the function names used with these static functions do not need to be the\n// same as the struct member names. It's just helpful if they are when trying\n// to search for them.\n// the static keyword ensures these names are file scope only and not visible\n// outside of the file.\nstatic int func1 (int a, int b)\n{\n    return a + b;\n}\n\nstatic char *func2 (int a, int b, char *c)\n{\n    c[0] = a % 100; c[1] = b % 50;\n    return c;\n}\n\nconst FuncThings FuncThingsGlobal = {func1, func2};\n\nconst\nint abcd = FuncThingsGlobal.func1 (a, b);\n\nnamespace\nstruct\ntypedef struct {\n    HMODULE  hModule;\n    int (*Func1)();\n    int (*Func2)();\n    int(*Func3)(int a, int b);\n} LibraryFuncStruct;\n\nint  LoadLibraryFunc LPCTSTR  dllFileName, LibraryFuncStruct *pStruct)\n{\n    int  retStatus = 0;   // default is an error detected\n\n    pStruct-&gt;hModule = LoadLibrary (dllFileName);\n    if (pStruct-&gt;hModule) {\n        pStruct-&gt;Func1 = (int (*)()) GetProcAddress (pStruct-&gt;hModule, \"Func1\");\n        pStruct-&gt;Func2 = (int (*)()) GetProcAddress (pStruct-&gt;hModule, \"Func2\");\n        pStruct-&gt;Func3 = (int (*)(int a, int b)) GetProcAddress(pStruct-&gt;hModule, \"Func3\");\n        retStatus = 1;\n    }\n\n    return retStatus;\n}\n\nvoid FreeLibraryFunc (LibraryFuncStruct *pStruct)\n{\n    if (pStruct-&gt;hModule) FreeLibrary (pStruct-&gt;hModule);\n    pStruct-&gt;hModule = 0;\n}\n\nLibraryFuncStruct myLib = {0};\nLoadLibraryFunc (L\"library.dll\", &amp;myLib);\n//  ....\nmyLib.Func1();\n//  ....\nFreeLibraryFunc (&amp;myLib);\n\nqsort()\nbsearch()\nvoid * ApplyAlgorithm (void *pArray, size_t sizeItem, size_t nItems, int (*p)(void *)) {\n    unsigned char *pList = pArray;\n    unsigned char *pListEnd = pList + nItems * sizeItem;\n    for ( ; pList &lt; pListEnd; pList += sizeItem) {\n        p (pList);\n    }\n\n    return pArray;\n}\n\nint pIncrement(int *pI) {\n    (*pI)++;\n\n    return 1;\n}\n\nvoid * ApplyFold(void *pArray, size_t sizeItem, size_t nItems, void * pResult, int(*p)(void *, void *)) {\n    unsigned char *pList = pArray;\n    unsigned char *pListEnd = pList + nItems * sizeItem;\n    for (; pList &lt; pListEnd; pList += sizeItem) {\n        p(pList, pResult);\n    }\n\n    return pArray;\n}\n\nint pSummation(int *pI, int *pSum) {\n    (*pSum) += *pI;\n\n    return 1;\n}\n\n// source code and then lets use our function.\nint intList[30] = { 0 }, iSum = 0;\n\nApplyAlgorithm(intList, sizeof(int), sizeof(intList) / sizeof(intList[0]), pIncrement);\nApplyFold(intList, sizeof(int), sizeof(intList) / sizeof(intList[0]), &amp;iSum, pSummation);\n",
            "qsort\nbsearch\nprint(int x, int y)\nadd()\nsub()\nprint()\n#include &lt;stdio.h&gt;\n\nint add()\n{\n   return (100+10);\n}\n\nint sub()\n{\n   return (100-10);\n}\n\nvoid print(int x, int y, int (*func)())\n{\n    printf(\"value is: %d\\n\", (x+y+(*func)()));\n}\n\nint main()\n{\n    int x=100, y=200;\n    print(x,y,add);\n    print(x,y,sub);\n\n    return 0;\n}\n",
            "// Say you have add function\nint add(int x, int y){\n    return x + y;\n}\n\n// Say you have another add function\nint another_add(int x, int y){\n    return y + x;\n}\n\n\nint main(){\n    // Although the types of another_add and add are same\n    // You can't do\n    another_add = add\n    \n    // You have a compute function that takes a function of int's signature\n    int (*compute)(int, int);\n   \n    // You won't even be able to pass functions to other functions\n    // (Although when you do, C is just passing the pointer to that function)\n    // So, compute(add) is really compute(&amp;add)\n    // But you can create a pointer to functions that are variables\n    // you can assign to and/or pass to other functions\n\n    int (*operation)(int, int);\n    // Now you can do\n    operation = &amp;add;\n    // You could also do, the following to do the same thing\n    // When a function is passed in right hand side of assignment,\n    // C knows that you mean pointer, and you don't need explicit &amp;\n    operation = add;\n}\n"
        ]
    },
    {
        "question_id": 572547,
        "question_code": "static",
        "answer_code_snippets": [
            "static\n#include &lt;stdio.h&gt;\n\nvoid foo()\n{\n    int a = 10;\n    static int sa = 10;\n    \n    a += 5;\n    sa += 5;\n    \n    printf(&quot;a = %d, sa = %d\\n&quot;, a, sa);\n}\n\n\nint main()\n{\n    int i;\n    \n    for (i = 0; i &lt; 10; ++i)\n        foo();\n}\n\na = 15, sa = 15\na = 15, sa = 20\na = 15, sa = 25\na = 15, sa = 30\na = 15, sa = 35\na = 15, sa = 40\na = 15, sa = 45\na = 15, sa = 50\na = 15, sa = 55\na = 15, sa = 60\n\nstatic\nstatic\nstatic\nstatic\nstatic\nvoid func(int foo[static 42]);\n\nfunc()\nstatic",
            "int someFunction(char arg[static 10])\n{\n    ...\n}\n\nchar",
            "#include &lt;stdio.h&gt;\n\n/*\nUndefined behavior: already defined in main.\nBinutils 2.24 gives an error and refuses to link.\nhttps://stackoverflow.com/questions/27667277/why-does-borland-compile-with-multiple-definitions-of-same-object-in-different-c\n*/\n/*int i = 0;*/\n\n/* Works in GCC as an extension: https://stackoverflow.com/a/3692486/895245 */\n/*int i;*/\n\n/* OK: extern. Will use the one in main. */\nextern int i;\n\n/* OK: only visible to this file. */\nstatic int si = 0;\n\nvoid a() {\n    i++;\n    si++;\n    puts(\"a()\");\n    printf(\"i = %d\\n\", i);\n    printf(\"si = %d\\n\", si);\n    puts(\"\");\n}\n\n#include &lt;stdio.h&gt;\n\nint i = 0;\nstatic int si = 0;\n\nvoid a();    \n\nvoid m() {\n    i++;\n    si++;\n    puts(\"m()\");\n    printf(\"i = %d\\n\", i);\n    printf(\"si = %d\\n\", si);\n    puts(\"\");\n}\n\nint main() {\n    m();\n    m();\n    a();\n    a();\n    return 0;\n}\n\ngcc -c a.c -o a.o\ngcc -c main.c -o main.o\ngcc -o main main.o a.o\n\nm()\ni = 1\nsi = 1\n\nm()\ni = 2\nsi = 2\n\na()\ni = 3\nsi = 1\n\na()\ni = 4\nsi = 2\n\nsi\ni\nstatic\nstatic\nstatic\nstatic\ninternal linkage\ninternal linkage\nSTB_LOCAL\nint i = 0;\nstatic int si = 0;\n\nreadelf -s main.o\n\nNum:    Value          Size Type    Bind   Vis      Ndx Name\n  5: 0000000000000004     4 OBJECT  LOCAL  DEFAULT    4 si\n 10: 0000000000000000     4 OBJECT  GLOBAL DEFAULT    4 i\n\nValue\n.bss\nSTB_LOCAL\nstatic\nSTB_GLOBAL\n-O3\nsi\nstatic\nstatic\nextern",
            "int foo()\n{\n   static int x;\n   return ++x;\n}\n\nstatic int foo()\n{\n}\n\nfoo()\nb.c",
            "static\nfoo()\nvoid foo ()\n{\nstatic int i = 0;\nprintf(\"%d\", i); i++\n}\n\n.obj\nstatic void foo() { ... }\n",
            "static\nextern",
            "void func(void) {\n    static int count; // If you don't declare its value, it is initialized with zero\n    printf(&quot;%d, &quot;, count);\n    ++count;\n}\n\nint main(void) {\n    while(true) {\n        func();\n    }\n    return 0;\n}\n",
            "static\nstatic\nstatic\nstatic\nstatic",
            "void procedure(void)\n{\n   static int i = 0;\n\n   i++;\n}\n",
            "mytest.c\nstatic int my_variable;\n\n*.c",
            "void function()\n{\n    static int var = 1;\n    var++;\n    printf(\"%d\", var);\n}\n\nint main()\n{\n    function(); // Call 1\n    function(); // Call 2\n}\n\nvar\nvar\nvar\nvar\nvar\nvar\nstatic int x;\n\nint main()\n{\n    printf(\"Accessing in same file%d\", x):\n}\n\n    extern int x;\n    func()\n    {\n        printf(\"accessing in different file %d\",x); // Not allowed, x has the file scope of file1.c\n    }\n\nrun gcc -c file1.c\n\ngcc -c file2.c\n\ngcc -o output file1.o file2.o\n",
            "static\nstatic",
            "functions.c\nmain.c\nmain.c\nfunctions.c\n#include &lt;stdio.h&gt;\n\nvoid public_print(void);\nvoid static_print(void);\n\nint main()\n{\n    public_print();\n    static_print();\n}\n\nfunctions.c\nstatic\n#include &lt;stdio.h&gt;\n\nvoid public_print(void)\n{\n    printf(&quot;public_print!\\n&quot;);\n}\n\nstatic void static_print(void)\n{\n    printf(&quot;static_print!\\n&quot;);\n}\n\nroot@ubuntu:~/static# gcc -c functions.c -o functions.o\nroot@ubuntu:~/static# gcc -c main1.c -o main1.o\nroot@ubuntu:~/static# gcc -o main1 main1.o functions.o\n/usr/bin/ld: main1.o: in function `main':\nmain1.c:(.text+0x81): undefined reference to `static_print'\ncollect2: error: ld returned 1 exit status\n\nfunctions.c\nstatic\n#include &lt;stdio.h&gt;\n\nvoid public_print(void)\n{\n    printf(&quot;public_print!\\n&quot;);\n}\n\nvoid static_print(void)\n{\n    printf(&quot;(no more) static_print!\\n&quot;);\n}\n\nroot@ubuntu:~/static# gcc -c functions.c -o functions.o\nroot@ubuntu:~/static# gcc -o main1 main1.o functions.o\nroot@ubuntu:~/static# gcc -o main1 main1.o functions.o\nroot@ubuntu:~/static# ./main1\npublic_print!\n(no more) static_print!\n",
            "#include&lt;stdio.h&gt; \nint fun() \n{ \n  static int count = 0; \n  count++; \n  return count; \n} \n\nint main() \n{ \n  printf(\"%d \", fun()); \n  printf(\"%d \", fun()); \n  return 0; \n}\n\n#include &lt;stdio.h&gt; \nint main() \n{ \n    static int x; \n    int y; \n    printf(\"%d \\n %d\", x, y); \n}\n",
            "static\n#include&lt;stdio.h&gt; \nint counterFunction() \n{ \n  static int count = 0; \n  count++; \n  return count; \n} \n\nint main() \n{ \n  printf(\"First Counter Output = %d\\n\", counterFunction()); \n  printf(\"Second Counter Output = %d \", counterFunction()); \n  return 0; \n}\n\nFirst Counter Output = 1 \nSecond Counter Output = 1 \n\ncount = 0\ncounterFunction"
        ]
    },
    {
        "question_id": 37538,
        "question_code": "",
        "answer_code_snippets": [
            "int a[17];\nsize_t n = sizeof(a)/sizeof(a[0]);\n\nsizeof\nint a[17];\nsize_t n = sizeof(a);\n\nint a[17];\nsize_t n = sizeof(a) / sizeof(int);\n\na\nsizeof(int)\nsizeof(a[0])\nsizeof(*a)\nint a[17];\nsize_t n = sizeof(a) / sizeof(a[0]);\n\n#define NELEMS(x)  (sizeof(x) / sizeof((x)[0]))\n\nint a[17];\nsize_t n = NELEMS(a);\n",
            "sizeof\nsizeof\nsize_t size\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nvoid printSizeOf(int intArray[]);\nvoid printLength(int intArray[]);\n\nint main(int argc, char* argv[])\n{\n    int array[] = { 0, 1, 2, 3, 4, 5, 6 };\n\n    printf(\"sizeof of array: %d\\n\", (int) sizeof(array));\n    printSizeOf(array);\n\n    printf(\"Length of array: %d\\n\", (int)( sizeof(array) / sizeof(array[0]) ));\n    printLength(array);\n}\n\nvoid printSizeOf(int intArray[])\n{\n    printf(\"sizeof of parameter: %d\\n\", (int) sizeof(intArray));\n}\n\nvoid printLength(int intArray[])\n{\n    printf(\"Length of parameter: %d\\n\", (int)( sizeof(intArray) / sizeof(intArray[0]) ));\n}\n\nsizeof of array: 28\nsizeof of parameter: 8\nLength of array: 7\nLength of parameter: 2\n\nsizeof of array: 28\nsizeof of parameter: 4\nLength of array: 7\nLength of parameter: 1\n",
            "sizeof\nint a[10];\nint* p = a;\n\nassert(sizeof(a) / sizeof(a[0]) == 10);\nassert(sizeof(p) == sizeof(int*));\nassert(sizeof(*p) == sizeof(int));\n",
            "sizeof\nsizeof\nint myArray[10];\n\nsize_t n = sizeof myArray / sizeof *myArray;\n\nsizeof\nsend()\nvoid send(const void *object, size_t size);\n\nint foo = 4711;\nsend(&amp;foo, sizeof (int));\n\nfoo\nsend(&amp;foo, sizeof foo);\n",
            "sizeof\nsizeof(ptr)\nsizeof(arr)\n#define ARRAY_SIZE(arr)   (sizeof(arr) / sizeof((arr)[0]) + must_be_array(arr))\n#define ARRAY_BYTES(arr)  (sizeof(arr) + must_be_array(arr))\n\n#define is_same_type(a, b)    __builtin_types_compatible_p(a, b)\n#define is_same_typeof(a, b)  is_same_type(typeof(a), typeof(b))\n#define decay(a)              (&amp;*(a))\n#define is_array(arr)         (!is_same_typeof(arr, decay(arr)))\n#define must_be(e)                                                      \\\n(                                                                       \\\n        0 * (int)sizeof(                                                \\\n                struct {                                                \\\n                        static_assert(e);                               \\\n                        char ISO_C_forbids_a_struct_with_no_members__;  \\\n                }                                                       \\\n        )                                                               \\\n)\n#define must_be_array(arr)  must_be(is_array(arr))\n\nvoid foo(size_t nmemb, int arr[nmemb])\n{\n        qsort(arr, nmemb, sizeof(arr[0]), cmp);\n}\n\nqsort()\nARRAY_SIZE\n#define ARRAY_SIZE(arr)     (sizeof(arr) / sizeof((arr)[0]))\n\nvoid foo(size_t nmemb)\n{\n        char buf[nmemb];\n\n        fgets(buf, ARRAY_SIZE(buf), stdin);\n}\n\nvoid bar(size_t nmemb)\n{\n        int arr[nmemb];\n\n        for (size_t i = 0; i &lt; ARRAY_SIZE(arr); i++)\n                arr[i] = i;\n}\n\nvoid foo(size_t nmemb, char buf[nmemb])\n{\n        fgets(buf, nmemb, stdin);\n}\n\nvoid bar(size_t nmemb, int arr[nmemb])\n{\n        for (size_t i = nmemb - 1; i &lt; nmemb; i--)\n                arr[i] = i;\n}\n\nARRAY_SIZE\nsizeof(arr)\n#define ARRAY_BYTES(arr)        (sizeof((arr)[0]) * ARRAY_SIZE(arr))\n\nARRAY_SIZE\nsizeof(arr)\nARRAY_SIZE\nvoid foo(size_t nmemb)\n{\n        int arr[nmemb];\n\n        memset(arr, 0, ARRAY_BYTES(arr));\n}\n\nmemset()\nvoid foo(size_t nmemb, int arr[nmemb])\n{\n        memset(arr, 0, sizeof(arr[0]) * nmemb);\n}\n\n-Wsizeof-pointer-div\n/usr/local/include/\n/usr/include/\n#include &lt;foo.h&gt;\n#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))\nstatic_assert()\n#include &lt;assert.h&gt;\n\n#define is_same_type(a, b)    __builtin_types_compatible_p(a, b)\n#define is_same_typeof(a, b)  is_same_type(typeof(a), typeof(b))\n#define decay(a)              (&amp;*(a))\n#define is_array(arr)         (!is_same_typeof(arr, decay(arr)))\n#define Static_assert_array(arr) static_assert(is_array(arr))\n\n#define ARRAY_SIZE(arr)                                                 \\\n({                                                                      \\\n        Static_assert_array(arr);                                       \\\n        sizeof(arr) / sizeof((arr)[0]);                                 \\\n})\n\nARRAY_SIZE()\n__arraycount()\n__arraycount()\n&lt;sys/cdefs.h&gt;\n#inlcude &lt;assert.h&gt;\n#include &lt;stddef.h&gt;\n#include &lt;sys/cdefs.h&gt;\n#include &lt;sys/types.h&gt;\n\n#define is_same_type(a, b)    __builtin_types_compatible_p(a, b)\n#define is_same_typeof(a, b)  is_same_type(typeof(a), typeof(b))\n#define decay(a)              (&amp;*(a))\n#define is_array(arr)         (!is_same_typeof(arr, decay(arr)))\n#define Static_assert_array(arr) static_assert(is_array(arr))\n\n#define ARRAY_SIZE(arr)                                                 \\\n({                                                                      \\\n        Static_assert_array(arr);                                       \\\n        __arraycount((arr));                                            \\\n})\n\n#define ARRAY_BYTES(arr)        (sizeof((arr)[0]) * ARRAY_SIZE(arr))\n\nnitems()\n&lt;sys/param.h&gt;\n({})\nsizeof(struct {})\n0\n(int)\n(int)0\nARRAY_BYTES()\n#include &lt;assert.h&gt;\n#include &lt;stddef.h&gt;\n#include &lt;sys/cdefs.h&gt;\n#include &lt;sys/types.h&gt;\n\n#define is_same_type(a, b)    __builtin_types_compatible_p(a, b)\n#define is_same_typeof(a, b)  is_same_type(typeof(a), typeof(b))\n#define decay(a)              (&amp;*(a))\n#define is_array(arr)         (!is_same_typeof(arr, decay(arr)))\n#define must_be(e)                                                      \\\n(                                                                       \\\n        0 * (int)sizeof(                                                \\\n                struct {                                                \\\n                        static_assert(e);                               \\\n                        char ISO_C_forbids_a_struct_with_no_members__;  \\\n                }                                                       \\\n        )                                                               \\\n)\n#define must_be_array(arr)      must_be(is_array(arr))\n\n#define ARRAY_SIZE(arr)         (__arraycount((arr)) + must_be_array(arr))\n#define ARRAY_BYTES(arr)        (sizeof(arr) + must_be_array(arr))\n\n__builtin_types_compatible_p()\ntypeof()\nstatic_assert()\nstatic_assert()",
            "int size = (&amp;arr)[1] - arr;\n",
            "len = sizeof(arr)/sizeof(arr[0])\n",
            "int arr[] = {23, 12, 423, 43, 21, 43, 65, 76, 22};\n\nint noofele = sizeof(arr)/sizeof(int);\n\nnoofele = sizeof(arr)/sizeof(arr[0]);\n\narr",
            "ARRAYELEMENTCOUNT(x)\n/* Compile as: CL /P \"macro.c\" */\n# define ARRAYELEMENTCOUNT(x) (sizeof (x) / sizeof (x[0]))\n\nARRAYELEMENTCOUNT(p + 1);\n\n(sizeof (p + 1) / sizeof (p + 1[0]));\n\n/* Compile as: CL /P \"macro.c\" */\n# define ARRAYELEMENTCOUNT(x) (sizeof (x) / sizeof (x)[0])\n\nARRAYELEMENTCOUNT(p + 1);\n\n(sizeof (p + 1) / sizeof (p + 1)[0]);\n\np + 1",
            "#define g_rgDialogRows   2\n#define g_rgDialogCols   7\n\nstatic char const* g_rgDialog[g_rgDialogRows][g_rgDialogCols] =\n{\n    { \" \",  \" \",    \" \",    \" 494\", \" 210\", \" Generic Sample Dialog\", \" \" },\n    { \" 1\", \" 330\", \" 174\", \" 88\",  \" \",    \" OK\",        \" \" },\n};\n\n#define rows_of_array(name)       \\\n    (sizeof(name   ) / sizeof(name[0][0]) / columns_of_array(name))\n#define columns_of_array(name)    \\\n    (sizeof(name[0]) / sizeof(name[0][0]))\n\nstatic char* g_rgDialog[][7] = { /* ... */ };\n\nassert(   rows_of_array(g_rgDialog) == 2);\nassert(columns_of_array(g_rgDialog) == 7);\n\nsizeof(name[0][0][0])\nsizeof(name[0][0][0][0])\n",
            "int a[10];\nsize_t size_of_array = sizeof(a);      // Size of array a\nint n = sizeof (a) / sizeof (a[0]);    // Number of elements in array a\nsize_t size_of_element = sizeof(a[0]); // Size of each element in array a                                          \n                                       // Size of each element = size of type\n",
            "sizeof(array) / sizeof(array[0])\n",
            "#define SIZE_OF_ARRAY(_array) (sizeof(_array) / sizeof(_array[0]))\n",
            "Array.arr[i]\nArray.size\n/* Absolutely no one should use this...\n   By the time you're done implementing it you'll wish you just passed around\n   an array and size to your functions */\n/* This is a static implementation. You can get a dynamic implementation and \n   cut out the array in main by using the stdlib memory allocation methods,\n   but it will work much slower since it will store your array on the heap */\n\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n/*\n#include \"MyTypeArray.h\"\n*/\n/* MyTypeArray.h \n#ifndef MYTYPE_ARRAY\n#define MYTYPE_ARRAY\n*/\ntypedef struct MyType\n{\n   int age;\n   char name[20];\n} MyType;\ntypedef struct MyTypeArray\n{\n   int size;\n   MyType *arr;\n} MyTypeArray;\n\nMyType new_MyType(int age, char *name);\nMyTypeArray newMyTypeArray(int size, MyType *first);\n/*\n#endif\nEnd MyTypeArray.h */\n\n/* MyTypeArray.c */\nMyType new_MyType(int age, char *name)\n{\n   MyType d;\n   d.age = age;\n   strcpy(d.name, name);\n   return d;\n}\n\nMyTypeArray new_MyTypeArray(int size, MyType *first)\n{\n   MyTypeArray d;\n   d.size = size;\n   d.arr = first;\n   return d;\n}\n/* End MyTypeArray.c */\n\n\nvoid print_MyType_names(MyTypeArray d)\n{\n   int i;\n   for (i = 0; i &lt; d.size; i++)\n   {\n      printf(\"Name: %s, Age: %d\\n\", d.arr[i].name, d.arr[i].age);\n   }\n}\n\nint main()\n{\n   /* First create an array on the stack to store our elements in.\n      Note we could create an empty array with a size instead and\n      set the elements later. */\n   MyType arr[] = {new_MyType(10, \"Sam\"), new_MyType(3, \"Baxter\")};\n   /* Now create a \"MyTypeArray\" which will use the array we just\n      created internally. Really it will just store the value of the pointer\n      \"arr\". Here we are manually setting the size. You can use the sizeof\n      trick here instead if you're sure it will work with your compiler. */\n   MyTypeArray array = new_MyTypeArray(2, arr);\n   /* MyTypeArray array = new_MyTypeArray(sizeof(arr)/sizeof(arr[0]), arr); */\n   print_MyType_names(array);\n   return 0;\n}\n",
            "typedef struct {\n     int *array;\n     int elements;\n} list_s;\n",
            "sizeof\nsizeof\nint array[10];\nint array[10];\nsize_t sizeOfArray = sizeof(array)/sizeof(int);\n",
            "&amp;\n#include&lt;stdio.h&gt;\n#include&lt;stdlib.h&gt;\nint main(){\n\n    int a[10];\n\n    int *p; \n\n    printf(\"%p\\n\", (void *)a); \n    printf(\"%p\\n\", (void *)(&amp;a+1));\n    printf(\"---- diff----\\n\");\n    printf(\"%zu\\n\", sizeof(a[0]));\n    printf(\"The size of array a is %zu\\n\", ((char *)(&amp;a+1)-(char *)a)/(sizeof(a[0])));\n\n\n    return 0;\n};\n\n1549216672\n1549216712\n---- diff----\n4\nThe size of array a is 10\n",
            "size_t size = sizeof(a) / sizeof(*a);\n",
            "#include &lt;stdio.h&gt;\n\nint main(void) {\n\n    int a[] = {2,3,4,5,4,5,6,78,9,91,435,4,5,76,7,34}; // For example only\n    int size;\n\n    size = sizeof(a)/sizeof(a[0]); // Method\n\n    printf(&quot;size = %d&quot;, size);\n    return 0;\n}\n",
            "#ifndef __cplusplus\n   /* C version */\n#  define ARRAY_LEN_UNSAFE(X) (sizeof(X)/sizeof(*(X)))\n#  define ARRAY_LEN(X) (ARRAY_LEN_UNSAFE(X) + 0 * sizeof((typeof(*(X))(*[1])[ARRAY_LEN_UNSAFE(X)]){0} - (typeof(X)**)0))\n#else\n   /* C++ version */\n   template &lt;unsigned int N&gt; class __array_len_aux    { public: template &lt;typename T, unsigned int M&gt; static const char (&amp;match_only_array(T(&amp;)[M]))[M]; };\n   template &lt;&gt;               class __array_len_aux&lt;0&gt; { public: template &lt;typename T&gt;                 static const char (&amp;match_only_array(T(&amp;)))[0]; };\n#  define ARRAY_LEN(X) sizeof(__array_len_aux&lt;sizeof(X)&gt;::match_only_array(X))\n#endif\n\n\n/* below are verifying codes */\n#include &lt;assert.h&gt;\n\nvoid * a0[0];\nvoid * a1[9];\nvoid * aa0[0];\nvoid * aa1[5][10];\nvoid *p;\nstruct tt {\n    char x[10];\n    char *p;\n} t;\n\nstatic_assert(ARRAY_LEN(a0) == 0, &quot;verify [0]&quot;);\nstatic_assert(ARRAY_LEN(aa0) == 0, &quot;verify [0][N]&quot;);\nstatic_assert(ARRAY_LEN(a1) == 9, &quot;verify [N]&quot;);\nstatic_assert(ARRAY_LEN(aa1) == 5, &quot;verify [N][M]&quot;);\nstatic_assert(ARRAY_LEN(aa1[0]) == 10, &quot;verify inner array of [N][M]&quot;);\nstatic_assert(ARRAY_LEN(t.x) == 10, &quot;verify array in struct&quot;);\n//static_assert(ARRAY_LEN(p) == 0, &quot;should parse error&quot;);\n//static_assert(ARRAY_LEN(t.p) == 0, &quot;should parse error&quot;);\n\nC\nARRAY_LEN\ntypeof()\nC++\nC",
            "sizeof(a) / sizeof (a[0])\n\na\nchar\nunsigned char\nsigned char\nsizeof\nsizeof\n1\nsizeof\nchar\nunsigned char\nsigned char\n1\nsizeof(a) / sizeof (a[0])\nNUMBER OF ARRAY ELEMENTS / 1\na\nchar\nunsigned char\nsigned char\nsizeof(a)\n\nchar a[10];\nsize_t length = sizeof(a);\n"
        ]
    },
    {
        "question_id": 1433204,
        "question_code": "extern\nextern\nextern",
        "answer_code_snippets": [
            "extern\nfile1.c\nfile2.c\nextern\nfile3.h\nfile1.c\nfile2.c\nextern int global_variable;  /* Declaration of the variable */\n\n#include &quot;file3.h&quot;  /* Declaration made available here */\n#include &quot;prog1.h&quot;  /* Function declarations */\n\n/* Variable defined here */\nint global_variable = 37;    /* Definition checked against declaration */\n\nint increment(void) { return global_variable++; }\n\n#include &quot;file3.h&quot;\n#include &quot;prog1.h&quot;\n#include &lt;stdio.h&gt;\n\nvoid use_it(void)\n{\n    printf(&quot;Global variable: %d\\n&quot;, global_variable++);\n}\n\nprog1\nextern\nextern\nextern\nextern void use_it(void);\nextern int increment(void);\n\n#include &quot;file3.h&quot;\n#include &quot;prog1.h&quot;\n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    use_it();\n    global_variable += 19;\n    use_it();\n    printf(&quot;Increment: %d\\n&quot;, increment());\n    return 0;\n}\n\nprog1\nprog1.c\nfile1.c\nfile2.c\nfile3.h\nprog1.h\nprog1.mk\nprog1\nmake\n# Minimal makefile for prog1\n\nPROGRAM = prog1\nFILES.c = prog1.c file1.c file2.c\nFILES.h = prog1.h file3.h\nFILES.o = ${FILES.c:.c=.o}\n\nCC      = gcc\nSFLAGS  = -std=c11\nGFLAGS  = -g\nOFLAGS  = -O3\nWFLAG1  = -Wall\nWFLAG2  = -Wextra\nWFLAG3  = -Werror\nWFLAG4  = -Wstrict-prototypes\nWFLAG5  = -Wmissing-prototypes\nWFLAGS  = ${WFLAG1} ${WFLAG2} ${WFLAG3} ${WFLAG4} ${WFLAG5}\nUFLAGS  = # Set on command line only\n\nCFLAGS  = ${SFLAGS} ${GFLAGS} ${OFLAGS} ${WFLAGS} ${UFLAGS}\nLDFLAGS =\nLDLIBS  =\n\nall:    ${PROGRAM}\n\n${PROGRAM}: ${FILES.o}\n    ${CC} -o $@ ${CFLAGS} ${FILES.o} ${LDFLAGS} ${LDLIBS}\n\nprog1.o: ${FILES.h}\nfile1.o: ${FILES.h}\nfile2.o: ${FILES.h}\n\n# If it exists, prog1.dSYM is a directory on macOS\nDEBRIS = a.out core *~ *.dSYM\nRM_FR  = rm -fr\n\nclean:\n    ${RM_FR} ${FILES.o} ${PROGRAM} ${DEBRIS}\n\n\nextern\nstatic\nextern\nextern\n#include &quot;prog2.h&quot;\n\nlong l;   /* Do not do this in portable code */\n\nvoid inc(void) { l++; }\n\n#include &quot;prog2.h&quot;\n\nlong l;   /* Do not do this in portable code */\n\nvoid dec(void) { l--; }\n\n#include &quot;prog2.h&quot;\n#include &lt;stdio.h&gt;\n\nlong l = 9;   /* Do not do this in portable code */\n\nvoid put(void) { printf(&quot;l = %ld\\n&quot;, l); }\n\nsizeof\n_Alignof\nl\ndouble\nlong\nlong\ndouble\nlong\ndouble\n-fno-common\n-fcommon\nprog2\nextern void dec(void);\nextern void put(void);\nextern void inc(void);\n\n#include &quot;prog2.h&quot;\n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    inc();\n    put();\n    dec();\n    put();\n    dec();\n    put();\n}\n\nprog2\nprog2.c\nfile10.c\nfile11.c\nfile12.c\nprog2.h\nint some_var;    /* Do not do this in a header!!! */\n\nextern\nint some_var = 13;    /* Only one source file in a program can use this */\n\nstatic int hidden_global = 3;   /* Each source file gets its own copy  */\n\nglobal_variable\nfile3.h\n#ifdef DEFINE_VARIABLES\n#define EXTERN /* nothing */\n#else\n#define EXTERN extern\n#endif /* DEFINE_VARIABLES */\n\nEXTERN int global_variable;\n\n#define DEFINE_VARIABLES\n#include &quot;file3a.h&quot;  /* Variable defined - but not initialized */\n#include &quot;prog3.h&quot;\n\nint increment(void) { return global_variable++; }\n\n#include &quot;file3a.h&quot;\n#include &quot;prog3.h&quot;\n#include &lt;stdio.h&gt;\n\nvoid use_it(void)\n{\n    printf(&quot;Global variable: %d\\n&quot;, global_variable++);\n}\n\nprog3\nextern void use_it(void);\nextern int increment(void);\n\n#include &quot;file3a.h&quot;\n#include &quot;prog3.h&quot;\n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    use_it();\n    global_variable += 19;\n    use_it();\n    printf(&quot;Increment: %d\\n&quot;, increment());\n    return 0;\n}\n\nprog3\nprog3.c\nfile1a.c\nfile2a.c\nfile3a.h\nprog3.h\n#ifdef DEFINE_VARIABLES\n#define EXTERN                  /* nothing */\n#define INITIALIZER(...)        = __VA_ARGS__\n#else\n#define EXTERN                  extern\n#define INITIALIZER(...)        /* nothing */\n#endif /* DEFINE_VARIABLES */\n\nEXTERN int global_variable INITIALIZER(37);\nEXTERN struct { int a; int b; } oddball_struct INITIALIZER({ 41, 43 });\n\n#if\n#else\n#define DEFINE_VARIABLES\n#include &quot;file3b.h&quot;  /* Variables now defined and initialized */\n#include &quot;prog4.h&quot;\n\nint increment(void) { return global_variable++; }\nint oddball_value(void) { return oddball_struct.a + oddball_struct.b; }\n\n\n#include &quot;file3b.h&quot;\n#include &quot;prog4.h&quot;\n#include &lt;stdio.h&gt;\n\nvoid use_them(void)\n{\n    printf(&quot;Global variable: %d\\n&quot;, global_variable++);\n    oddball_struct.a += global_variable;\n    oddball_struct.b -= global_variable / 2;\n}\n\nINITIALIZER\n{ 41\n43 }\nfile3b.h\nfileba.h\nprog4\nextern int increment(void);\nextern int oddball_value(void);\nextern void use_them(void);\n\n#include &quot;file3b.h&quot;\n#include &quot;prog4.h&quot;\n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    use_them();\n    global_variable += 19;\n    use_them();\n    printf(&quot;Increment: %d\\n&quot;, increment());\n    printf(&quot;Oddball:   %d\\n&quot;, oddball_value());\n    return 0;\n}\n\nprog4\nprog4.c\nfile1b.c\nfile2b.c\nprog4.h\nfile3b.h\n#ifndef FILE3B_H_INCLUDED\n#define FILE3B_H_INCLUDED\n\n...contents of header...\n\n#endif /* FILE3B_H_INCLUDED */\n\nfile4b.h\nfile3b.h\nfile1b.c\nfile4b.h\nfile3b.h\nfile4b.h\nfile4b.h\nfile3b.h\nfile3b.h\nfile3b.h\nexternal.h\nfile1c.h\nstruct oddball\noddball_struct\nfile2c.h\nfile3c.c\nfile4c.c\nfile5c.c\nfile6c.c\nfile5c.c\nfile6c.c\nfile2c.h\n/*\n** This header must not contain header guards (like &lt;assert.h&gt; must not).\n** Each time it is invoked, it redefines the macros EXTERN, INITIALIZE\n** based on whether macro DEFINE_VARIABLES is currently defined.\n*/\n#undef EXTERN\n#undef INITIALIZE\n\n#ifdef DEFINE_VARIABLES\n#define EXTERN              /* nothing */\n#define INITIALIZE(...)     = __VA_ARGS__\n#else\n#define EXTERN              extern\n#define INITIALIZE(...)     /* nothing */\n#endif /* DEFINE_VARIABLES */\n\n#ifndef FILE1C_H_INCLUDED\n#define FILE1C_H_INCLUDED\n\nstruct oddball\n{\n    int a;\n    int b;\n};\n\nextern void use_them(void);\nextern int increment(void);\nextern int oddball_value(void);\n\n#endif /* FILE1C_H_INCLUDED */\n\n\n\n/* Standard prologue */\n#if defined(DEFINE_VARIABLES) &amp;&amp; !defined(FILE2C_H_DEFINITIONS)\n#undef FILE2C_H_INCLUDED\n#endif\n\n#ifndef FILE2C_H_INCLUDED\n#define FILE2C_H_INCLUDED\n\n#include &quot;external.h&quot;   /* Support macros EXTERN, INITIALIZE */\n#include &quot;file1c.h&quot;     /* Type definition for struct oddball */\n\n#if !defined(DEFINE_VARIABLES) || !defined(FILE2C_H_DEFINITIONS)\n\n/* Global variable declarations / definitions */\nEXTERN int global_variable INITIALIZE(37);\nEXTERN struct oddball oddball_struct INITIALIZE({ 41, 43 });\n\n#endif /* !DEFINE_VARIABLES || !FILE2C_H_DEFINITIONS */\n\n/* Standard epilogue */\n#ifdef DEFINE_VARIABLES\n#define FILE2C_H_DEFINITIONS\n#endif /* DEFINE_VARIABLES */\n\n#endif /* FILE2C_H_INCLUDED */\n\n#define DEFINE_VARIABLES\n#include &quot;file2c.h&quot;  /* Variables now defined and initialized */\n\nint increment(void) { return global_variable++; }\nint oddball_value(void) { return oddball_struct.a + oddball_struct.b; }\n\n\n#include &quot;file2c.h&quot;\n#include &lt;stdio.h&gt;\n\nvoid use_them(void)\n{\n    printf(&quot;Global variable: %d\\n&quot;, global_variable++);\n    oddball_struct.a += global_variable;\n    oddball_struct.b -= global_variable / 2;\n}\n\n\n\n#include &quot;file2c.h&quot;     /* Declare variables */\n\n#define DEFINE_VARIABLES\n#include &quot;file2c.h&quot;  /* Variables now defined and initialized */\n\nint increment(void) { return global_variable++; }\nint oddball_value(void) { return oddball_struct.a + oddball_struct.b; }\n\n\n\n#define DEFINE_VARIABLES\n#include &quot;file2c.h&quot;     /* Variables now defined and initialized */\n\n#include &quot;file2c.h&quot;     /* Declare variables */\n\nint increment(void) { return global_variable++; }\nint oddball_value(void) { return oddball_struct.a + oddball_struct.b; }\n\n\nprog5\nprog6\nprog7\n#include &quot;file2c.h&quot;\n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    use_them();\n    global_variable += 19;\n    use_them();\n    printf(&quot;Increment: %d\\n&quot;, increment());\n    printf(&quot;Oddball:   %d\\n&quot;, oddball_value());\n    return 0;\n}\n\nprog5\nprog5.c\nfile3c.c\nfile4c.c\nfile1c.h\nfile2c.h\nexternal.h\nprog6\nprog5.c\nfile5c.c\nfile4c.c\nfile1c.h\nfile2c.h\nexternal.h\nprog7\nprog5.c\nfile6c.c\nfile4c.c\nfile1c.h\nfile2c.h\nexternal.h\nfile2c.h\nfile7c.h\nfile2c.h\nfile2d.h\n/* Standard prologue */\n#if defined(DEFINE_VARIABLES) &amp;&amp; !defined(FILE2D_H_DEFINITIONS)\n#undef FILE2D_H_INCLUDED\n#endif\n\n#ifndef FILE2D_H_INCLUDED\n#define FILE2D_H_INCLUDED\n\n#include &quot;external.h&quot;   /* Support macros EXTERN, INITIALIZE */\n#include &quot;file1c.h&quot;     /* Type definition for struct oddball */\n\n#if !defined(DEFINE_VARIABLES) || !defined(FILE2D_H_DEFINITIONS)\n\n/* Global variable declarations / definitions */\nEXTERN int global_variable INITIALIZE(37);\nEXTERN struct oddball oddball_struct INITIALIZE({ 41, 43 });\n\n#endif /* !DEFINE_VARIABLES || !FILE2D_H_DEFINITIONS */\n\n/* Standard epilogue */\n#ifdef DEFINE_VARIABLES\n#define FILE2D_H_DEFINITIONS\n#undef DEFINE_VARIABLES\n#endif /* DEFINE_VARIABLES */\n\n#endif /* FILE2D_H_INCLUDED */\n\n#undef DEFINE_VARIABLES\n#define\n#undef\n#define DEFINE_VARIABLES\n#include &quot;file2c.h&quot;\n#undef DEFINE_VARIABLES\n\nDEFINE_VARIABLES\n#define HEADER_DEFINING_VARIABLES &quot;file2c.h&quot;\n#include &quot;externdef.h&quot;\n\n/*\n** This header must not contain header guards (like &lt;assert.h&gt; must not).\n** Each time it is included, the macro HEADER_DEFINING_VARIABLES should\n** be defined with the name (in quotes - or possibly angle brackets) of\n** the header to be included that defines variables when the macro\n** DEFINE_VARIABLES is defined.  See also: external.h (which uses\n** DEFINE_VARIABLES and defines macros EXTERN and INITIALIZE\n** appropriately).\n**\n** #define HEADER_DEFINING_VARIABLES &quot;file2c.h&quot;\n** #include &quot;externdef.h&quot;\n*/\n\n#if defined(HEADER_DEFINING_VARIABLES)\n#define DEFINE_VARIABLES\n#include HEADER_DEFINING_VARIABLES\n#undef DEFINE_VARIABLES\n#undef HEADER_DEFINING_VARIABLES\n#endif /* HEADER_DEFINING_VARIABLES */\n\n\nfile2d.h\n#undef DEFINE_VARIABLES\nfile2d.h\n/* Declare variables */\n#include &quot;file2d.h&quot;\n\n/* Define variables */\n#define HEADER_DEFINING_VARIABLES &quot;file2d.h&quot;\n#include &quot;externdef.h&quot;\n\n/* Declare variables - again */\n#include &quot;file2d.h&quot;\n\n/* Define variables - again */\n#define HEADER_DEFINING_VARIABLES &quot;file2d.h&quot;\n#include &quot;externdef.h&quot;\n\nint increment(void) { return global_variable++; }\nint oddball_value(void) { return oddball_struct.a + oddball_struct.b; }\n\n\n/* Standard prologue */\n#if defined(DEFINE_VARIABLES) &amp;&amp; !defined(FILE8C_H_DEFINITIONS)\n#undef FILE8C_H_INCLUDED\n#endif\n\n#ifndef FILE8C_H_INCLUDED\n#define FILE8C_H_INCLUDED\n\n#include &quot;external.h&quot;   /* Support macros EXTERN, INITIALIZE */\n#include &quot;file2d.h&quot;     /* struct oddball */\n\n#if !defined(DEFINE_VARIABLES) || !defined(FILE8C_H_DEFINITIONS)\n\n/* Global variable declarations / definitions */\nEXTERN struct oddball another INITIALIZE({ 14, 34 });\n\n#endif /* !DEFINE_VARIABLES || !FILE8C_H_DEFINITIONS */\n\n/* Standard epilogue */\n#ifdef DEFINE_VARIABLES\n#define FILE8C_H_DEFINITIONS\n#endif /* DEFINE_VARIABLES */\n\n#endif /* FILE8C_H_INCLUDED */\n\n\n/* Define variables */\n#define HEADER_DEFINING_VARIABLES &quot;file2d.h&quot;\n#include &quot;externdef.h&quot;\n\n/* Define variables */\n#define HEADER_DEFINING_VARIABLES &quot;file8c.h&quot;\n#include &quot;externdef.h&quot;\n\nint increment(void) { return global_variable++; }\nint oddball_value(void) { return oddball_struct.a + oddball_struct.b; }\n\n\nprog8\nprog9\n#include &quot;file2d.h&quot;\n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    use_them();\n    global_variable += 19;\n    use_them();\n    printf(&quot;Increment: %d\\n&quot;, increment());\n    printf(&quot;Oddball:   %d\\n&quot;, oddball_value());\n    return 0;\n}\n\n#include &quot;file2d.h&quot;\n#include &lt;stdio.h&gt;\n\nvoid use_them(void)\n{\n    printf(&quot;Global variable: %d\\n&quot;, global_variable++);\n    oddball_struct.a += global_variable;\n    oddball_struct.b -= global_variable / 2;\n}\n\n\nprog8\nprog8.c\nfile7c.c\nfile9c.c\nprog9\nprog8.c\nfile8c.c\nfile9c.c\nprog5.c\nprog8.c\nmain()",
            "extern\n.c\ntest1.c\ntest2.c\nint test1_var;\ntest1.c\ntest2.c\nextern int test1_var;\ntest2.c\n$ cat test1.c \nint test1_var = 5;\n$ cat test2.c\n#include &lt;stdio.h&gt;\n\nextern int test1_var;\n\nint main(void) {\n    printf(\"test1_var = %d\\n\", test1_var);\n    return 0;\n}\n$ gcc test1.c test2.c -o test\n$ ./test\ntest1_var = 5\n",
            "                 declare | define   | initialize |\n                ----------------------------------\n\nextern int a;    yes          no           no\n-------------\nint a = 2019;    yes          yes          yes\n-------------\nint a;           yes          yes          no\n-------------\n",
            "extern",
            "#include &lt;stdio.h&gt;\n\nint not_extern_int = 1;\nextern int extern_int;\n\nvoid main() {\n    printf(\"%d\\n\", not_extern_int);\n    printf(\"%d\\n\", extern_int);\n}\n\ngcc -c main.c\nreadelf -s main.o\n\nNum:    Value          Size Type    Bind   Vis      Ndx Name\n 9: 0000000000000000     4 OBJECT  GLOBAL DEFAULT    3 not_extern_int\n12: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND extern_int\n\nextern\nextern",
            "#include&lt;stdio.h&gt;\nextern int a;\nmain(){\n       printf(\"The value of a is &lt;%d&gt;\\n\",a);\n}\n\nint a = 5;\n",
            "extern\nstatic",
            "extern\nextern\nextern",
            "extern",
            "extern\nfirst.c\nsecond.c\nextern\nfirst.c\nfirst.c",
            "int\nchar\n#ifdef MAIN_C\n#define GLOBAL\n /* #warning COMPILING MAIN.C */\n#else\n#define GLOBAL extern\n#endif\nGLOBAL unsigned char testing_mode; // example var used in several C files\n\n#define MAIN_C 1\n#include \"global.h\"\n#undef MAIN_C\n\nunsigned char\nextern unsigned char testing_mode;\n\nunsigned char\ngotcha",
            "#define GLOBAL_FOO_IMPLEMENTATION\n//file foo_globals.h\n#pragma once  \n#include &quot;foo.h&quot;  //contains Foo typedef\n#include &lt;atomic&gt;\n\n#ifdef GLOBAL  \n#undef GLOBAL  \n#endif  \n\n#ifdef GLOBALINIT\n#undef GLOBALINIT\n#endif\n\n#ifdef GLOBAL_FOO_IMPLEMENTATION  \n#define GLOBAL  \n#define GLOBALINIT(x) = x\n#else  \n#define GLOBAL extern  \n#define GLOBALINIT(x)\n#endif  \n\nGLOBAL Foo foo1 GLOBALINIT({2, 3, 4})\nGLOBAL std::atomic_bool flag1 GLOBALINIT(true);\nGLOBAL std::atomic_uint counter1 GLOBALINIT(5);\n\n\n//file main.cpp\n#define GLOBAL_FOO_IMPLEMENTATION\n#include &quot;foo_globals.h&quot;\n\n//file uses_extern_foo.cpp\n#include &quot;foo_globals.h\n",
            "extern\nextern"
        ]
    },
    {
        "question_id": 201101,
        "question_code": "memset()",
        "answer_code_snippets": [
            "int myArray[10] = { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 };\n\nint myArray[10] = { 1, 2 }; // initialize to 1,2,0,0,0...\n\nint myArray[10] = { 0 }; // all elements 0\n\nint myArray[10] = {}; // all elements 0 in C++ and C23\n\nstatic int myArray[10]; // all elements 0\n",
            "int array[1024] = {[0 ... 1023] = 5};\n",
            "#define VAL_1X     42\n#define VAL_2X     VAL_1X,  VAL_1X\n#define VAL_4X     VAL_2X,  VAL_2X\n#define VAL_8X     VAL_4X,  VAL_4X\n#define VAL_16X    VAL_8X,  VAL_8X\n#define VAL_32X    VAL_16X, VAL_16X\n#define VAL_64X    VAL_32X, VAL_32X\n\nint myArray[53] = { VAL_32X, VAL_16X, VAL_4X, VAL_1X };\n\n#define VAL_1(X) X\n#define VAL_2(X) VAL_1(X), VAL_1(X)\n/* etc. */\n\n#define STRUCTVAL_1(...) { __VA_ARGS__ }\n#define STRUCTVAL_2(...) STRUCTVAL_1(__VA_ARGS__), STRUCTVAL_1(__VA_ARGS__)\n/*etc */\n\n#define STRUCTVAL_48(...) STRUCTVAL_32(__VA_ARGS__), STRUCTVAL_16(__VA_ARGS__)\n\nstruct Pair { char key[16]; char val[32]; };\nstruct Pair p_data[] = { STRUCTVAL_48(&quot;Key&quot;, &quot;Value&quot;) };\nint a_data[][4] = { STRUCTVAL_48(12, 19, 23, 37) };\n",
            "int myArray[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n\nint myPoints[][3] = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9} };\n\nint myPoints[][] = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9} };\n",
            "char* array[] = \n{\n    [0] = \"Hello\",\n    [1] = \"World\"\n};   \n\nenum\n{\n    ERR_OK,\n    ERR_FAIL,\n    ERR_MEMORY\n};\n\n#define _ITEM(x) [x] = #x\n\nchar* array[] = \n{\n    _ITEM(ERR_OK),\n    _ITEM(ERR_FAIL),\n    _ITEM(ERR_MEMORY)\n};   \n",
            "int i;\nfor (i = 0; i &lt; ARRAY_SIZE; ++i)\n{\n  myArray[i] = VALUE;\n}\n\nint myArray[10] = { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5...\n",
            "std::index_sequence\nconstexpr\n#include &lt;array&gt;\n\n/// [3]\n/// This functions's only purpose is to ignore the index given as the second\n/// template argument and to always produce the value passed in.\ntemplate&lt;class T, size_t /*ignored*/&gt;\nconstexpr T identity_func(const T&amp; value) {\n    return value;\n}\n\n/// [2]\n/// At this point, we have a list of indices that we can unfold\n/// into an initializer list using the `identity_func` above.\ntemplate&lt;class T, size_t... Indices&gt;\nconstexpr std::array&lt;T, sizeof...(Indices)&gt;\nmake_array_of_impl(const T&amp; value, std::index_sequence&lt;Indices...&gt;) {\n    return {identity_func&lt;T, Indices&gt;(value)...};\n}\n\n/// [1]\n/// This is the user-facing function.\n/// The template arguments are swapped compared to the order used\n/// for std::array, this way we can let the compiler infer the type\n/// from the given value but still define it explicitly if we want to.\ntemplate&lt;size_t Size, class T&gt;\nconstexpr std::array&lt;T, Size&gt; \nmake_array_of(const T&amp; value) {\n    using Indices = std::make_index_sequence&lt;Size&gt;;\n    return make_array_of_impl(value, Indices{});\n}\n\n// std::array&lt;int, 4&gt;{42, 42, 42, 42}\nconstexpr auto test_array = make_array_of&lt;4/*, int*/&gt;(42);\nstatic_assert(test_array[0] == 42);\nstatic_assert(test_array[1] == 42);\nstatic_assert(test_array[2] == 42);\nstatic_assert(test_array[3] == 42);\n// static_assert(test_array[4] == 42); out of bounds\n",
            "static void\nunhandled_interrupt(struct trap_frame *frame, int irq, void *arg)\n{\n    //this code intentionally left blank\n}\n\nstatic struct irqtbl_s vector_tbl[XCHAL_NUM_INTERRUPTS] = {\n    [0 ... XCHAL_NUM_INTERRUPTS-1] {unhandled_interrupt, NULL},\n};\n",
            "array = initial_value\n",
            "// put values 1-8, then two zeroes\nint list[10] = {1,2,3,4,5,6,7,8};\n",
            "1 000 000\nint\nloop runtime 0.004248 [seconds]\nmemfill() runtime 0.001085 [seconds]\n#include &lt;stdio.h&gt;\n#include &lt;time.h&gt;\n#include &lt;string.h&gt;\n#define ARR_SIZE 1000000\n\nvoid memfill(void *dest, size_t destsize, size_t elemsize) {\n   char   *nextdest = (char *) dest + elemsize;\n   size_t movesize, donesize = elemsize;\n\n   destsize -= elemsize;\n   while (destsize) {\n      movesize = (donesize &lt; destsize) ? donesize : destsize;\n      memcpy(nextdest, dest, movesize);\n      nextdest += movesize; destsize -= movesize; donesize += movesize;\n   }\n}    \nint main() {\n    clock_t timeStart;\n    double  runTime;\n    int     i, a[ARR_SIZE];\n\n    timeStart = clock();\n    for (i = 0; i &lt; ARR_SIZE; i++)\n        a[i] = 9;    \n    runTime = (double)(clock() - timeStart) / (double)CLOCKS_PER_SEC;\n    printf(\"loop runtime %f [seconds]\\n\",runTime);\n\n    timeStart = clock();\n    a[0] = 10;\n    memfill(a, sizeof(a), sizeof(a[0]));\n    runTime = (double)(clock() - timeStart) / (double)CLOCKS_PER_SEC;\n    printf(\"memfill() runtime %f [seconds]\\n\",runTime);\n    return 0;\n}\n",
            "int array[10] = {0};\n\nint array[10];\nmemset(array,-1, 10 *sizeof(int));\n",
            "int array[1024] = {[0 ... 1023] = 5};\n\n...",
            "#include &lt;iostream&gt;\n\nvoid PrintArray(int a[3][3])\n{\n    std::cout &lt;&lt; &quot;a11 = &quot; &lt;&lt; a[0][0] &lt;&lt; &quot;\\t\\t&quot; &lt;&lt; &quot;a12 = &quot; &lt;&lt; a[0][1] &lt;&lt; &quot;\\t\\t&quot; &lt;&lt; &quot;a13 = &quot; &lt;&lt; a[0][2] &lt;&lt; std::endl;\n    std::cout &lt;&lt; &quot;a21 = &quot; &lt;&lt; a[1][0] &lt;&lt; &quot;\\t\\t&quot; &lt;&lt; &quot;a22 = &quot; &lt;&lt; a[1][1] &lt;&lt; &quot;\\t\\t&quot; &lt;&lt; &quot;a23 = &quot; &lt;&lt; a[1][2] &lt;&lt; std::endl;\n    std::cout &lt;&lt; &quot;a31 = &quot; &lt;&lt; a[2][0] &lt;&lt; &quot;\\t\\t&quot; &lt;&lt; &quot;a32 = &quot; &lt;&lt; a[2][1] &lt;&lt; &quot;\\t\\t&quot; &lt;&lt; &quot;a33 = &quot; &lt;&lt; a[2][2] &lt;&lt; std::endl;\n    std::cout &lt;&lt; std::endl;\n}\n\nint wmain(int argc, wchar_t * argv[])\n{\n    int a1[3][3] = { 11,  12,  13,      // The most\n                     21,  22,  23,      // basic\n                     31,  32,  33   };  // format.\n                                    \n    int a2[][3]  = { 11,  12,  13,      // The first (outer) dimension\n                     21,  22,  23,      // may be omitted. The compiler\n                     31,  32,  33   };  // will automatically deduce it.\n                                    \n    int a3[3][3] = { {11, 12,  13},     // The elements of each\n                     {21, 22,  23},     // second (inner) dimension\n                     {31, 32,  33}  };  // can be grouped together.\n                                    \n    int a4[][3]  = { {11, 12,  13},     // Again, the first dimension\n                     {21, 22,  23},     // can be omitted when the\n                     {31, 32,  33}  };  // inner elements are grouped.\n\n    PrintArray(a1);\n    PrintArray(a2);\n    PrintArray(a3);\n    PrintArray(a4);\n\n    // This part shows in which order the elements are stored in the memory.\n    int * b = (int *) a1;    // The output is the same for the all four arrays.\n    for (int i=0; i&lt;9; i++)\n    {\n        std::cout &lt;&lt; b[i] &lt;&lt; '\\t';\n    }\n\n    return 0;\n}\n\na11 = 11                a12 = 12                a13 = 13\na21 = 21                a22 = 22                a23 = 23\na31 = 31                a32 = 32                a33 = 33\n\na11 = 11                a12 = 12                a13 = 13\na21 = 21                a22 = 22                a23 = 23\na31 = 31                a32 = 32                a33 = 33\n\na11 = 11                a12 = 12                a13 = 13\na21 = 21                a22 = 22                a23 = 23\na31 = 31                a32 = 32                a33 = 33\n\na11 = 11                a12 = 12                a13 = 13\na21 = 21                a22 = 22                a23 = 23\na31 = 31                a32 = 32                a33 = 33\n\n11      12      13      21      22      23      31      32      33\n",
            "int i, value=5, array[1000]; \nfor(i=0; i&lt;1000; i++) \n    array[i] = value; \n",
            "#include &lt;stdio.h&gt;\n\ntypedef const unsigned int cUINT;\ntypedef unsigned int UINT;\n\ncUINT size = 10;\ncUINT initVal = 5;\n\nvoid arrayInitializer(UINT* myArray, cUINT size, cUINT initVal);\nvoid printArray(UINT* myArray);\n\nint main() {\n    UINT myArray[size];\n    /* Not initialized during declaration, but it can be\n    initialized using a function for the appropriate TYPE*/\n    arrayInitializer(myArray, size, initVal);\n\n    printArray(myArray);\n\n    return 0;\n}\n\nvoid arrayInitializer(UINT* myArray, cUINT size, cUINT initVal) {\n    for (UINT n = 0; n &lt; size; n++) {\n        myArray[n] = initVal;\n    }\n}\n\nvoid printArray(UINT* myArray) {\n    printf(&quot;myArray = { &quot;);\n    for (UINT n = 0; n &lt; size; n++) {\n        printf(&quot;%u&quot;, myArray[n]);\n\n        if (n &lt; size-1)\n            printf(&quot;, &quot;);\n    }\n    printf(&quot; }\\n&quot;);\n}\n\nUINT myArray[size];\ninitializing function\ntype\nprintArray()",
            "int a[4];\n\nunsigned int size = sizeof(a) / sizeof(a[0]);\nfor (unsigned int i = 0; i &lt; size; i++)\n  a[i] = 0;\n",
            "#include &lt;boost/preprocessor/repetition/enum.hpp&gt;\n#define C_ARRAY_ELEMENT(z, index, name) name[index]\n#define C_ARRAY_EXPAND(name,size) BOOST_PP_ENUM(size,C_ARRAY_ELEMENT,name)\n#define C_ARRAY_VALUE(z, index, value) value\n#define C_ARRAY_INITIALIZE(value,size) BOOST_PP_ENUM(size,C_ARRAY_VALUE,value)\n",
            "  char arr[1000] = { 0 };\n\n  char arr[1000];\n  for(int i=0; i&lt;arr.size(); i++){\n     arr[i] = 'A';\n  }\n",
            "template &lt;size_t Cnt, typename T&gt;                                               \nstd::array&lt;T, Cnt&gt; make_array_of(const T&amp; v)                                           \n{                                                                               \n    return []&lt;size_t... Idx&gt;(std::index_sequence&lt;Idx...&gt;, const auto&amp; v)        \n    {                                                                           \n        auto identity = [](const auto&amp; v, size_t) { return v; };                \n        return std::array{identity(v, Idx)...};                                 \n    }                                                                           \n    (std::make_index_sequence&lt;Cnt&gt;{}, v);                                       \n}\n",
            "int a[5] = {3, 3, 3, 3, 3};\n\nint a[100] = {0};\n\nint a[10] = {1};\n\nint a[100];\n\nint a[1000] = {0};\n",
            "// macros.h\n#define INDEX_SEQUENCE(X) _indexseq_expand(X)\n#define _indexseq_expand(X) _indeseq_concat(_indexseq, X)\n\n#define _indexseq_concat(a, b) _indexseq_concat_expand(a, b)\n#define _indexseq_concat_expand(a, b) a##b\n\n#define _indexseq1 0\n#define _indexseq2 _indexseq1, 1\n// generate as above to a given max size\n\n#define APPLY_FOR_EACH(macro, ...) _foreach(macro, _vaargsn(__VA_ARGS__), __VA_ARGS__)\n#define _foreach(macro, n, ...) _foreach_concat(_foreach, n)(macro, __VA_ARGS__)\n\n#define _foreach_concat(a, b) _foreach_concat_expand(a, b)\n#define _foreach_concat_expand(a, b) a##b\n\n#define _foreach1(macro, i) macro(i)\n#define _foreach2(macro, i, ...) macro(i) _foreach1(__VA_ARGS__)\n// generate as above to a given max size\n\n#define _vaargsn(...) _vaargsnpp(__VA_ARGS__, _vaargsnidx())\n// macros below shall be generated as well until a given max size\n#define _vaargsnpp(_1, _2, _3, N, ...) N\n#define _vaargsnidx() 3, 2, 1\n\n#define CONFIGURED_SIZE 42\n\nstruct complex_struct {\n    int zero, one;\n    float pi;\n    unsigned index;\n};\n\n#define INIT(I) { 0, 1, 3.14159f, I },\nstruct complex_struct array[CONFIGURED_SIZE] = {\n    APPLY_FOR_EACH(INIT, INDEX_SEQUENCE(CONFIGURED_SIZE))\n};\n",
            "memcpy (&amp;element [1], &amp;element [0], sizeof (element)-sizeof (element [0]);",
            "#include &lt;string.h&gt;\n\nvoid array_init(void *start, size_t element_size, size_t elements, void *initval) {\n  memcpy(       start,                initval, element_size             );\n  memcpy((char*)start + element_size, start,   element_size*(elements-1));\n}\n\n// Testing\n#include &lt;stdio.h&gt;\n\nstruct s {\n  int a;\n  char b;\n} array[2][3], init;\n\nint main() {\n  init = (struct s){.a = 3, .b = 'x'};\n  array_init(array, sizeof(array[0][0]), 2*3, &amp;init);\n\n  for(int i=0; i&lt;2; i++)\n    for(int j=0; j&lt;3; j++)\n      printf(&quot;array[%i][%i].a = %i .b = '%c'\\n&quot;, i, j, array[i][j].a, array[i][j].b);\n}\n\narray[0][0].a = 3 .b = 'x'\narray[0][1].a = 3 .b = 'x'\narray[0][2].a = 3 .b = 'x'\narray[1][0].a = 3 .b = 'x'\narray[1][1].a = 3 .b = 'x'\narray[1][2].a = 3 .b = 'x'\n",
            "#include &lt;stdio.h&gt;\n\nint main()\n{\n    int i, a[50];\n    for (i=0; i&lt;50; i++) {\n        a[i]=5; // Set value 5 to all the array index\n    }\n    for (i=0; i&lt;50; i++)\n        printf(&quot;%d\\n&quot;, a[i]);\n    return 0;\n}\n"
        ]
    },
    {
        "question_id": 24853,
        "question_code": "++i\ni++\nfor",
        "answer_code_snippets": [
            "++i\ni\n i = 1;\n j = ++i;\n (i is 2, j is 2)\n\ni++\ni\ni\n i = 1;\n j = i++;\n (i is 2, j is 1)\n\nfor\n++i\n++i\ni++\n++i\ni++\noperator++()",
            "i++\n++i\ni++\ni++\ni\nint i = 1, j;\nj = i++;\n\nj = 1\ni = 2\ni\nj\ni\n++i\n++i\ni\nj = i;\ni++\nint i = 1, j;\nj = ++i;\n\nj = 2\ni = 2\ni\nj\ni\ni\n++i\nj=i;\nfor(i=0; i&lt;5; i++)\n   printf(&quot;%d &quot;, i);\n\nfor(i=0; i&lt;5; ++i)\n   printf(&quot;%d &quot;, i);\n\n0 1 2 3 4\nfor(i = 0; i&lt;5;)\n    printf(&quot;%d &quot;, ++i);\n\n1 2 3 4 5",
            "i++\n++i",
            "++i\ni++\n++i\ni++",
            "#include&lt;stdio.h&gt;\n\nint main(int argc, char* argv[])\n{\n  unsigned int i=0, a;\n  printf(&quot;i initial value: %d; &quot;, i);\n  a = i++;\n  printf(&quot;value returned by i++: %d, i after: %d\\n&quot;, a, i);\n  i=0;\n  printf(&quot;i initial value: %d; &quot;, i);\n  a = ++i;\n  printf(&quot; value returned by ++i: %d, i after: %d\\n&quot;,a, i);\n}\n\ni initial value: 0; value returned by i++: 0, i after: 1\ni initial value: 0;  value returned by ++i: 1, i after: 1\n\n++i\ni++\ni\n#include&lt;stdio.h&gt;\n\nint main ()\n  int i=0;\n  int a = i++*2;\n  printf(&quot;i=0, i++*2=%d\\n&quot;, a);\n  i=0;\n  a = ++i * 2;\n  printf(&quot;i=0, ++i*2=%d\\n&quot;, a);\n  i=0;\n  a = (++i) * 2;\n  printf(&quot;i=0, (++i)*2=%d\\n&quot;, a);\n  i=0;\n  a = (i++) * 2;\n  printf(&quot;i=0, (i++)*2=%d\\n&quot;, a);\n  return 0;\n}\n\ni=0, i++*2=0\ni=0, ++i*2=2\ni=0, (++i)*2=2\ni=0, (i++)*2=0\n\ni++*2\n++i*2\n(i++)*2\n(++i)*2\nfor(int i=0; i&lt;10; i++)\n\nfor(int i=0; i&lt;10; ++i)\n\n++\ni\n++\n++\ni\n++\ni",
            "++i\ni++\ni++\n++i\n++i",
            "++i\ni++\n++i\nint i = 0;\nprintf(\"i: %d\\n\", i);\nprintf(\"i++: %d\\n\", i++);\nprintf(\"++i: %d\\n\", ++i);\n\ni: 0\ni++: 0\n++i: 2\n",
            "++i\nint i = 5\nint b = ++i\ni++\nint i = 5\nint b = i++\ni++\ni",
            "int i = 10, j = 10;\n  \nprintf (&quot;i is %i \\n&quot;, i);\nprintf (&quot;i++ is %i \\n&quot;, i++);\nprintf (&quot;i is %i \\n\\n&quot;, i);\n  \nprintf (&quot;j is %i \\n&quot;, j);\nprintf (&quot;++j is %i \\n&quot;, ++j);\nprintf (&quot;j is %i \\n&quot;, j);\n\n//Remember that the values are i = 10, and j = 10\n\ni is 10 \ni++ is 10     //Assigns (print out), then increments\ni is 11 \n\nj is 10 \n++j is 11    //Increments, then assigns (print out)\nj is 11 \n\nint i, j;\n\nfor (i = 0; i &lt;= 3; i++)\n    printf (&quot; &gt; iteration #%i&quot;, i);\n\nprintf (&quot;\\n&quot;);\n\nfor (j = 0; j &lt;= 3; ++j)\n    printf (&quot; &gt; iteration #%i&quot;, j);\n\n&gt; iteration #0 &gt; iteration #1 &gt; iteration #2 &gt; iteration #3\n&gt; iteration #0 &gt; iteration #1 &gt; iteration #2 &gt; iteration #3 \n",
            "int  i;\nint  j;\n\ni = 1;\nj = ++i;    // i is now 2, j is also 2\nj = i++;    // i is now 3, j is 2\n",
            "++i\ni++\nfunction(i++)\nfunction(++i)\nfunction(++i)\ni\nfunction(i++)\ni\ni\nint i=4;\nprintf(\"%d\\n\",pow(++i,2));//it prints 25 and i is 5 now\ni=4;\nprintf(\"%d\",pow(i++,2));//it prints 16 i is 5 now\n",
            "int j = 0;\nSystem.out.println(j); // 0\nSystem.out.println(j++); // 0. post-increment. It means after this line executes j increments.\n\nint k = 0;\nSystem.out.println(k); // 0\nSystem.out.println(++k); // 1. pre increment. It means it increments first and then the line executes\n\nint m = 0;\nif((m == 0 || m++ == 0) &amp;&amp; (m++ == 1)) { // False\n    // In the OR condition, if the first line is already true\n    // then the compiler doesn't check the rest. It is a\n    // technique of compiler optimization\n    System.out.println(&quot;post-increment &quot; + m);\n}\n\nint n = 0;\nif((n == 0 || n++ == 0) &amp;&amp; (++n == 1)) { // True\n    System.out.println(&quot;pre-increment &quot; + n); // 1\n}\n\nSystem.out.println(&quot;In Array&quot;);\nint[] a = { 55, 11, 15, 20, 25 };\nint ii, jj, kk = 1, mm;\nii = ++a[1]; // ii = 12. a[1] = a[1] + 1\nSystem.out.println(a[1]); // 12\n\njj = a[1]++; // 12\nSystem.out.println(a[1]); // a[1] = 13\n\nmm = a[1]; // 13\nSystem.out.printf(&quot;\\n%d %d %d\\n&quot;, ii, jj, mm); // 12, 12, 13\n\nfor (int val: a) {\n     System.out.print(&quot; &quot; + val); // 55, 13, 15, 20, 25\n}\n\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n\n    int x = 10;\n    int* p = &amp;x;\n\n    std::cout &lt;&lt; &quot;address = &quot; &lt;&lt; p &lt;&lt;&quot;\\n&quot;; // Prints the address of x\n    std::cout &lt;&lt; &quot;address = &quot; &lt;&lt; p &lt;&lt;&quot;\\n&quot;; // Prints (the address of x) + sizeof(int)\n    std::cout &lt;&lt; &quot;address = &quot; &lt;&lt; &amp;x &lt;&lt;&quot;\\n&quot;; // Prints the address of x\n\n    std::cout &lt;&lt; &quot;address = &quot; &lt;&lt; ++&amp;x &lt;&lt; &quot;\\n&quot;; // Error. The reference can't reassign, because it is fixed (immutable).\n}\n",
            "int i = 1;\nint j = i++;\n\nj\n1\nint i = 1;\nint j = ++i;\n\nj\n2\ni\n2",
            "for (int i = 0; i != X; ++i) ...\n",
            "i =1\n1,2,3,4,n\ni =1\n2,3,4,5,n",
            "int i, j, k, l;\ni = 1; //initialize int i with 1\nj = i+1; //add 1 with i and set that as the value of j. i is still 1\nk = i++; //k gets the current value of i, after that i is incremented. So here i is 2, but k is 1\nl = ++i; // i is incremented first and then returned. So the value of i is 3 and so does l.\ncout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; j &lt;&lt; ' ' &lt;&lt; k &lt;&lt; ' '&lt;&lt; l &lt;&lt; endl;\nreturn 0;\n",
            "// case 1\n\ni++;\n\n/* you can think as,\n * i;\n * i= i+1;\n */\n\n\n\n// case 2\n\n++i;\n\n/* you can think as,\n * i = i+i;\n * i;\n */\n",
            "++\n++\nclass Int {\n    private:\n        int i;\n\n    public:\n        Int(int i)\n        {\n            this-&gt;i = i;\n        }\n\n        // Overloading the prefix operator\n        Int&amp; operator++()\n        {\n            ++i;\n            // returned value should be a reference to *this\n            return *this;\n        }\n\n        // Overloading the postfix operator\n        Int operator++(int)\n        {\n            // returned value should be a copy of the object before increment\n            Int obj = *this;\n            ++i;\n            return obj;\n        }\n};\n"
        ]
    },
    {
        "question_id": 19210935,
        "question_code": "linux\n1\n#include &lt;stdio.h&gt;\nint main(void)\n{       \n    int linux = 5;\n    return 0;\n}\n\n$ gcc -E test.c\n....\nint main(void)\n{\n    int 1 = 5;\n    return 0;\n}\n\n#define linux\nstdio.h",
        "answer_code_snippets": [
            "unix\nvax\n#ifdef\nunix\nunix\nlinux\nint linux = 5;\ngcc -std=c90 -pedantic ... # or -std=c89 or -ansi\ngcc -std=c99 -pedantic\ngcc -std=c11 -pedantic\n\nunix\nlinux\n__linux__\nunix\nmain() { printf(&amp;unix[&quot;\\021%six\\012\\0&quot;],(unix)[&quot;have&quot;]+&quot;fun&quot;-0x60);}\n\n&quot;unix&quot;",
            "-dM\n-std=gnu99\n-std=c99\n$ cpp --std=c89 -dM &lt; /dev/null | grep linux\n#define __linux 1\n#define __linux__ 1\n#define __gnu_linux__ 1\n\n$ cpp --std=gnu89 -dM &lt; /dev/null | grep linux\n#define __linux 1\n#define __linux__ 1\n#define __gnu_linux__ 1\n#define linux 1\n\n$ cpp --std=c99 -dM &lt; /dev/null | grep linux\n#define __linux 1\n#define __linux__ 1\n#define __gnu_linux__ 1\n\n$ cpp --std=gnu99 -dM &lt; /dev/null | grep linux\n#define __linux 1\n#define __linux__ 1\n#define __gnu_linux__ 1\n#define linux 1\n\n#define unix\nc11\ngnu11\n-std=gnu89\ncpp",
            "linux\ncp /dev/null emptyfile.c\ngcc -E -dM emptyfile.c\n\n/dev/null\n#define __DBL_MIN_EXP__ (-1021)\n#define __UINT_LEAST16_MAX__ 65535\n#define __ATOMIC_ACQUIRE 2\n#define __FLT_MIN__ 1.17549435082228750797e-38F\n#define __UINT_LEAST8_TYPE__ unsigned char\n#define __INTMAX_C(c) c ## L\n#define __CHAR_BIT__ 8\n#define __UINT8_MAX__ 255\n#define __WINT_MAX__ 2147483647\n#define __ORDER_LITTLE_ENDIAN__ 1234\n#define __SIZE_MAX__ 18446744073709551615UL\n#define __WCHAR_MAX__ 2147483647\n#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1 1\n#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2 1\n#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4 1\n#define __DBL_DENORM_MIN__ ((double)4.94065645841246544177e-324L)\n#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8 1\n#define __GCC_ATOMIC_CHAR_LOCK_FREE 2\n#define __FLT_EVAL_METHOD__ 0\n#define __GCC_ATOMIC_CHAR32_T_LOCK_FREE 2\n#define __x86_64 1\n#define __UINT_FAST64_MAX__ 18446744073709551615ULL\n#define __SIG_ATOMIC_TYPE__ int\n#define __DBL_MIN_10_EXP__ (-307)\n#define __FINITE_MATH_ONLY__ 0\n#define __GNUC_PATCHLEVEL__ 1\n#define __UINT_FAST8_MAX__ 255\n#define __DEC64_MAX_EXP__ 385\n#define __INT8_C(c) c\n#define __UINT_LEAST64_MAX__ 18446744073709551615ULL\n#define __SHRT_MAX__ 32767\n#define __LDBL_MAX__ 1.18973149535723176502e+4932L\n#define __UINT_LEAST8_MAX__ 255\n#define __GCC_ATOMIC_BOOL_LOCK_FREE 2\n#define __APPLE_CC__ 1\n#define __UINTMAX_TYPE__ long unsigned int\n#define __DEC32_EPSILON__ 1E-6DF\n#define __UINT32_MAX__ 4294967295U\n#define __LDBL_MAX_EXP__ 16384\n#define __WINT_MIN__ (-__WINT_MAX__ - 1)\n#define __SCHAR_MAX__ 127\n#define __WCHAR_MIN__ (-__WCHAR_MAX__ - 1)\n#define __INT64_C(c) c ## LL\n#define __DBL_DIG__ 15\n#define __GCC_ATOMIC_POINTER_LOCK_FREE 2\n#define __SIZEOF_INT__ 4\n#define __SIZEOF_POINTER__ 8\n#define __USER_LABEL_PREFIX__ _\n#define __STDC_HOSTED__ 1\n#define __LDBL_HAS_INFINITY__ 1\n#define __FLT_EPSILON__ 1.19209289550781250000e-7F\n#define __LDBL_MIN__ 3.36210314311209350626e-4932L\n#define __DEC32_MAX__ 9.999999E96DF\n#define __strong \n#define __INT32_MAX__ 2147483647\n#define __SIZEOF_LONG__ 8\n#define __APPLE__ 1\n#define __UINT16_C(c) c\n#define __DECIMAL_DIG__ 21\n#define __LDBL_HAS_QUIET_NAN__ 1\n#define __DYNAMIC__ 1\n#define __GNUC__ 4\n#define __MMX__ 1\n#define __FLT_HAS_DENORM__ 1\n#define __SIZEOF_LONG_DOUBLE__ 16\n#define __BIGGEST_ALIGNMENT__ 16\n#define __DBL_MAX__ ((double)1.79769313486231570815e+308L)\n#define __INT_FAST32_MAX__ 2147483647\n#define __DBL_HAS_INFINITY__ 1\n#define __DEC32_MIN_EXP__ (-94)\n#define __INT_FAST16_TYPE__ short int\n#define __LDBL_HAS_DENORM__ 1\n#define __DEC128_MAX__ 9.999999999999999999999999999999999E6144DL\n#define __INT_LEAST32_MAX__ 2147483647\n#define __DEC32_MIN__ 1E-95DF\n#define __weak \n#define __DBL_MAX_EXP__ 1024\n#define __DEC128_EPSILON__ 1E-33DL\n#define __SSE2_MATH__ 1\n#define __ATOMIC_HLE_RELEASE 131072\n#define __PTRDIFF_MAX__ 9223372036854775807L\n#define __amd64 1\n#define __tune_core2__ 1\n#define __ATOMIC_HLE_ACQUIRE 65536\n#define __LONG_LONG_MAX__ 9223372036854775807LL\n#define __SIZEOF_SIZE_T__ 8\n#define __SIZEOF_WINT_T__ 4\n#define __GXX_ABI_VERSION 1002\n#define __FLT_MIN_EXP__ (-125)\n#define __INT_FAST64_TYPE__ long long int\n#define __DBL_MIN__ ((double)2.22507385850720138309e-308L)\n#define __LP64__ 1\n#define __DEC128_MIN__ 1E-6143DL\n#define __REGISTER_PREFIX__ \n#define __UINT16_MAX__ 65535\n#define __DBL_HAS_DENORM__ 1\n#define __UINT8_TYPE__ unsigned char\n#define __NO_INLINE__ 1\n#define __FLT_MANT_DIG__ 24\n#define __VERSION__ \"4.8.1\"\n#define __UINT64_C(c) c ## ULL\n#define __GCC_ATOMIC_INT_LOCK_FREE 2\n#define __FLOAT_WORD_ORDER__ __ORDER_LITTLE_ENDIAN__\n#define __INT32_C(c) c\n#define __DEC64_EPSILON__ 1E-15DD\n#define __ORDER_PDP_ENDIAN__ 3412\n#define __DEC128_MIN_EXP__ (-6142)\n#define __INT_FAST32_TYPE__ int\n#define __UINT_LEAST16_TYPE__ short unsigned int\n#define __INT16_MAX__ 32767\n#define __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ 1080\n#define __SIZE_TYPE__ long unsigned int\n#define __UINT64_MAX__ 18446744073709551615ULL\n#define __INT8_TYPE__ signed char\n#define __FLT_RADIX__ 2\n#define __INT_LEAST16_TYPE__ short int\n#define __LDBL_EPSILON__ 1.08420217248550443401e-19L\n#define __UINTMAX_C(c) c ## UL\n#define __SSE_MATH__ 1\n#define __k8 1\n#define __SIG_ATOMIC_MAX__ 2147483647\n#define __GCC_ATOMIC_WCHAR_T_LOCK_FREE 2\n#define __SIZEOF_PTRDIFF_T__ 8\n#define __x86_64__ 1\n#define __DEC32_SUBNORMAL_MIN__ 0.000001E-95DF\n#define __INT_FAST16_MAX__ 32767\n#define __UINT_FAST32_MAX__ 4294967295U\n#define __UINT_LEAST64_TYPE__ long long unsigned int\n#define __FLT_HAS_QUIET_NAN__ 1\n#define __FLT_MAX_10_EXP__ 38\n#define __LONG_MAX__ 9223372036854775807L\n#define __DEC128_SUBNORMAL_MIN__ 0.000000000000000000000000000000001E-6143DL\n#define __FLT_HAS_INFINITY__ 1\n#define __UINT_FAST16_TYPE__ short unsigned int\n#define __DEC64_MAX__ 9.999999999999999E384DD\n#define __CHAR16_TYPE__ short unsigned int\n#define __PRAGMA_REDEFINE_EXTNAME 1\n#define __INT_LEAST16_MAX__ 32767\n#define __DEC64_MANT_DIG__ 16\n#define __INT64_MAX__ 9223372036854775807LL\n#define __UINT_LEAST32_MAX__ 4294967295U\n#define __GCC_ATOMIC_LONG_LOCK_FREE 2\n#define __INT_LEAST64_TYPE__ long long int\n#define __INT16_TYPE__ short int\n#define __INT_LEAST8_TYPE__ signed char\n#define __DEC32_MAX_EXP__ 97\n#define __INT_FAST8_MAX__ 127\n#define __INTPTR_MAX__ 9223372036854775807L\n#define __LITTLE_ENDIAN__ 1\n#define __SSE2__ 1\n#define __LDBL_MANT_DIG__ 64\n#define __CONSTANT_CFSTRINGS__ 1\n#define __DBL_HAS_QUIET_NAN__ 1\n#define __SIG_ATOMIC_MIN__ (-__SIG_ATOMIC_MAX__ - 1)\n#define __code_model_small__ 1\n#define __k8__ 1\n#define __INTPTR_TYPE__ long int\n#define __UINT16_TYPE__ short unsigned int\n#define __WCHAR_TYPE__ int\n#define __SIZEOF_FLOAT__ 4\n#define __pic__ 2\n#define __UINTPTR_MAX__ 18446744073709551615UL\n#define __DEC64_MIN_EXP__ (-382)\n#define __INT_FAST64_MAX__ 9223372036854775807LL\n#define __GCC_ATOMIC_TEST_AND_SET_TRUEVAL 1\n#define __FLT_DIG__ 6\n#define __UINT_FAST64_TYPE__ long long unsigned int\n#define __INT_MAX__ 2147483647\n#define __MACH__ 1\n#define __amd64__ 1\n#define __INT64_TYPE__ long long int\n#define __FLT_MAX_EXP__ 128\n#define __ORDER_BIG_ENDIAN__ 4321\n#define __DBL_MANT_DIG__ 53\n#define __INT_LEAST64_MAX__ 9223372036854775807LL\n#define __GCC_ATOMIC_CHAR16_T_LOCK_FREE 2\n#define __DEC64_MIN__ 1E-383DD\n#define __WINT_TYPE__ int\n#define __UINT_LEAST32_TYPE__ unsigned int\n#define __SIZEOF_SHORT__ 2\n#define __SSE__ 1\n#define __LDBL_MIN_EXP__ (-16381)\n#define __INT_LEAST8_MAX__ 127\n#define __SIZEOF_INT128__ 16\n#define __LDBL_MAX_10_EXP__ 4932\n#define __ATOMIC_RELAXED 0\n#define __DBL_EPSILON__ ((double)2.22044604925031308085e-16L)\n#define _LP64 1\n#define __UINT8_C(c) c\n#define __INT_LEAST32_TYPE__ int\n#define __SIZEOF_WCHAR_T__ 4\n#define __UINT64_TYPE__ long long unsigned int\n#define __INT_FAST8_TYPE__ signed char\n#define __DBL_DECIMAL_DIG__ 17\n#define __FXSR__ 1\n#define __DEC_EVAL_METHOD__ 2\n#define __UINT32_C(c) c ## U\n#define __INTMAX_MAX__ 9223372036854775807L\n#define __BYTE_ORDER__ __ORDER_LITTLE_ENDIAN__\n#define __FLT_DENORM_MIN__ 1.40129846432481707092e-45F\n#define __INT8_MAX__ 127\n#define __PIC__ 2\n#define __UINT_FAST32_TYPE__ unsigned int\n#define __CHAR32_TYPE__ unsigned int\n#define __FLT_MAX__ 3.40282346638528859812e+38F\n#define __INT32_TYPE__ int\n#define __SIZEOF_DOUBLE__ 8\n#define __FLT_MIN_10_EXP__ (-37)\n#define __INTMAX_TYPE__ long int\n#define __DEC128_MAX_EXP__ 6145\n#define __ATOMIC_CONSUME 1\n#define __GNUC_MINOR__ 8\n#define __UINTMAX_MAX__ 18446744073709551615UL\n#define __DEC32_MANT_DIG__ 7\n#define __DBL_MAX_10_EXP__ 308\n#define __LDBL_DENORM_MIN__ 3.64519953188247460253e-4951L\n#define __INT16_C(c) c\n#define __STDC__ 1\n#define __PTRDIFF_TYPE__ long int\n#define __ATOMIC_SEQ_CST 5\n#define __UINT32_TYPE__ unsigned int\n#define __UINTPTR_TYPE__ long unsigned int\n#define __DEC64_SUBNORMAL_MIN__ 0.000000000000001E-383DD\n#define __DEC128_MANT_DIG__ 34\n#define __LDBL_MIN_10_EXP__ (-4931)\n#define __SIZEOF_LONG_LONG__ 8\n#define __GCC_ATOMIC_LLONG_LOCK_FREE 2\n#define __LDBL_DIG__ 18\n#define __FLT_DECIMAL_DIG__ 9\n#define __UINT_FAST16_MAX__ 65535\n#define __GNUC_GNU_INLINE__ 1\n#define __GCC_ATOMIC_SHORT_LOCK_FREE 2\n#define __SSE3__ 1\n#define __UINT_FAST8_TYPE__ unsigned char\n#define __ATOMIC_ACQ_REL 4\n#define __ATOMIC_RELEASE 3\n\n#include &lt;stdio.h&gt;",
            "info gcc\n-ansi\n-std=c90\n-std=c++98\nasm\ntypeof\n//\ninline\n-ansi",
            "gcc -dM -E - &lt; /dev/null\n\n    #define _LP64 1\n#define _STDC_PREDEF_H 1\n#define __ATOMIC_ACQUIRE 2\n#define __ATOMIC_ACQ_REL 4\n#define __ATOMIC_CONSUME 1\n#define __ATOMIC_HLE_ACQUIRE 65536\n#define __ATOMIC_HLE_RELEASE 131072\n#define __ATOMIC_RELAXED 0\n#define __ATOMIC_RELEASE 3\n#define __ATOMIC_SEQ_CST 5\n#define __BIGGEST_ALIGNMENT__ 16\n#define __BYTE_ORDER__ __ORDER_LITTLE_ENDIAN__\n#define __CHAR16_TYPE__ short unsigned int\n#define __CHAR32_TYPE__ unsigned int\n#define __CHAR_BIT__ 8\n#define __DBL_DECIMAL_DIG__ 17\n#define __DBL_DENORM_MIN__ ((double)4.94065645841246544177e-324L)\n#define __DBL_DIG__ 15\n#define __DBL_EPSILON__ ((double)2.22044604925031308085e-16L)\n#define __DBL_HAS_DENORM__ 1\n#define __DBL_HAS_INFINITY__ 1\n#define __DBL_HAS_QUIET_NAN__ 1\n#define __DBL_MANT_DIG__ 53\n#define __DBL_MAX_10_EXP__ 308\n#define __DBL_MAX_EXP__ 1024\n#define __DBL_MAX__ ((double)1.79769313486231570815e+308L)\n#define __DBL_MIN_10_EXP__ (-307)\n#define __DBL_MIN_EXP__ (-1021)\n#define __DBL_MIN__ ((double)2.22507385850720138309e-308L)\n#define __DEC128_EPSILON__ 1E-33DL\n#define __DEC128_MANT_DIG__ 34\n#define __DEC128_MAX_EXP__ 6145\n#define __DEC128_MAX__ 9.999999999999999999999999999999999E6144DL\n#define __DEC128_MIN_EXP__ (-6142)\n#define __DEC128_MIN__ 1E-6143DL\n#define __DEC128_SUBNORMAL_MIN__ 0.000000000000000000000000000000001E-6143DL\n#define __DEC32_EPSILON__ 1E-6DF\n#define __DEC32_MANT_DIG__ 7\n#define __DEC32_MAX_EXP__ 97\n#define __DEC32_MAX__ 9.999999E96DF\n#define __DEC32_MIN_EXP__ (-94)\n#define __DEC32_MIN__ 1E-95DF\n#define __DEC32_SUBNORMAL_MIN__ 0.000001E-95DF\n#define __DEC64_EPSILON__ 1E-15DD\n#define __DEC64_MANT_DIG__ 16\n#define __DEC64_MAX_EXP__ 385\n#define __DEC64_MAX__ 9.999999999999999E384DD\n#define __DEC64_MIN_EXP__ (-382)\n#define __DEC64_MIN__ 1E-383DD\n#define __DEC64_SUBNORMAL_MIN__ 0.000000000000001E-383DD\n#define __DECIMAL_BID_FORMAT__ 1\n#define __DECIMAL_DIG__ 21\n#define __DEC_EVAL_METHOD__ 2\n#define __ELF__ 1\n#define __FINITE_MATH_ONLY__ 0\n#define __FLOAT_WORD_ORDER__ __ORDER_LITTLE_ENDIAN__\n#define __FLT_DECIMAL_DIG__ 9\n#define __FLT_DENORM_MIN__ 1.40129846432481707092e-45F\n#define __FLT_DIG__ 6\n#define __FLT_EPSILON__ 1.19209289550781250000e-7F\n#define __FLT_EVAL_METHOD__ 0\n#define __FLT_HAS_DENORM__ 1\n#define __FLT_HAS_INFINITY__ 1\n#define __FLT_HAS_QUIET_NAN__ 1\n#define __FLT_MANT_DIG__ 24\n#define __FLT_MAX_10_EXP__ 38\n#define __FLT_MAX_EXP__ 128\n#define __FLT_MAX__ 3.40282346638528859812e+38F\n#define __FLT_MIN_10_EXP__ (-37)\n#define __FLT_MIN_EXP__ (-125)\n#define __FLT_MIN__ 1.17549435082228750797e-38F\n#define __FLT_RADIX__ 2\n#define __FXSR__ 1\n#define __GCC_ASM_FLAG_OUTPUTS__ 1\n#define __GCC_ATOMIC_BOOL_LOCK_FREE 2\n#define __GCC_ATOMIC_CHAR16_T_LOCK_FREE 2\n#define __GCC_ATOMIC_CHAR32_T_LOCK_FREE 2\n#define __GCC_ATOMIC_CHAR_LOCK_FREE 2\n#define __GCC_ATOMIC_INT_LOCK_FREE 2\n#define __GCC_ATOMIC_LLONG_LOCK_FREE 2\n#define __GCC_ATOMIC_LONG_LOCK_FREE 2\n#define __GCC_ATOMIC_POINTER_LOCK_FREE 2\n#define __GCC_ATOMIC_SHORT_LOCK_FREE 2\n#define __GCC_ATOMIC_TEST_AND_SET_TRUEVAL 1\n#define __GCC_ATOMIC_WCHAR_T_LOCK_FREE 2\n#define __GCC_HAVE_DWARF2_CFI_ASM 1\n#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1 1\n#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2 1\n#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4 1\n#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8 1\n#define __GCC_IEC_559 2\n#define __GCC_IEC_559_COMPLEX 2\n#define __GNUC_MINOR__ 3\n#define __GNUC_PATCHLEVEL__ 0\n#define __GNUC_STDC_INLINE__ 1\n#define __GNUC__ 6\n#define __GXX_ABI_VERSION 1010\n#define __INT16_C(c) c\n#define __INT16_MAX__ 0x7fff\n#define __INT16_TYPE__ short int\n#define __INT32_C(c) c\n#define __INT32_MAX__ 0x7fffffff\n#define __INT32_TYPE__ int\n#define __INT64_C(c) c ## L\n#define __INT64_MAX__ 0x7fffffffffffffffL\n#define __INT64_TYPE__ long int\n#define __INT8_C(c) c\n#define __INT8_MAX__ 0x7f\n#define __INT8_TYPE__ signed char\n#define __INTMAX_C(c) c ## L\n#define __INTMAX_MAX__ 0x7fffffffffffffffL\n#define __INTMAX_TYPE__ long int\n#define __INTPTR_MAX__ 0x7fffffffffffffffL\n#define __INTPTR_TYPE__ long int\n#define __INT_FAST16_MAX__ 0x7fffffffffffffffL\n#define __INT_FAST16_TYPE__ long int\n#define __INT_FAST32_MAX__ 0x7fffffffffffffffL\n#define __INT_FAST32_TYPE__ long int\n#define __INT_FAST64_MAX__ 0x7fffffffffffffffL\n#define __INT_FAST64_TYPE__ long int\n#define __INT_FAST8_MAX__ 0x7f\n#define __INT_FAST8_TYPE__ signed char\n#define __INT_LEAST16_MAX__ 0x7fff\n#define __INT_LEAST16_TYPE__ short int\n#define __INT_LEAST32_MAX__ 0x7fffffff\n#define __INT_LEAST32_TYPE__ int\n#define __INT_LEAST64_MAX__ 0x7fffffffffffffffL\n#define __INT_LEAST64_TYPE__ long int\n#define __INT_LEAST8_MAX__ 0x7f\n#define __INT_LEAST8_TYPE__ signed char\n#define __INT_MAX__ 0x7fffffff\n#define __LDBL_DENORM_MIN__ 3.64519953188247460253e-4951L\n#define __LDBL_DIG__ 18\n#define __LDBL_EPSILON__ 1.08420217248550443401e-19L\n#define __LDBL_HAS_DENORM__ 1\n#define __LDBL_HAS_INFINITY__ 1\n#define __LDBL_HAS_QUIET_NAN__ 1\n#define __LDBL_MANT_DIG__ 64\n#define __LDBL_MAX_10_EXP__ 4932\n#define __LDBL_MAX_EXP__ 16384\n#define __LDBL_MAX__ 1.18973149535723176502e+4932L\n#define __LDBL_MIN_10_EXP__ (-4931)\n#define __LDBL_MIN_EXP__ (-16381)\n#define __LDBL_MIN__ 3.36210314311209350626e-4932L\n#define __LONG_LONG_MAX__ 0x7fffffffffffffffLL\n#define __LONG_MAX__ 0x7fffffffffffffffL\n#define __LP64__ 1\n#define __MMX__ 1\n#define __NO_INLINE__ 1\n#define __ORDER_BIG_ENDIAN__ 4321\n#define __ORDER_LITTLE_ENDIAN__ 1234\n#define __ORDER_PDP_ENDIAN__ 3412\n#define __PIC__ 2\n#define __PIE__ 2\n#define __PRAGMA_REDEFINE_EXTNAME 1\n#define __PTRDIFF_MAX__ 0x7fffffffffffffffL\n#define __PTRDIFF_TYPE__ long int\n#define __REGISTER_PREFIX__ \n#define __SCHAR_MAX__ 0x7f\n#define __SEG_FS 1\n#define __SEG_GS 1\n#define __SHRT_MAX__ 0x7fff\n#define __SIG_ATOMIC_MAX__ 0x7fffffff\n#define __SIG_ATOMIC_MIN__ (-__SIG_ATOMIC_MAX__ - 1)\n#define __SIG_ATOMIC_TYPE__ int\n#define __SIZEOF_DOUBLE__ 8\n#define __SIZEOF_FLOAT128__ 16\n#define __SIZEOF_FLOAT80__ 16\n#define __SIZEOF_FLOAT__ 4\n#define __SIZEOF_INT128__ 16\n#define __SIZEOF_INT__ 4\n#define __SIZEOF_LONG_DOUBLE__ 16\n#define __SIZEOF_LONG_LONG__ 8\n#define __SIZEOF_LONG__ 8\n#define __SIZEOF_POINTER__ 8\n#define __SIZEOF_PTRDIFF_T__ 8\n#define __SIZEOF_SHORT__ 2\n#define __SIZEOF_SIZE_T__ 8\n#define __SIZEOF_WCHAR_T__ 4\n#define __SIZEOF_WINT_T__ 4\n#define __SIZE_MAX__ 0xffffffffffffffffUL\n#define __SIZE_TYPE__ long unsigned int\n#define __SSE2_MATH__ 1\n#define __SSE2__ 1\n#define __SSE_MATH__ 1\n#define __SSE__ 1\n#define __SSP_STRONG__ 3\n#define __STDC_HOSTED__ 1\n#define __STDC_IEC_559_COMPLEX__ 1\n#define __STDC_IEC_559__ 1\n#define __STDC_ISO_10646__ 201605L\n#define __STDC_NO_THREADS__ 1\n#define __STDC_UTF_16__ 1\n#define __STDC_UTF_32__ 1\n#define __STDC_VERSION__ 201112L\n#define __STDC__ 1\n#define __UINT16_C(c) c\n#define __UINT16_MAX__ 0xffff\n#define __UINT16_TYPE__ short unsigned int\n#define __UINT32_C(c) c ## U\n#define __UINT32_MAX__ 0xffffffffU\n#define __UINT32_TYPE__ unsigned int\n#define __UINT64_C(c) c ## UL\n#define __UINT64_MAX__ 0xffffffffffffffffUL\n#define __UINT64_TYPE__ long unsigned int\n#define __UINT8_C(c) c\n#define __UINT8_MAX__ 0xff\n#define __UINT8_TYPE__ unsigned char\n#define __UINTMAX_C(c) c ## UL\n#define __UINTMAX_MAX__ 0xffffffffffffffffUL\n#define __UINTMAX_TYPE__ long unsigned int\n#define __UINTPTR_MAX__ 0xffffffffffffffffUL\n#define __UINTPTR_TYPE__ long unsigned int\n#define __UINT_FAST16_MAX__ 0xffffffffffffffffUL\n#define __UINT_FAST16_TYPE__ long unsigned int\n#define __UINT_FAST32_MAX__ 0xffffffffffffffffUL\n#define __UINT_FAST32_TYPE__ long unsigned int\n#define __UINT_FAST64_MAX__ 0xffffffffffffffffUL\n#define __UINT_FAST64_TYPE__ long unsigned int\n#define __UINT_FAST8_MAX__ 0xff\n#define __UINT_FAST8_TYPE__ unsigned char\n#define __UINT_LEAST16_MAX__ 0xffff\n#define __UINT_LEAST16_TYPE__ short unsigned int\n#define __UINT_LEAST32_MAX__ 0xffffffffU\n#define __UINT_LEAST32_TYPE__ unsigned int\n#define __UINT_LEAST64_MAX__ 0xffffffffffffffffUL\n#define __UINT_LEAST64_TYPE__ long unsigned int\n#define __UINT_LEAST8_MAX__ 0xff\n#define __UINT_LEAST8_TYPE__ unsigned char\n#define __USER_LABEL_PREFIX__ \n#define __VERSION__ \"6.3.0 20170406\"\n#define __WCHAR_MAX__ 0x7fffffff\n#define __WCHAR_MIN__ (-__WCHAR_MAX__ - 1)\n#define __WCHAR_TYPE__ int\n#define __WINT_MAX__ 0xffffffffU\n#define __WINT_MIN__ 0U\n#define __WINT_TYPE__ unsigned int\n#define __amd64 1\n#define __amd64__ 1\n#define __code_model_small__ 1\n#define __gnu_linux__ 1\n#define __has_include(STR) __has_include__(STR)\n#define __has_include_next(STR) __has_include_next__(STR)\n#define __k8 1\n#define __k8__ 1\n#define __linux 1\n#define __linux__ 1\n#define __pic__ 2\n#define __pie__ 2\n#define __unix 1\n#define __unix__ 1\n#define __x86_64 1\n#define __x86_64__ 1\n#define linux 1\n#define unix 1\n"
        ]
    },
    {
        "question_id": 1410563,
        "question_code": "",
        "answer_code_snippets": [
            "extern int bar;\nextern int g(int, int);\ndouble f(int, double); // extern can be omitted for function declarations\nclass foo; // no extern allowed for type declarations\n\nint bar;\nint g(int lhs, int rhs) {return lhs*rhs;}\ndouble f(int i, double d) {return i+d;}\nclass foo {};\n\ndouble f(int, double);\ndouble f(int, double);\nextern double f(int, double); // the same as the two above\nextern double f(int, double);\n\nstruct x;\nstruct x {};",
            "void sqrt(double);  // declares sqrt\n\nstruct X\n{\n    int a;         // defines a\n    static int b;  // declares b\n};\n\nclass Y;\n\nextern\nextern const int i = 0;  // defines i\nextern int j;  // declares j\nextern \"C\"\n{\n    void foo();  // declares foo\n}\n\ntypedef\nusing\ntypedef long LONG_32;  // declares LONG_32\nusing namespace std;   // declares std\n",
            "T t;\n\nT\ntypedef void T();\nT t; // declaration of function \"t\"\n\nstruct X { \n  T t; // declaration of function \"t\".\n};\n\ntypedef int T;\nT t; // definition of object \"t\".\n\ntemplate &lt;typename T&gt;\nstruct X { \n  static int member; // declaration\n};\n\ntemplate&lt;typename T&gt;\nint X&lt;T&gt;::member; // definition\n\ntemplate&lt;&gt;\nint X&lt;bool&gt;::member; // declaration!\n\nX&lt;bool&gt;\nX&lt;bool&gt;::member\ntemplate&lt;&gt;\nint X&lt;bool&gt;::member = 1; // definition, belongs into a .cpp file.\n",
            "typedef int myint;",
            "extern int a; \nstruct _tagExample { int a; int b; }; \nint myFunc (int a, int b);\n\nint a; \nint b = 0; \nint myFunc (int a, int b) { return a + b; } \nstruct _tagExample example; \n",
            "enum X : int;\ntemplate&lt;typename T&gt; class MyArray;\nint add(int x, int y);\nusing IntVector = std::vector&lt;int&gt;;\nstatic_assert(sizeof(int) == 4, &quot;Yikes!&quot;)\n;\nint add(int x, int y);\nextern int a;\nextern &quot;C&quot; { ... };\nclass C { static int x; };\nstruct Point;\ntypedef int Int;\nusing std::cout;\nusing namespace NS;\n// except one all these are definitions\nint a;                                  // defines a\nextern const int c = 1;                 // defines c\nint f(int x) { return x + a; }          // defines f and defines x\nstruct S { int a; int b; };             // defines S, S::a, and S::b\nstruct X {                              // defines X\n    int x;                              // defines non-static data member x\n    static int y;                       // DECLARES static data member y\n    X(): x(0) { }                       // defines a constructor of X\n};\nint X::y = 1;                           // defines X::y\nenum { up , down };                     // defines up and down\nnamespace N { int d; }                  // defines N and N::d\nnamespace N1 = N;                       // defines N1\nX anX;                                  // defines anX\n\n\n// all these are declarations\nextern int a;                           // declares a\nextern const int c;                     // declares c\nint f(int);                             // declares f\nstruct S;                               // declares S\ntypedef int Int;                        // declares Int\nextern X anotherX;                      // declares anotherX\nusing N::d;                             // declares N::d\n\n\n// specific to C++11 - these are not from the standard\nenum X : int;                           // declares X with int as the underlying type\nusing IntVector = std::vector&lt;int&gt;;     // declares IntVector as an alias to std::vector&lt;int&gt;\nstatic_assert(X::y == 1, &quot;Oops!&quot;);      // declares a static_assert which can render the program ill-formed or have no effect like an empty declaration, depending on the result of expr\ntemplate &lt;class T&gt; class C;             // declares template class C\n;                                       // declares nothing\n",
            "extern int a;      // Declaration \nint a;             // Definition\na = 10             // Initialization\nint b = 10;        // Definition &amp; Initialization\n\nint a;\nfloat b;\ndouble c;\n\nint fun(int a,int b); \n\nint b=fun(x,y,z);\n\n#include &lt;stdio.h&gt;\nvoid print(int a)\n{\n     printf(\"%d\",a);\n}\nmain()\n{\n    print(5);\n}\n\n #include &lt;stdio.h&gt;\n void print(int a); // In this case this is essential\n main()\n {\n    print(5);\n }\n void print(int a)\n {\n     printf(\"%d\",a);\n }\n\nvoid print(int a)\n{\n    printf(\"%d\",a);\n}\n",
            "// declaration\nint sum(int, int);\n\nsum\nint\nint\n// definition\nint sum(int x, int y)\n{\n    return x + y;\n}\n",
            "void  myfunction(); //this is simple declaration\n\nvoid myfunction()\n{\n some statement;    \n}\n",
            "int sampleFunc(); // function\nextern int car;  // variable\n\nint sampleFunc() {} // function\nint car; // variable\n\nint car = 0; // variable\n",
            "int f(int x); // function declaration (I know f exists)\n\nint f(int x) { return 2*x; } // declaration and definition\n",
            "uint8_t   ui8 = 5;  |   movb    $0x5,-0x45(%rbp)\nint         i = 5;  |   movl    $0x5,-0x3c(%rbp)\nuint32_t ui32 = 5;  |   movl    $0x5,-0x38(%rbp)\nuint64_t ui64 = 5;  |   movq    $0x5,-0x10(%rbp)\ndouble   doub = 5;  |   movsd   0x328(%rip),%xmm0        # 0x400a20\n                        movsd   %xmm0,-0x8(%rbp)\n\nui8 = 5;   |   movb    $0x5,-0x45(%rbp)\ni = 5;     |   movl    $0x5,-0x3c(%rbp)\nui32 = 5;  |   movl    $0x5,-0x38(%rbp)\nui64 = 5;  |   movq    $0x5,-0x10(%rbp)\ndoub = 5;  |   movsd   0x328(%rip),%xmm0        # 0x400a20\n               movsd   %xmm0,-0x8(%rbp)\n\nuint def;                  |  no instructions\nprintf(\"some stuff...\");   |  [...] callq   0x400450 &lt;printf@plt&gt;\ndef=5;                     |  movb    $0x5,-0x45(%rbp)\n",
            "int a;                       // defines a\nextern const int c = 1;      // defines c\nint f(int x) { return x+a; } // defines f and defines x\nstruct S { int a; int b; };  // defines S, S::a, and S::b\nstruct X {                   // defines X\n    int x;                   // defines non-static data member x\n    static int y;            // DECLARES static data member y\n    X(): x(0) { }            // defines a constructor of X\n};\nint X::y = 1;                // defines X::y\nenum { up, down };           // defines up and down\nnamespace N { int d; }       // defines N and N::d\nnamespace N1 = N;            // defines N1\nX anX;                       // defines anX\n\nextern int a;                 // declares a\nextern const int c;           // declares c\nint f(int);                   // declares f\nstruct S;                     // declares S\ntypedef int Int;              // declares Int\nextern X anotherX;            // declares anotherX\nusing N::d;                   // declares d\n",
            "int sp;\ndouble val[MAXVAL]\n\nsp\nval\nextern int sp;\nextern double val[];\n\nsp\nint\nval\ndouble\nextern",
            "int i;\n\nint max(int, int);\n\ni = 20;\n\nint max(int a, int b)\n{\n   if(a&gt;b)   return a;\n   return b;  \n}\n\nint i=20;\n\nint max(int a, int b)\n{\n    if(a&gt;b)   return a;\n    return b;    \n} \n\ni\nfunction max()"
        ]
    },
    {
        "question_id": 1675351,
        "question_code": "typedef\ntypedef\nstruct myStruct{\n    int one;\n    int two;\n};\n\ntypedef struct{\n    int one;\n    int two;\n}myStruct;\n",
        "answer_code_snippets": [
            "typedef struct S { \n    int x; \n} S;\n\nstruct S { \n    int x; \n};\n\ntypedef struct S S;\n\nS\nstruct S\nvoid f( struct S argument ); // struct is required here\n\nS\nvoid f( S argument ); // struct keyword no longer needed\n\nS\ntypedef struct S { \n    int x; \n} T;\n\nvoid S() { } // correct\n\n//void T() {} // error: symbol T already defined as an alias to 'struct S'\n\ntypedef\n // C++\nstruct S { \n    int x; \n}; // S defined as a class\n\nvoid f( S a ); // correct: struct is optional\n\nS\nS\ntypedef struct S { \n    int x; \n} T;\n\nvoid S() {} // correct [*]\n\n//void T() {} // error: symbol T already defined as an alias to 'struct S'\n\nS\nS\nstruct\n// previous code here...\nint main() {\n    S(); \n    struct S s;\n}\n",
            "struct\ntypedef\nstruct\nstruct foo {\n    int n;\n};\n\nstruct foo\nfoo\nstruct\nnamespace\ntypedef\ntypedef int my_int;\n\nmy_int\nint\nmy_int\nint\nstruct\ntypedef struct foo foo;\n\nstruct foo\ntypedef\nfoo\nstruct\ntypedef\ntypedef struct bar {\n    int n;\n} bar;\n\nstruct bar\nbar\nstruct\ntypedef struct node {\n    int data;\n    struct node *next; /* can't use just &quot;node *next&quot; here */\n} node;\n\ntypedef struct node_s {\n    /* ... */\n} node;\n\ntypedef\nstruct bar\ntypedef\nn\nstruct blah\nblah",
            "struct myStruct;\nvoid doit(struct myStruct *ptr);\n\ntypedef struct myStruct{\n    int one;\n    int two;\n} myStruct;\n",
            "struct myStruct myVariable;\n\nmyStruct myVariable;\ntypedef\ntypedef struct myStruct someStruct;\nsomeStruct myVariable;\n\nstruct\ntypedef\nstruct\ntypedef\ntypedef struct { ... } myStruct;\n",
            "struct\ntypedef\nstruct mystruct myvar;\n\nmystruct myvar;\n\ntypedef\nstruct",
            "struct\nunion\nenum\ntypedef\ntypedef",
            "typedef struct\nstruct\ntypedef struct{\n    int one;\n    int two;\n} myStruct;\n\nstruct myStruct; //forward declaration fails\n\nvoid blah(myStruct* pStruct);\n\n//error C2371: 'myStruct' : redefinition; different basic types\n",
            "myStruct\ntypedef struct{\n    int one;\n    int two;\n} myStruct;\n",
            "typedef\nstruct myStruct blah;\n\nmyStruct blah;\n",
            "struct\nstruct myStruct aName;\n\nstruct\nmyStruct aName;\n",
            "struct myStruct\n   {\n   int field_1;\n   ...\n   };\n\ntypedef struct\n   {\n   field_1;\n   ...\n   }myStruct;\n\ntypedef struct\n   {\n   field_1;\n   ...\n   }myStruct,*myStructP;\n\ntypedef struct myStructElement\n   {\n   myStructElement*  nextSE;\n   field_1;\n   ...\n   }myStruct;\n",
            "myStruct a;\n\nstruct myStruct a;\n"
        ]
    },
    {
        "question_id": 98650,
        "question_code": "",
        "answer_code_snippets": [
            "uint32_t\nuint16_t\ntypedef struct Msg\n{\n    unsigned int a;\n    unsigned int b;\n} Msg;\n\nvoid SendWord(uint32_t);\n\nint main(void)\n{\n    // Get a 32-bit buffer from the system\n    uint32_t* buff = malloc(sizeof(Msg));\n    \n    // Alias that buffer through message\n    Msg* msg = (Msg*)(buff);\n    \n    // Send a bunch of messages    \n    for (int i = 0; i &lt; 10; ++i)\n    {\n        msg-&gt;a = i;\n        msg-&gt;b = i+1;\n        SendWord(buff[0]);\n        SendWord(buff[1]);   \n    }\n}\n\nbuff\nbuff[0]\nbuff[1]\nbuff\nvoid SendMessage(uint32_t* buff, size_t size32)\n{\n    for (int i = 0; i &lt; size32; ++i) \n    {\n        SendWord(buff[i]);\n    }\n}\n\nfor (int i = 0; i &lt; 10; ++i)\n{\n    msg-&gt;a = i;\n    msg-&gt;b = i+1;\n    SendMessage(buff, 2);\n}\n\nSendMessage\n  union {\n      Msg msg;\n      unsigned int asBuffer[sizeof(Msg)/sizeof(unsigned int)];\n  };\n\nchar*\nchar*\nsigned char\nunsigned char\nchar*",
            "int*\nint\nfloat*\nfloat\nchar*",
            "int x = 10;\nint *ip = &amp;x;\n\nstd::cout &lt;&lt; *ip &lt;&lt; &quot;\\n&quot;;\n*ip = 12;\nstd::cout &lt;&lt; x &lt;&lt; &quot;\\n&quot;;\n\nint foo( float *f, int *i ) { \n    *i = 1;\n    *f = 0.f;\n    \n    return *i;\n}\n\nint main() {\n    int x = 0;\n    \n    std::cout &lt;&lt; x &lt;&lt; &quot;\\n&quot;;   // Expect 0\n    x = foo(reinterpret_cast&lt;float*&gt;(&amp;x), &amp;x);\n    std::cout &lt;&lt; x &lt;&lt; &quot;\\n&quot;;   // Expect 0?\n}\n\n0\n1\n\nfoo(float*, int*): # @foo(float*, int*)\nmov dword ptr [rsi], 1\nmov dword ptr [rdi], 0\nmov eax, 1\nret\n\nint x = 1;\nint *p = &amp;x;\nprintf(&quot;%d\\n&quot;, *p); // *p gives us an lvalue expression of type int which is compatible with int\n\nint x = 1;\nconst int *p = &amp;x;\nprintf(&quot;%d\\n&quot;, *p); // *p gives us an lvalue expression of type const int which is compatible with int\n\nint x = 1;\nunsigned int *p = (unsigned int*)&amp;x;\nprintf(&quot;%u\\n&quot;, *p ); // *p gives us an lvalue expression of type unsigned int which corresponds to \n                     // the effective type of the object\n\nint x = 1;\nconst unsigned int *p = (const unsigned int*)&amp;x;\nprintf(&quot;%u\\n&quot;, *p ); // *p gives us an lvalue expression of type const unsigned int which is a unsigned type \n                     // that corresponds with to a qualified version of the effective type of the object\n\nstruct foo {\n    int x;\n};\n    \nvoid foobar( struct foo *fp, int *ip );  // struct foo is an aggregate that includes int among its members so it\n                                         // can alias with *ip\n\nfoo f;\nfoobar( &amp;f, &amp;f.x );\n\nint x = 65;\nchar *p = (char *)&amp;x;\nprintf(&quot;%c\\n&quot;, *p );  // *p gives us an lvalue expression of type char which is a character type.\n                      // The results are not portable due to endianness issues.\n\nvoid *p = malloc( sizeof(int) ); // We have allocated storage but not started the lifetime of an object\nint *ip = new (p) int{0};        // Placement new changes the dynamic type of the object to int\nstd::cout &lt;&lt; *ip &lt;&lt; &quot;\\n&quot;;        // *ip gives us a glvalue expression of type int which matches the dynamic type \n                                 // of the allocated object\n\nint x = 1;\nconst int *cip = &amp;x;\nstd::cout &lt;&lt; *cip &lt;&lt; &quot;\\n&quot;;  // *cip gives us a glvalue expression of type const int which is a cv-qualified \n                            // version of the dynamic type of x\n\n// Both si and ui are signed or unsigned types corresponding to each others dynamic types\n// We can see from this godbolt(https://godbolt.org/g/KowGXB) the optimizer assumes aliasing.\nsigned int foo( signed int &amp;si, unsigned int &amp;ui ) {\n    si = 1;\n    ui = 2;\n\n    return si;\n}\n\nsigned int foo( const signed int &amp;si1, int &amp;si2); // Hard to show this one assumes aliasing\n\nstruct foo {\n    int x;\n};\n\n// Compiler Explorer example(https://godbolt.org/g/z2wJTC) shows aliasing assumption\nint foobar( foo &amp;fp, int &amp;ip ) {\n    fp.x = 1;\n    ip = 2;\n\n    return fp.x;\n}\n\nfoo f;\nfoobar( f, f.x );\n\nstruct foo { int x; };\n\nstruct bar : public foo {};\n\nint foobar( foo &amp;f, bar &amp;b ) {\n    f.x = 1;\n    b.x = 2;\n\n    return f.x;\n}\n\nint foo( std::byte &amp;b, uint32_t &amp;ui ) {\n    b = static_cast&lt;std::byte&gt;('a');\n    ui = 0xFFFFFFFF;\n  \n    return std::to_integer&lt;int&gt;( b );  // b gives us a glvalue expression of type std::byte which can alias\n                                       // an object of type uint32_t\n}\n\nint x = 1;\n\n// In C\nfloat *fp = (float*)&amp;x;  // Not a valid aliasing\n\n// In C++\nfloat *fp = reinterpret_cast&lt;float*&gt;(&amp;x);  // Not a valid aliasing\n\nprintf( &quot;%f\\n&quot;, *fp );\n\nunion u1\n{\n    int n;\n    float f;\n};\n\nunion u1 u;\nu.f = 1.0f;\n\nprintf( &quot;%d\\n&quot;, u.n );  // UB in C++ n is not the active member\n\nstatic_assert( sizeof( double ) == sizeof( int64_t ) );  // C++17 does not require a message\n\nvoid func1( double d ) {\n    std::int64_t n;\n    std::memcpy(&amp;n, &amp;d, sizeof d);\n    //...\n\nstd::cout &lt;&lt; bit_cast&lt;float&gt;(0x447a0000) &lt;&lt; &quot;\\n&quot;; //assuming sizeof(float) == sizeof(unsigned int)\n\nstruct uint_chars {\n    unsigned char arr[sizeof( unsigned int )] = {};  // Assume sizeof( unsigned int ) == 4\n};\n\n// Assume len is a multiple of 4 \nint bar( unsigned char *p, size_t len ) {\n    int result = 0;\n\n    for( size_t index = 0; index &lt; len; index += sizeof(unsigned int) ) {\n        uint_chars f;\n        std::memcpy( f.arr, &amp;p[index], sizeof(unsigned int));\n        unsigned int result = bit_cast&lt;unsigned int&gt;(f);\n\n        result += foo( result );\n    }\n\n    return result;\n}\n\nint a = 1;\nshort j;\nfloat f = 1.f; // Originally not initialized but tis-kernel caught \n               // it was being accessed w/ an indeterminate value below\n\nprintf(&quot;%i\\n&quot;, j = *(reinterpret_cast&lt;short*&gt;(&amp;a)));\nprintf(&quot;%i\\n&quot;, j = *(reinterpret_cast&lt;int*&gt;(&amp;f)));\n\nint *p;\n\np = &amp;a;\nprintf(&quot;%i\\n&quot;, j = *(reinterpret_cast&lt;short*&gt;(p)));\n\nint *x = new int[2];               // 8 bytes: [0,7].\nint *u = (int*)((char*)x + 6);     // regardless of alignment of x this will not be an aligned address\n*u = 1;                            // Access to range [6-9]\nprintf( &quot;%d\\n&quot;, *u );              // Access to range [6-9]\n\nint a = 1;\nshort j;\nfloat f = 1.0;\n\nprintf(&quot;%i\\n&quot;, j = *((short*)&amp;a));\nprintf(&quot;%i\\n&quot;, j = *((int*)&amp;f));\n    \nint *p;\n\np = &amp;a;\nprintf(&quot;%i\\n&quot;, j = *((short*)p));\n\n./bin/tis-kernel -sa example1.c \n...\nexample1.c:9:[sa] warning: The pointer (short *)(&amp; a) has type short *. It violates strict aliasing\n              rules by accessing a cell with effective type int.\n...\n\nexample1.c:10:[sa] warning: The pointer (int *)(&amp; f) has type int *. It violates strict aliasing rules by\n              accessing a cell with effective type float.\n              Callstack: main\n...\n\nexample1.c:15:[sa] warning: The pointer (short *)p has type short *. It violates strict aliasing rules by\n              accessing a cell with effective type int.\n",
            "char\nunsigned char\nchar\nunsigned char",
            "#include &lt;stdio.h&gt;\n\nvoid check(short *h,long *k)\n{\n    *h=5;\n    *k=6;\n    if (*h == 5)\n        printf(\"strict aliasing problem\\n\");\n}\n\nint main(void)\n{\n    long      k[1];\n    check((short *)k,k);\n    return 0;\n}\n\ngcc -O2 -o check check.c\nif (*h == 5)\nmovw    $5, (%rdi)\nmovq    $6, (%rsi)\nmovl    $.LC0, %edi\njmp puts\n",
            "int x;\nint test(double *p)\n{\n  x=5;\n  *p = 1.0;\n  return x;\n}\n\nx\np\nx\n*p\nx\nvoid test(void)\n{\n  struct S {int x;} s;\n  s.x = 1;\n}\n\nint\nstruct S\nint\nstruct S\nint test(int *ip, double *dp)\n{\n  *ip = 1;\n  *dp = 1.23;\n  return *ip;\n}\nint test2(void)\n{\n  union U { int i; double d; } u;\n  return test(&amp;u.i, &amp;u.d);\n}\n\n void inc_int(int *p) { *p = 3; }\n int test(void)\n {\n   int *p;\n   struct S { int x; } s;\n   s.x = 1;\n   p = &amp;s.x;\n   inc_int(p);\n   return s.x;\n }\n\ninc_int\n*p\nint\ntest\np\nstruct S\ns\np\n void inc_int(int *p) { *p = 3; }\n int test(void)\n {\n   int *p;\n   struct S { int x; } s;\n   p = &amp;s.x;\n   s.x = 1;  //  !!*!!\n   *p += 1;\n   return s.x;\n }\n\np\ns.x",
            "restrict\nint *\nfloat *\nvoid merge_two_ints(int *a, int *b) {\n  *b += *a;\n  *a += *b;\n}\n\na == b\na\nb\na\nb\nb\na\nb\na\na\na\nb\nvoid merge_two_numbers(int *a, long *b) {...}\n\nrestrict\nvoid merge_two_ints(int * restrict a, int * restrict b) {...}\n\nrestrict\na\nb\na\nb\na\nb\na\nb"
        ]
    },
    {
        "question_id": 15393441,
        "question_code": "main(_){_^448&amp;&amp;main(-~_);putchar(--_%64?32|-~7[__TIME__-_/8%8][\"&gt;'txiZ^(~z?\"-48]&gt;&gt;\";;;====~$::199\"[_*2&amp;8|_/64]/(_&amp;2?1:8)%8&amp;1:10);}\n\ngcc 4.6.3\n    !!  !!!!!!              !!  !!!!!!              !!  !!!!!! \n    !!  !!  !!              !!      !!              !!  !!  !! \n    !!  !!  !!              !!      !!              !!  !!  !! \n    !!  !!!!!!    !!        !!      !!    !!        !!  !!!!!! \n    !!      !!              !!      !!              !!  !!  !! \n    !!      !!              !!      !!              !!  !!  !! \n    !!  !!!!!!              !!      !!              !!  !!!!!!\n\n-Wall\nsykes2.c:1:1: warning: return type defaults to ‘int’ [-Wreturn-type]\nsykes2.c: In function ‘main’:\nsykes2.c:1:14: warning: value computed is not used [-Wunused-value]\nsykes2.c:1:1: warning: implicit declaration of function ‘putchar’ [-Wimplicit-function-declaration]\nsykes2.c:1:1: warning: suggest parentheses around arithmetic in operand of ‘|’ [-Wparentheses]\nsykes2.c:1:1: warning: suggest parentheses around arithmetic in operand of ‘|’ [-Wparentheses]\nsykes2.c:1:1: warning: control reaches end of non-void function [-Wreturn-type]\n",
        "answer_code_snippets": [
            "main(_) {\n    _^448 &amp;&amp; main(-~_);\n    putchar(--_%64\n        ? 32 | -~7[__TIME__-_/8%8][\"&gt;'txiZ^(~z?\"-48] &gt;&gt; \";;;====~$::199\"[_*2&amp;8|_/64]/(_&amp;2?1:8)%8&amp;1\n        : 10);\n}\n\nmain(int i) {\n    if(i^448)\n        main(-~i);\n    if(--i % 64) {\n        char a = -~7[__TIME__-i/8%8][\"&gt;'txiZ^(~z?\"-48];\n        char b = a &gt;&gt; \";;;====~$::199\"[i*2&amp;8|i/64]/(i&amp;2?1:8)%8;\n        putchar(32 | (b &amp; 1));\n    } else {\n        putchar(10); // newline\n    }\n}\n\n-~i == i+1\nmain(int i) {\n    if(i != 448)\n        main(i+1);\n    i--;\n    if(i % 64 == 0) {\n        putchar('\\n');\n    } else {\n        char a = -~7[__TIME__-i/8%8][\"&gt;'txiZ^(~z?\"-48];\n        char b = a &gt;&gt; \";;;====~$::199\"[i*2&amp;8|i/64]/(i&amp;2?1:8)%8;\n        putchar(32 | (b &amp; 1));\n    }\n}\n\na[b]\nb[a]\n-~ == 1+\nmain(int i) {\n    if(i != 448)\n        main(i+1);\n    i--;\n    if(i % 64 == 0) {\n        putchar('\\n');\n    } else {\n        char a = (\"&gt;'txiZ^(~z?\"-48)[(__TIME__-i/8%8)[7]] + 1;\n        char b = a &gt;&gt; \";;;====~$::199\"[(i*2&amp;8)|i/64]/(i&amp;2?1:8)%8;\n        putchar(32 | (b &amp; 1));\n    }\n}\n\n// please don't pass any command-line arguments\nmain() {\n    int i;\n    for(i=447; i&gt;=0; i--) {\n        if(i % 64 == 0) {\n            putchar('\\n');\n        } else {\n            char t = __TIME__[7 - i/8%8];\n            char a = \"&gt;'txiZ^(~z?\"[t - 48] + 1;\n            int shift = \";;;====~$::199\"[(i*2&amp;8) | (i/64)];\n            if((i &amp; 2) == 0)\n                shift /= 8;\n            shift = shift % 8;\n            char b = a &gt;&gt; shift;\n            putchar(32 | (b &amp; 1));\n        }\n    }\n}\n\n!\n\"&gt;'txiZ^(~z?\"\n\";;;====~$::199\"\nint shift = \";;;====~$::199\"[(i*2&amp;8) | (i/64)];\ni/64\ni*2&amp;8\ni\nif((i &amp; 2) == 0) shift /= 8; shift = shift % 8\ni%8\ni%8\nrow col val\n6   6-7 0\n6   4-5 0\n6   2-3 5\n6   0-1 7\n5   6-7 1\n5   4-5 7\n5   2-3 5\n5   0-1 7\n4   6-7 1\n4   4-5 7\n4   2-3 5\n4   0-1 7\n3   6-7 1\n3   4-5 6\n3   2-3 5\n3   0-1 7\n2   6-7 2\n2   4-5 7\n2   2-3 3\n2   0-1 7\n1   6-7 2\n1   4-5 7\n1   2-3 3\n1   0-1 7\n0   6-7 4\n0   4-5 4\n0   2-3 3\n0   0-1 7\n\n00005577\n11775577\n11775577\n11665577\n22773377\n22773377\n44443377\n\n7\n__TIME__\n\"HH:MM:SS\"\n:\n__TIME__\n7 - i/8%8\n__TIME__\n7-\ni\nt\n__TIME__\na\nt\n0 00111111\n1 00101000\n2 01110101\n3 01111001\n4 01101010\n5 01011011\n6 01011111\n7 00101001\n8 01111111\n9 01111011\n: 01000000\n\n7\n7\n000055  \n11  55  \n11  55  \n116655  \n22  33  \n22  33  \n444433  \n\n4\n01101010\n----!!--\n!!--!!--\n!!--!!--\n!!!!!!--\n----!!--\n----!!--\n----!!--\n\n  00  \n11  55\n11  55\n  66  \n22  33\n22  33\n  44\n\n\"?;;?==? '::799\\x07\"\n\"?{{?}}?gg::799G\"\nmain(_){_^448&amp;&amp;main(-~_);putchar(--_%64?32|-~7[__TIME__-_/8%8][\"&gt;'txiZ^(~z?\"-48]&gt;&gt;\"?{{?}}?gg::799G\"[_*2&amp;8|_/64]/(_&amp;2?1:8)%8&amp;1:10);}\n\n          !!              !!                              !!   \n    !!  !!              !!  !!  !!  !!              !!  !!  !! \n    !!  !!              !!  !!  !!  !!              !!  !!  !! \n          !!      !!              !!      !!                   \n    !!  !!  !!          !!  !!      !!              !!  !!  !! \n    !!  !!  !!          !!  !!      !!              !!  !!  !! \n          !!              !!                              !!   \n",
            "main(_){\n  _^448&amp;&amp;main(-~_);\n  putchar((--_%64) ? (32|-(~7[__TIME__-_/8%8])[\"&gt;'txiZ^(~z?\"-48]&gt;&gt;(\";;;====~$::199\")[_*2&amp;8|_/64]/(_&amp;2?1:8)%8&amp;1):10);\n}\n\n1\nmain()\n-(~_)\n_\n_^448 == 0\n448/64 == 7\nmain(int argc) {\n  if (argc^448) main(-(~argc));\n  if (argc % 64) {\n    putchar((32|-(~7[__TIME__-argc/8%8])[\"&gt;'txiZ^(~z?\"-48]&gt;&gt;(\";;;====~$::199\")[argc*2&amp;8|argc/64]/(argc&amp;2?1:8)%8&amp;1));\n  } else putchar('\\n');\n}\n\n32\n&amp;1\n-(~(7[__TIME__-argc/8%8][\"&gt;'txiZ^(~z?\"-48]) &gt;&gt;\n     (\";;;====~$::199\"[argc*2&amp;8|argc/64]) / (argc&amp;2?1:8) % 8\n\n__TIME__\n7[__TIME__ - (argc/8)%8]\n\n__TIME__\n[\"&gt;'txiZ^(~z?\"-48]",
            "-~x\nx+1\n~x\n(0xffffffff-x)\n(-1-x)\n-~x\n-(-1-x) = x+1",
            "int pixelX, line, digit ;\nfor(line=6; line &gt;= 0; line--){\n  for (digit =0; digit&lt;8; digit++){\n    for(pixelX=7;pixelX &gt; 0; pixelX--){ \n        putchar(' '| 1 + \"&gt;'txiZ^(~z?\"[\"12:34:56\"[digit]-'0'] &gt;&gt; \n          (\";;;====~$::199\"[pixel*2 &amp; 8  | line] / (pixelX&amp;2 ? 1 : 8) ) % 8 &amp; 1);               \n    }\n  }\n  putchar('\\n');\n}\n\nint pixelX, line, digit, shift;\nchar shiftChar;\nfor(line=6; line &gt;= 0; line--){\n    for (digit =0; digit&lt;8; digit++){\n        for(pixelX=7;pixelX &gt;= 0; pixelX--){ \n            shiftChar = \";;;====~$::199\"[pixelX*2 &amp; 8 | line];\n            if (pixelX &amp; 2)\n                shift = shiftChar &amp; 7;\n            else\n                shift = shiftChar &gt;&gt; 3;     \n            putchar(' '| (\"&gt;'txiZ^(~z?\"[\"12:34:56\"[digit]-'0'] + 1) &gt;&gt; shift &amp; 1 );\n        }\n\n    }\n    putchar('\\n');\n}\n"
        ]
    },
    {
        "question_id": 1538420,
        "question_code": "ptr = malloc(MAXELEMS * sizeof(char *));\n\nptr = calloc(MAXELEMS, sizeof(char*));\n\ncalloc\nmalloc",
        "answer_code_snippets": [
            "calloc()\nmalloc()\ncalloc\nmmap(MAP_ANONYMOUS)\nVirtualAlloc\nmalloc\ncalloc\ncalloc\nmalloc\ncalloc\ncalloc\nmmap(MAP_UNINITIALIZED|MAP_ANONYMOUS)",
            "malloc\ncalloc",
            "calloc\nsize_t count = get_int32(file);\nstruct foo *bar = malloc(count * sizeof *bar);\n\nsize_t count = get_int32(file);\nstruct foo *bar = calloc(count, sizeof *bar);\n\ncount\nSIZE_MAX/sizeof *bar",
            "calloc\nmalloc\ncalloc\ncalloc",
            "calloc\ncalloc\n0\n0\n0.0\ncalloc\nmemset(..., 0, ...)\nunsigned char\nunsigned char\ncalloc\nmemset(..., 0, ...)\ncalloc\nmalloc\ncalloc\ncalloc\nmalloc",
            "malloc()\ncalloc()\nmalloc()\ncalloc()\nmalloc()\ncalloc()\nmalloc()\ncalloc()\nvoid *malloc(size_t bytes);         \nvoid *calloc(size_t length, size_t bytes);      \n\nmalloc\ncalloc\nmalloc\ncalloc",
            "calloc\nmalloc+memset\nmalloc+memset\nptr=malloc(sizeof(Item));\nmemset(ptr, 0, sizeof(Item));\n\nsizeof(Item)\nmemset\ncalloc\ncalloc\nmemset\nsizeof(long)\naligned_memset",
            "malloc()\ncalloc()\nmalloc()\ncalloc()\ncalloc()\ncalloc\nNULL\nptr_var = calloc(no_of_blocks, size_of_each_block); \nptr_var = calloc(n, s);\nmalloc()\nptr_var = malloc(Size_in_bytes);\nmalloc()\ncalloc()\ncalloc()\nmalloc()",
            "malloc()\ncalloc()\nmalloc()\ndata_type ptr = (cast_type *)malloc( sizeof(data_type)*no_of_blocks );\n\nint *ptr = (int *) malloc(sizeof(int) * 10 );\n\ncalloc()\ndata_type ptr = (cast_type *)calloc(no_of_blocks, (sizeof(data_type)));\n\nint *ptr = (int *) calloc(10, (sizeof(int)));\n\nmalloc()\ncalloc()",
            "calloc()\n&lt;stdlib.h&gt;\nmalloc()",
            "malloc()\ncalloc()\nvoid *malloc( size_t n);\nvoid *calloc( size_t n, size_t t)\n\nmalloc()\ncalloc()\nmalloc()\ncalloc()\nint *arr;\n\n// allocate memory for 10 integers with garbage values\narr = (int *)malloc(10 * sizeof(int)); \n\n// allocate memory for 10 integers and sets all of them to 0\narr = (int *)calloc(10, sizeof(int));\n\ncalloc()\nmalloc()\nmemset()\n// allocate memory for 10 integers with garbage values   \narr= (int *)malloc(10 * sizeof(int));\n// set all of them to 0\nmemset(arr, 0, 10 * sizeof(int)); \n\nmalloc()\ncalloc()\ncalloc()",
            "void *malloc(size_t size)\nSIZE_MAX\nvoid *calloc(size_t nmemb, size_t size);\nSIZE_MAX*SIZE_MAX\ncalloc()\nnmemb * size &lt;= SIZE_MAX\ndisk_sector\nSIZE_MAX/sizeof disk_sector\nsize_t count = SIZE_MAX/sizeof disk_sector;\ndisk_sector *p = malloc(count * sizeof *p);\n\nsize_t count = something_in_the_range(SIZE_MAX/sizeof disk_sector + 1, SIZE_MAX)\ndisk_sector *p = calloc(count, sizeof *p);\n\nSIZE_MAX\nSIZE_MAX == 4294967295",
            "malloc\ncalloc\ncalloc\nmalloc\nmemset"
        ]
    },
    {
        "question_id": 65820,
        "question_code": "",
        "answer_code_snippets": [
            "#include \"myimplementationfile.c\"\n#include &lt;gtest/gtest.h&gt;\n\n// Mock out external dependency on mylogger.o\nvoid Logger_log(...){}\n\nTEST(FactorialTest, Zero) {\n    EXPECT_EQ(1, Factorial(0));\n}\n",
            "#include &lt;unity.h&gt;\n\nvoid test_true_should_be_true(void)\n{\n    TEST_ASSERT_TRUE(true);\n}\n\nint main(void)\n{\n    UNITY_BEGIN();\n    RUN_TEST(test_true_should_be_true);\n    return UNITY_END();\n}\n",
            "#include &lt;tap.h&gt;\n\nint main () {\n    plan(5);\n\n    ok(3 == 3);\n    is(\"fnord\", \"eek\", \"two different strings not that way?\");\n    ok(3 &lt;= 8732, \"%d &lt;= %d\", 3, 8732);\n    like(\"fnord\", \"f(yes|no)r*[a-f]$\");\n    cmp_ok(3, \"&gt;=\", 10);\n\n    done_testing();\n}\n",
            "#include &lt;stdarg.h&gt;\n#include &lt;stddef.h&gt;\n#include &lt;setjmp.h&gt;\n#include &lt;cmocka.h&gt;\n\n/* A test case that does nothing and succeeds. */\nstatic void null_test_success(void **state) {\n    (void) state; /* unused */\n}\n\nint main(void) {\n    const struct CMUnitTest tests[] = {\n        cmocka_unit_test(null_test_success),\n    };\n    return cmocka_run_group_tests(tests, NULL, NULL);\n}\n",
            "#include &lt;cheat.h&gt;\n\nCHEAT_TEST(mathematics_still_work,\n    cheat_assert(2 + 2 == 4);\n    cheat_assert_not(2 + 2 == 5);\n)\n\n$ gcc -I . tests.c\n$ ./a.out\n..\n---\n2 successful of 2 run\nSUCCESS\n",
            "assert()\n&amp;&amp;",
            "check_PROGRAMS = test_oe_amqp\n\ntest_oe_amqp_SOURCES = test_oe_amqp.c\ntest_oe_amqp_LDADD = -L$(top_builddir)/components/common -loecommon\ntest_oe_amqp_CFLAGS = -I$(top_srcdir)/components/common -static\n\nTESTS = test_oe_amqp\n"
        ]
    },
    {
        "question_id": 154136,
        "question_code": "do while\n#define FOO(X) do { f(X); g(X); } while (0)\n#define FOO(X) if (1) { f(X); g(X); } else\n\ndo while\n#define FOO(X) f(X); g(X)\n",
        "answer_code_snippets": [
            "do ... while\nif ... else\n#define BAR(X) f(x); g(x)\n\nBAR(X);\nif ... else\nif (corge)\n  BAR(corge);\nelse\n  gralt();\n\nif (corge)\n  f(corge); g(corge);\nelse\n  gralt();\n\nif (corge)\n  {f(corge); g(corge);};\nelse\n  gralt();\n\n#define BAR(X) f(X), g(X)\n\nBAR\nif (corge)\n  f(corge), g(corge);\nelse\n  gralt();\n\nf(X)\ndo ... while\n#define BAR(X) do { \\\n  int i = f(X); \\\n  if (i &gt; 4) g(i); \\\n} while (0)\n\ndo ... while\nif ... else\nif ... else\nif ... else\nif (corge)\n  if (1) { f(corge); g(corge); } else;\nelse\n  gralt();\n\nBAR\ndo ... while",
            "doSomething(1) ;\nDO_SOMETHING_ELSE(2)  // &lt;== Hey? What's this?\ndoSomethingElseAgain(3) ;\n\nif(bIsOk)\n   MY_MACRO(42) ;\n\n#define MY_MACRO(x) f(x) ; g(x)\n\nif(bIsOk)\n   f(42) ; g(42) ; // was MY_MACRO(42) ;\n\ng\nbIsOk\n#define MY_MACRO(x) { f(x) ; g(x) ; }\n\nif(bIsOk)\n   { f(42) ; g(42) ; } ; // was MY_MACRO(42) ;\n\n#define MY_MACRO(x) int i = x + 1 ; f(i) ;\n\nvoid doSomething()\n{\n    int i = 25 ;\n    MY_MACRO(32) ;\n}\n\nvoid doSomething()\n{\n    int i = 25 ;\n    int i = 32 + 1 ; f(i) ; ; // was MY_MACRO(32) ;\n}\n\n#define MY_MACRO(x) { int i = x + 1 ; f(i) ; }\n\nvoid doSomething()\n{\n    int i = 25 ;\n    { int i = 32 + 1 ; f(i) ; } ; // was MY_MACRO(32) ;\n}\n\ndo\n{\n    // code\n}\nwhile(false) ;\n\n#define MY_MACRO(x)                                  \\\ndo                                                   \\\n{                                                    \\\n    const int i = x + 1 ;                            \\\n    f(i) ; g(i) ;                                    \\\n}                                                    \\\nwhile(false)\n\nvoid doSomething(bool bIsOk)\n{\n   int i = 25 ;\n\n   if(bIsOk)\n      MY_MACRO(42) ;\n\n   // Etc.\n}\n\nvoid doSomething(bool bIsOk)\n{\n   int i = 25 ;\n\n   if(bIsOk)\n      do\n      {\n         const int i = 42 + 1 ; // was MY_MACRO(42) ;\n         f(i) ; g(i) ;\n      }\n      while(false) ;\n\n   // Etc.\n}\n\nvoid doSomething(bool bIsOk)\n{\n   int i = 25 ;\n\n   if(bIsOk)\n   {\n      f(43) ; g(43) ;\n   }\n\n   // Etc.\n}\n",
            "#define FOO(x)  f(x); g(x)\n\nif (test) FOO( baz);\n\nif (test) f(baz); g(baz);\n",
            "do ... while\nif ... else\nif ... else\nFOO(1)\nprintf(\"abc\");\n\nif (1) { f(X); g(X); } else\nprintf(\"abc\");\n\nprintf\ndo ... while\nwhile(0)",
            "do {} while (0)\nif (1) {} else\nif (something)\n    FOO(X); \n\nif (something)\n    f(X); g(X); \n\ng(X)\nif\ndo {} while (0)\nif (1) {} else\ndo {} while (0)\nif (1) {} else\n({})\n#define FOO(X) ({f(X); g(X);})\n\ndo {} while (0)\nreturn FOO(&quot;X&quot;);\n",
            "do { ... } while(false);\n#define FOO(X) (f(X),g(X))\n\n#define FOO(X) g((f(X),(X)))\n\n#define\n#define FOO(X) (int s=5,f((X)+s),g((X)+s))\n",
            "if(1) { ... } else\n#define P99_NOP ((void)0)\n#define P99_PREFER(...) if (1) { __VA_ARGS__ } else\n#define P99_BLOCK(...) P99_PREFER(__VA_ARGS__) P99_NOP\n\ndo { ... } while(0)\nbreak\ncontinue\n((void)0)\nelse\nif",
            "#define FOO(X) do { int i; for (i = 0; i &lt; (X); ++i) do_something(i); } while (0)\n\nvoid some_func(void) {\n    int i;\n    for (i = 0; i &lt; 10; ++i)\n        FOO(i);\n}\n",
            "while(i&lt;100)\n  FOO(i++);\n\nwhile(i&lt;100)\n  do { f(i++); g(i++); } while (0)\n\ni++"
        ]
    },
    {
        "question_id": 949433,
        "question_code": "#include &lt;stdio.h&gt;\n\nint main(void)\n{\n   int i = 0;\n   i = i++ + ++i;\n   printf(\"%d\\n\", i); // 3\n\n   i = 1;\n   i = (i++);\n   printf(\"%d\\n\", i); // 2 Should be 1, no ?\n\n   volatile int u = 0;\n   u = u++ + ++u;\n   printf(\"%d\\n\", u); // 1\n\n   u = 1;\n   u = (u++);\n   printf(\"%d\\n\", u); // 2 Should also be one, no ?\n\n   register int v = 0;\n   v = v++ + ++v;\n   printf(\"%d\\n\", v); // 3 (Should be the same as u ?)\n\n   int w = 0;\n   printf(\"%d %d\\n\", ++w, w); // shouldn't this print 1 1\n\n   int x[2] = { 5, 8 }, y = 0;\n   x[y] = y ++;\n   printf(\"%d %d\\n\", x[0], x[1]); // shouldn't this print 0 8? or 5 0?\n}\n",
        "answer_code_snippets": [
            "volatile\nu = (u++);\n",
            "A\nB\nA\nB\nA\nB\nA\nB\nA\nB\nA\nB\nA\nB\nint i = 1;\ni = i++;\n\ni\ni\n++\ni\nil\ni++\nir\nil = ir++     // Note that suffix l and r are used for the sake of clarity.\n              // Both il and ir represents the same object.  \n\n++\n++\nil = ir++\ntemp = ir;      // i = 1\nir = ir + 1;    // i = 2   side effect by ++ before assignment\nil = temp;      // i = 1   result is 1  \n\ntemp = ir;      // i = 1\nil = temp;      // i = 1   side effect by assignment before ++\nir = ir + 1;    // i = 2   result is 2  \n\n1\n2\n++",
            "$ cat evil.c\nvoid evil(){\n  int i = 0;\n  i+= i++ + ++i;\n}\n$ gcc evil.c -c -o evil.bin\n$ gdb evil.bin\n(gdb) disassemble evil\nDump of assembler code for function evil:\n   0x00000000 &lt;+0&gt;:   push   %ebp\n   0x00000001 &lt;+1&gt;:   mov    %esp,%ebp\n   0x00000003 &lt;+3&gt;:   sub    $0x10,%esp\n   0x00000006 &lt;+6&gt;:   movl   $0x0,-0x4(%ebp)  // i = 0   i = 0\n   0x0000000d &lt;+13&gt;:  addl   $0x1,-0x4(%ebp)  // i++     i = 1\n   0x00000011 &lt;+17&gt;:  mov    -0x4(%ebp),%eax  // j = i   i = 1  j = 1\n   0x00000014 &lt;+20&gt;:  add    %eax,%eax        // j += j  i = 1  j = 2\n   0x00000016 &lt;+22&gt;:  add    %eax,-0x4(%ebp)  // i += j  i = 3\n   0x00000019 &lt;+25&gt;:  addl   $0x1,-0x4(%ebp)  // i++     i = 4\n   0x0000001d &lt;+29&gt;:  leave  \n   0x0000001e &lt;+30&gt;:  ret\nEnd of assembler dump.\n",
            "6.5\ni = i++ + ++i;\n\ni++\n++i\ni\nu\n6.5\ni = ++i + 1;\na[i++] = i; \n\n;\ni = i++ + ++i;\n^   ^       ^\n\ni = (i++);\n^    ^\n\nu = u++ + ++u;\n^   ^       ^\n\nu = (u++);\n^    ^\n\nv = v++ + ++v;\n^   ^       ^\n\n3.4.4\n3.4.3",
            "i = i++ + ++i\ni = i++\ni\ni\ni\ni\ni = i + 1\n\ni++\n\ni\ni\ni = i++\n\ni\ni\ni\n++\n++\n++\n++",
            "printf(\"%d %d\\n\", i, i++);\n\nprintf(\"%d %d\\n\", ++i, i++);\n\nprintf()\nx = i++ + i++;\n\nprintf(\"%d %d\\n\", ++i, i++);\n\nprintf()\ni++\n++i\nprintf(\"%d %d\\n\", ++x, y++);\n\n++x\ny++\n++x\ny++\nprintf(\"%d %d\\n\", ++i, i++);\n\ni\nint i = 5;\nint j;\n\nj = (++i, i++);  // No undefined behaviour here because the comma operator \n                 // introduces a sequence point between '++i' and 'i++'\n\nprintf(\"i=%d j=%d\\n\",i, j); // prints: i=7 j=6\n\nj = (++i, i++);\n++i\ni\n6\ni++\ni\n6\nj\ni\n7\nprintf(\"%d %d\\n\", ++i, i++);\n",
            "In a single operation, read `i` and lock it to prevent access until further notice\nCompute (1+read_value)\nIn a single operation, unlock `i` and store the computed value\n\ni\ni++\ni\ni\np\nq\n(*p)\n(*q)\ni\np\nq",
            "a = a++\na++ + a++\ni = ++i + 1;\na[i++] = i;\n\ni = i + 1;\na[i] = i;\n\n-Wall\n-Werror\n% gcc plusplus.c -Wall -Werror -pedantic\nplusplus.c: In function ‘main’:\nplusplus.c:6:6: error: operation on ‘i’ may be undefined [-Werror=sequence-point]\n    i = i++ + ++i;\n    ~~^~~~~~~~~~~\nplusplus.c:6:6: error: operation on ‘i’ may be undefined [-Werror=sequence-point]\nplusplus.c:10:6: error: operation on ‘i’ may be undefined [-Werror=sequence-point]\n    i = (i++);\n    ~~^~~~~~~\nplusplus.c:14:6: error: operation on ‘u’ may be undefined [-Werror=sequence-point]\n    u = u++ + ++u;\n    ~~^~~~~~~~~~~\nplusplus.c:14:6: error: operation on ‘u’ may be undefined [-Werror=sequence-point]\nplusplus.c:18:6: error: operation on ‘u’ may be undefined [-Werror=sequence-point]\n    u = (u++);\n    ~~^~~~~~~\nplusplus.c:22:6: error: operation on ‘v’ may be undefined [-Werror=sequence-point]\n    v = v++ + ++v;\n    ~~^~~~~~~~~~~\nplusplus.c:22:6: error: operation on ‘v’ may be undefined [-Werror=sequence-point]\ncc1: all warnings being treated as errors\n\nj = (i ++, ++ i);\n\ni\ni\nj = (i += 2)\ni += 2;\nj = i;\n\n,\nint i = 0;\nprintf(\"%d %d\\n\", i++, ++i, i);\n\ni++\n++i\ni\ni++\n++i",
            "++\n++\n--\n++x\nx++\nint x = 5;\nprintf(&quot;%d %d %d\\n&quot;, x, ++x, x++);\n\n++\nint x = 5;\nx = x++ + ++x;\nprintf(&quot;%d\\n&quot;, x);\n\n++\n--\nprintf(&quot;%d %d %d\\n&quot;, x, ++x, x++);\n\nprintf\nx\nx++\n++x\nx\n++x\nx++\nx++\n++x\nx\nx = x++ + ++x;\n\nx\nx++\nx\nx\n++x\nx\nx\nx =\nx\nx\nx\ny = x++;\nz = x++ + y++;\nx = x + 1;\nx = a[i++];\nx = a[i++] + b[j++];\nx[i++] = a[j++] + b[k++];\nx = *p++;\nx = *p++ + *q++;\n\nx = x++;\nx = x++ + ++x;\ny = x + x++;\na[i] = i++;\na[i++] = i;\nprintf(&quot;%d %d %d\\n&quot;, x, ++x, x++);\n\nx = x++ + ++x;\n\nx\ny = x + x++;\n\nx\nprintf(&quot;%d %d %d\\n&quot;, x, ++x, x++);\nprintf\nprintf(&quot;%d &quot;, x);\nprintf(&quot;%d &quot;, ++x);\nprintf(&quot;%d\\n&quot;, x++);\n\nx = x++ + ++x\nx = x++ + ++x",
            "i = i++;\ni = i++ + ++i;\n\nwhile(*src++ = *dst++);\n",
            "int k[] = {0,1,2,3,4,5,6,7,8,9,10};\nint i = 0;\nint num;\nnum = k[++i+k[++i]] + k[++i];\nprintf(\"%d\", num);\n\n++i\n++i\nk[]\n++i\nk[]\nnum = k[i+1]+k[i+2] + k[i+3];\ni += 3\n",
            "i=i++\ni=\ni++\ni=i++\nexpression-statement\ni=i++\n\ntmp = i\ni=i+1\ni = tmp\n\ntmp = i\ni = tmp\ni=i+1\n\ni=i++",
            " #include&lt;stdio.h&gt;\n int main(int argc, char ** argv)\n {\n    int i = 0;\n    i = i++ + ++i;\n    printf(&quot;%d\\n&quot;, i); // 2\n\n    i = 1;\n    i = (i++);\n    printf(&quot;%d\\n&quot;, i); //1\n\n    volatile int u = 0;\n    u = u++ + ++u;\n    printf(&quot;%d\\n&quot;, u); // 2\n\n    u = 1;\n    u = (u++);\n    printf(&quot;%d\\n&quot;, u); //1\n\n    register int v = 0;\n    v = v++ + ++v;\n    printf(&quot;%d\\n&quot;, v); //2\n }\n\n#include&lt;stdio.h&gt;\nint main(int argc, char ** argv)\n{\n    int i = 0;\n    //i = i++ + ++i;\n    int r;\n    r=i;\n    i++;\n    ++i;\n    r+=i;\n    i=r;\n    printf(&quot;%d\\n&quot;, i); // 2\n\n    i = 1;\n    //i = (i++);\n    r=i;\n    i++;\n    i=r;\n    printf(&quot;%d\\n&quot;, i); // 1\n\n    volatile int u = 0;\n    //u = u++ + ++u;\n    r=u;\n    u++;\n    ++u;\n    r+=u;\n    u=r;\n    printf(&quot;%d\\n&quot;, u); // 2\n\n    u = 1;\n    //u = (u++);\n    r=u;\n    u++;\n    u=r;\n    printf(&quot;%d\\n&quot;, u); // 1\n\n    register int v = 0;\n    //v = v++ + ++v;\n    r=v;\n    v++;\n    ++v;\n    r+=v;\n    v=r;\n    printf(&quot;%d\\n&quot;, v); //2\n}\n\n#include&lt;stdio.h&gt;\nint main(int argc, char ** argv)\n{\n    int i = 0;\n    i = i++ + ++i;\n    printf(&quot;%d\\n&quot;, i); // 3\n\n    i = 1;\n    i = (i++);\n    printf(&quot;%d\\n&quot;, i); // 2 \n\n    volatile int u = 0;\n    u = u++ + ++u;\n    printf(&quot;%d\\n&quot;, u); // 3\n\n    u = 1;\n    u = (u++);\n    printf(&quot;%d\\n&quot;, u); // 2 \n\n    register int v = 0;\n    v = v++ + ++v;\n    printf(&quot;%d\\n&quot;, v); // 3 \n}\n\n#include&lt;stdio.h&gt;\nint main(int argc, char ** argv)\n{\n    int r;\n    int i = 0;\n    //i = i++ + ++i;\n    ++i;\n    r = i + i;\n    i = r;\n    i++;\n    printf(&quot;%d\\n&quot;, i); // 3\n\n    i = 1;\n    //i = (i++);\n    r = i;\n    i = r;\n    i++;\n    printf(&quot;%d\\n&quot;, i); // 2 \n\n    volatile int u = 0;\n    //u = u++ + ++u;\n    ++u;\n    r = u + u;\n    u = r;\n    u++;\n    printf(&quot;%d\\n&quot;, u); // 3\n\n    u = 1;\n    //u = (u++);\n    r = u;\n    u = r;\n    u++;\n    printf(&quot;%d\\n&quot;, u); // 2 \n\n    register int v = 0;\n    //v = v++ + ++v;\n    ++v;\n    r = v + v;\n    v = r;\n    v++;\n    printf(&quot;%d\\n&quot;, v); // 3 \n}\n",
            "i++\ni\ni\ni+1\ni\ni++ + ++i\ni\ni+1\ni++ + ++i\ni\ni\ni\ni\ni+i+1\ni+2\ni\n2*i+1; i+=2;\n++\ni=i+1"
        ]
    },
    {
        "question_id": 2346806,
        "question_code": "",
        "answer_code_snippets": [
            "int *p = NULL;\n*p = 1;\n\nchar *str = &quot;Foo&quot;; // Compiler marks the constant string as read-only\n*str = 'b'; // Which means this is illegal and results in a segfault\n\nchar *p = NULL;\n{\n    char c;\n    p = &amp;c;\n}\n// Now p is dangling\n\np\nc\n*p='A'",
            "int *arr = new int[20];\ndelete arr;\ncout&lt;&lt;arr[1];  //dangling problem occurs here\n",
            "#include &lt;stdio.h&gt;\n\nint main(int argc, char *argv[]) {\n    \n    char A = 'asd';\n    puts(A);\n    \n    return 0;\n    \n}\n\nchar\nstring\nchar",
            "int main(int argc, char *argv[])",
            "printf\n#include &lt;stdio.h&gt;\nint main(){   \n  int a = 5;\n  printf(&quot;%s&quot;,a);\n  return 0;\n}\n\nSegmentation Fault (SIGSEGV)\n#include &lt;stdio.h&gt; \ntypedef struct{\n  int a;\n} myStruct;   \nint main(){\n  myStruct *s;\n  /* few lines of code */\n  s-&gt;a = 5;\n  return 0;\n}\n\nSegmentation Fault (SIGSEGV)",
            "Segmentation fault\nSegmentation fault\nSegmentation fault\nscanf()\n&amp;\nint num;\nscanf(\"%d\", num);// must use &amp;num instead of num\n\nint *num; \nprintf(\"%d\",*num); //*num should be correct as num only\n//Unless You can use *num but you have to point this pointer to valid memory address before accessing it.\n\nchar *str;  \n\n//Stored in read only part of data segment\nstr = \"GfG\";      \n\n//Problem:  trying to modify read only memory\n*(str+1) = 'n';\n\n// allocating memory to num \nint* num = malloc(8); \n*num = 100; \n\n// de-allocated the space allocated to num \nfree(num); \n\n// num is already freed there for it cause segmentation fault\n*num = 110; \n\nprintf()\nscanf()",
            "int *number = NULL;\n*number = 1;\n\nint *number = malloc(sizeof(int));\n*number = 1;\n\nmalloc()\nsizeof()",
            " /* \"Array out of bounds\" error \n   valid indices for array foo\n   are 0, 1, ... 999 */\n   int foo[1000];\n   for (int i = 0; i &lt;= 1000 ; i++) \n   foo[i] = i;\n\nit arise primarily due to errors in use of pointers for virtual memory addressing, particularly illegal access.\n\nDe-referencing NULL pointers – this is special-cased by memory management hardware.\n\nAttempting to access a nonexistent memory address (outside process’s address space).\n\nAttempting to access memory the program does not have rights to (such as kernel structures in process context).\n\nAttempting to write read-only memory (such as code segment).\n"
        ]
    },
    {
        "question_id": 1921539,
        "question_code": "",
        "answer_code_snippets": [
            "#include &lt;stdbool.h&gt;\n\ntypedef enum { false, true } bool;\n\ntypedef int bool;\nenum { false, true };\n\ntypedef int bool;\n#define true 1\n#define false 0\n",
            "int\n&lt;stdbool.h&gt;\nif (ready == TRUE) ...\nwhile (empty == FALSE) ...\n\nif (ready) ...\nwhile (!empty) ...\n\nfull\nnotfull\nif (full) ...\nif (!full) ...\n\nif (!notfull) ...\nif (notfull) ...\n\n!notfull\nvoid foo(bool option) { ... }\n\nfoo(TRUE);\nfoo(FALSE):\n\ntypedef enum { OPT_ON, OPT_OFF } foo_option;\nvoid foo(foo_option option);\n\n#define OPT_ON true\n#define OPT_OFF false\nvoid foo(bool option) { ... }\n\nfoo(OPT_ON);\nfoo(OPT_OFF);\n\nfoo",
            "typedef enum { false = 0, true = !false } bool;\n\nif (true == !false)\n\ntypedef enum { myfalse = 0, mytrue = !myfalse } mybool;\n\ntrue\nfalse\nmybool somebool;\nint someint = 5;\nsomebool = !!someint;\n\nmyfalse\nfalse = 0,\nfalse,\ntypedef __attribute__((__packed__)) enum { myfalse = 0, mytrue = !myfalse } mybool;\n\nstruct mystruct {\n    mybool somebool1;\n    mybool somebool2;\n    mybool somebool3;\n    mybool somebool4;\n}\n",
            "#include &lt;stdbool.h&gt;\nint main()\n{\n  bool b = false;\n  b = true;\n}\n",
            "#include &lt;stdbool.h&gt;\ntrue\nfalse\nbool\n_Bool\n1\n0\ntypedef int bool;\n#define true 1\n#define false 0\n\nbool\nbool\ndouble a = ...;\nbool b = a;\n\nbool\n_Bool\nb\nfalse\na\ntrue\n_Bool\ntypedef\ndouble\nint\nint\ntrue\nfalse\nenum\ntypedef enum bool {\n    false, true\n} bool;\n\nint\n0\n1\n!!\nBOOL\nTRUE\nFALSE",
            "typedef enum {\n    false = 0,\n    true\n} t_bool;\n",
            "#define TRUE 1\n#define FALSE 0\n",
            "+-------+----------------+-------------------------+--------------------+\n|  Name | Characteristic | Dependence in stdbool.h |        Value       |\n+-------+----------------+-------------------------+--------------------+\n| _Bool |   Native type  |    Don't need header    |                    |\n+-------+----------------+-------------------------+--------------------+\n|  bool |      Macro     |           Yes           | Translate to _Bool |\n+-------+----------------+-------------------------+--------------------+\n|  true |      Macro     |           Yes           |   Translate to 1   |\n+-------+----------------+-------------------------+--------------------+\n| false |      Macro     |           Yes           |   Translate to 0   |\n+-------+----------------+-------------------------+--------------------+\n\n_Bool\nbool\nbool\n_Bool\nbool\n_Bool\nfalse\ntrue\n0\n1\nfalse\ntrue\n_Bool\nunsigned int\n0\n1\nbool\ntrue\nfalse\n_Bool\nbool\n0\n0\n0\n1\n _Bool x = 9;\n9\n1\nx\n_Bool\nchar",
            "bool\n_Bool\ntrue\nfalse\nbool\n_Bool\ntrue\nfalse\n!\n||\n&amp;&amp;\nbool\nfalse\nnull\nnullptr_t\ntrue\nbool\ntrue\nfalse\n&lt;stdbool.h&gt;\n__bool_true_false_are_defined\n_Bool\n1\n0\n!\n||\n&amp;&amp;\n_Bool\n0\n1\n&lt;stdbool.h&gt;\nbool\n_Bool\ntrue\n_Bool\n1\nfalse\n0\n__bool_true_false_are_defined\n1\nbool\ntrue\nfalse\ntypedef enum { false, true } bool;",
            "#include &lt;stdbool.h&gt;\n#include &lt;stdbool.h&gt;\n\nint main() \n{ \n    bool arr[2] = {true, false}; \n\n    printf(\"%d\\n\", arr[0] &amp;&amp; arr[1]);\n    printf(\"%d\\n\", arr[0] || arr[1]);\n\n    return 0; \n} \n\n0\n1\n",
            "void foo(bool flag);\n\n...\n\nint flag = TRUE;\nfoo(flag);\n\nfoo(flag == TRUE);\n\nfoo(flag == !0);\n",
            "#define TRUE  1\n#define FALSE 0\n\nchar bValue = TRUE;\n",
            "#define TRUE 1\n#define FALSE 0\n",
            "_Bool\n#include\n1\ntrue\n0\nfalse\nTRUE\nFALSE\n_Bool this_is_a_Boolean_var = 1;\n\n\n//or using it with true and false\n#define TRUE 1\n#define FALSE 0\n_Bool var = TRUE;\n",
            "enum {false, true};\ntypedef _Bool bool;\n\n_Bool",
            "#define\n#define TRUE 1\n#define FALSE 0\n#define NOT(arg) (arg == TRUE)? FALSE : TRUE\ntypedef int bool;\n\nbool isVisible = FALSE;\nbool isWorking = TRUE;\nisVisible = NOT(isVisible);\n"
        ]
    },
    {
        "question_id": 16931770,
        "question_code": "all:ll\n\nll:ll.c   \n  gcc  -c  -Wall -Werror -02 c.c ll.c  -o  ll  $@  $&lt;\n\nclean :\n  \\rm -fr ll\n\nmake clean\nmake make\n:makefile:4: *** missing separator.  Stop.\n",
        "answer_code_snippets": [
            "cat -e -t -v makefile_name\n^I\n$\nKaizen ~/so_test $ cat -e -t -v  mk.t\nall:ll$      ## here the $ is end of line ...                   \n$\nll:ll.c   $\n^Igcc  -c  -Wall -Werror -02 c.c ll.c  -o  ll  $@  $&lt;$ \n## the ^I above means a tab was there before the action part, so this line is ok .\n $\nclean :$\n   \\rm -fr ll$\n## see here there is no ^I which means , tab is not present .... \n## in this case you need to open the file again and edit/ensure a tab \n## starts the action part\n",
            ".RECIPEPREFIX\ngcc\ngcc\n\\rm -fr ll\nrm -fr ll",
            "make\nbash\nsometask:\n  ifeq ($FOO,bar)  // this is make code. only spaces\n    echo &quot;foobar&quot;  // this is bash code. only tabs\n  endif            // again, this is make code. only spaces\n",
            "PyCharm\nMakefile support\nPreferences\ncmd + ,\nPlugins\nMarketplace\nMakefile support",
            ".editorconfig\nroot = true\n\n[*]\ncharset = utf-8\nend_of_line = lf\ninsert_final_newline = true\nindent_style = space\nindent_size = 4\n\n[Makefile]\nindent_style = tab\n",
            "vi/vim\nvi/vim\nMakefile\nvim Makefile\n:set list\n %-linux: force$\n^I@if [ \"$(GCC_VERSION)\" = \"2.96\" ] ; then \\$\n^I^Iecho ===== Generating build tree for legacy $@ architecture =====; \\$\n^I^I$(CONFIGURE) $(CWD) $@ legacy; \\$\n^Ielse \\$\n^I^Iecho ===== Generating build tree for $@ architecture =====; \\$\n^I^I$(CONFIGURE) $(CWD) $@; \\$\n^Ifi$\n^Icd build-$@;make$\n",
            ".vimrc\nset tabstop=X",
            "Other File Types\nUse tab character\nTab size\nIndent",
            "perl -pi -e 's/^  */\\t/' Makefile",
            ".editorconfig\n[Makefile]\nindent_style = tab\n",
            ":set noet\n*** missing separator.  Stop.\n:set et",
            "Windows-&gt; Preferences-&gt;General-&gt;Editor-&gt;Text Editors-&gt;Show Whitespace Characters -&gt; Apply\n",
            "*** missing separator.  Stop.\n\n/home/user/#my_sources/\n"
        ]
    },
    {
        "question_id": 119123,
        "question_code": "sizeof",
        "answer_code_snippets": [
            "SIGBUS\nstruct X\n{\n    short s; /* 2 bytes */\n             /* 2 padding bytes */\n    int   i; /* 4 bytes */\n    char  c; /* 1 byte */\n             /* 3 padding bytes */\n};\n\nstruct Y\n{\n    int   i; /* 4 bytes */\n    char  c; /* 1 byte */\n             /* 1 padding byte */\n    short s; /* 2 bytes */\n};\n\nstruct Z\n{\n    int   i; /* 4 bytes */\n    short s; /* 2 bytes */\n    char  c; /* 1 byte */\n             /* 1 padding byte */\n};\n\nconst int sizeX = sizeof(struct X); /* = 12 */\nconst int sizeY = sizeof(struct Y); /* = 8 */\nconst int sizeZ = sizeof(struct Z); /* = 8 */\n\nZ\n#pragma",
            "struct {\n    char a[3];\n    short int b;\n    long int c;\n    char d[3];\n};\n\n+-------+-------+-------+-------+\n|           a           |   b   |\n+-------+-------+-------+-------+\n|   b   |           c           |\n+-------+-------+-------+-------+\n|   c   |           d           |\n+-------+-------+-------+-------+\n\n+-------+-------+-------+\n|           a           |\n+-------+-------+-------+\n|       b       |\n+-------+-------+-------+-------+\n|               c               |\n+-------+-------+-------+-------+\n|           d           |\n+-------+-------+-------+\n\n+-------+-------+-------+-------+\n|           a           | pad1  |\n+-------+-------+-------+-------+\n|       b       |     pad2      |\n+-------+-------+-------+-------+\n|               c               |\n+-------+-------+-------+-------+\n|           d           | pad3  |\n+-------+-------+-------+-------+\n",
            "__attribute__((packed))",
            "#include \"stdio.h\"\n\n\nstruct oneInt {\n  int x;\n};\n\nstruct twoInts {\n  int x;\n  int y;\n};\n\nstruct someBits {\n  int x:2;\n  int y:6;\n};\n\n\nint main (int argc, char** argv) {\n  printf(\"oneInt=%zu\\n\",sizeof(struct oneInt));\n  printf(\"twoInts=%zu\\n\",sizeof(struct twoInts));\n  printf(\"someBits=%zu\\n\",sizeof(struct someBits));\n  return 0;\n}\n\noneInt=4\ntwoInts=8\nsomeBits=4\n",
            "struct myStruct\n{\n   int a;\n   char b;\n   int c;\n} data;\n\n#pragma pack 1\nstruct MyStruct\n{\n    int a;\n    char b;\n    int c;\n    short d;\n} myData;\n\nI = sizeof(myData);\n",
            "struct S {int is[];};",
            "struct pixel {\n    unsigned char red;   // 0\n    unsigned char green; // 1\n    unsigned int alpha;  // 4 (gotta skip to an aligned offset)\n    unsigned char blue;  // 8 (then skip 9 10 11)\n};\n\n// next offset: 12\n",
            "sizeof\nsizeof\nsizeof\nsizeof\nsizeof\nstruct foo {\n   int a;   \n   int b;\n   int c;     \n} bar;\n\nsizeof(int) == 4\nbar\nsizeof(bar) == 12\nstruct foo {\n   short int a;   \n   short int b;\n   int c;     \n} bar;\n\nsizeof(short int) == 2\nsizeof(int) == 4\na\nb\nc\nsizeof(bar) == 8",
            "#pragma pack(push, 1)\n\n// your structure\n\n#pragma pack(pop) \n"
        ]
    },
    {
        "question_id": 204476,
        "question_code": "main()\nint main()\nvoid main()\nint main()\nreturn 1\nreturn 0",
        "answer_code_snippets": [
            "main\nmain\nvoid main()\nmain\nint main(void)\n\nint main(int argc, char **argv)\n\nint main(int argc, char *argv[])\n\nint main()\nreturn 0;\nmain\nmain()\nint main()\nint main(int argc, char **argv)\nreturn 0;",
            "main()\nint main(void)\nint main(int argc, char **argv)\n\nint main(int argc, char *argv[])\nint\nint\nmain()\nint main(int argc, char *argv[], char *envp[])\n0\nEXIT_SUCCESS\nEXIT_FAILURE\nmain()\nreturn\nmain()\nmain()\nreturn 0\nmain()",
            "main\nint\nint main(void) { /* ... */ }\n\nargc\nargv\nint main(int argc, char *argv[]) { /* ... */ }\n\nargc\nargv[argc]\nargc\nargv[0]\nargv[argc-1]\nargc\nargv[0]\nargv[0][0]\nargc\nargv[1]\nargv[argc-1]\nargc\nargv\nargv\nint\nint\nargv\nchar **argv\nmain()\nmain\nint\nmain\nexit\nmain\n}\nmain\nint\nmain\n0\nEXIT_FAILURE\nEXIT_SUCCESS\n&lt;stdlib.h&gt;\nmain()\nexit\nstatus\nEXIT_SUCCESS\nstatus\nEXIT_FAILURE\nint main() { /* ... */ }\n\nint main(int argc, char* argv[]) { /* ... */ }\n\nargc\nargc\nargv[0]\nargv[argc-1]\nargv[0]\n&quot;&quot;\nargc\nargv[argc]\nargv\nmain\nmain\nstd::exit\nreturn 0;\n\nint\nmain\nexit\nEXIT_SUCCESS\nEXIT_FAILURE\n&lt;cstdlib&gt;\nint main(int argc, char **argv, char **envp) { ... }\n\nextern char **environ;\nchar *envp[]\nchar\n int main();\n\nint main(int argc, char *argv[], char *envp[]);\n\nmain\nwmain\nvoid\nmain\nwmain\nmain\nwmain\nvoid\nexit\nvoid main()\nmain()\nchar **envp\nwmain()\nvoid main()\nmain\n&lt;float.h&gt;\n&lt;iso646.h&gt;\n&lt;limits.h&gt;\n&lt;stdalign.h&gt;\n&lt;stdarg.h&gt;\n&lt;stdbool.h&gt;\n&lt;stddef.h&gt;\n&lt;stdint.h&gt;\n&lt;stdnoreturn.h&gt;\n#ifdef __STDC_IEC_559__ /* FE_UPWARD defined */\n    /* ... */\n    fesetround(FE_UPWARD);\n    /* ... */\n#endif\n\n&lt;stdarg.h&gt;\n&lt;cstdlib&gt;\nabort\natexit\nat_quick_exit\nexit\nquick_exit\n&lt;ciso646&gt;\n&lt;cstddef&gt;\n&lt;cfloat&gt;\n&lt;limits&gt;\n&lt;climits&gt;\n&lt;cstdint&gt;\n&lt;cstdlib&gt;\n&lt;new&gt;\n&lt;typeinfo&gt;\n&lt;exception&gt;\n&lt;initializer_list&gt;\n&lt;cstdalign&gt;\n&lt;cstdarg&gt;\n&lt;cstdbool&gt;\n&lt;type_traits&gt;\n&lt;atomic&gt;\nint main()\nint main(void)\nint main()\nint main()\nint main()\nsizeof\n_Alignof\n#include &lt;stddef.h&gt;\n\nsize_t fsize3(int n)\n{\n    char b[n+3]; // variable length array\n    return sizeof b; // execution time sizeof\n}\nint main()\n{\n    size_t size;\n    size = fsize3(10); // fsize3 returns 13\n    return 0;\n}\n\nint main(){ … }\nmain()\nmain()\nmain()\nint i = 0;\nint main()\n{\n    if (i++ &lt; 10)\n        main(i, i * i);\n    return 0;\n}\n\n-Wstrict-prototypes\nmain(void)",
            "main()\nEXIT_SUCCESS\nEXIT_FAILURE\nstdlib.h",
            "int main (void)\nint main (int argc, char *argv[])\n\nmain (void)\nmain (int argc, char *argv[])\n/*... etc, similar forms with implicit int */\n\nint main (void)\nint main (int argc, char *argv[])\n/* or in some other implementation-defined manner. */\n\nmain()\nint main()\nmain()\nint main\nint main (void)\nint main (int argc, char *argv[])\n/* or in some other implementation-defined manner. */\n\nint main()\n()\n(void)\nint main ()\nint main (int argc, char *argv[])\n\nmain()\n// implementation-defined name, or \nint main ()\nint main (int argc, char *argv[])\n\nint main ()\nint main (int argc, char *argv[])\n\nmain()\n// implementation-defined name, or \nint main ()\nint main (int argc, char *argv[])\n\nint main(void) { /* ... */ } \n\nint main(int argc, char *argv[]) { /* ... */ }\n\nint main(void) { /* ... */ } \n\nint main(int argc, char *argv[]) { /* ... */ }\n\n}\nint main() { /* ... */ }\n\nint main(int argc, char* argv[]) { /* ... */ }\n",
            "main()\nreturn 1? return 0?\n\nint main()\n}\nreturn 0\nreturn 1\nmain()\n$ ./a.out\n$ echo $?\n\n$?\nmain()\nreturn 0",
            "main()\nzero",
            "return 0\nmain\nreturn 0;\nmain\nmain\nexit\nmain\n}\nmain\nreturn;\nvoid\nreturn 0;\nmain",
            "main()\nint\nmain()\nint\nmain()\nmain()\nmain()\nmain\nmain",
            "int main (void) { .. return 0; .. }",
            "$ grep order myfile\n\n$ echo $?\n$ 0\n\n$ grep foo myfile\n$ echo $?\n$ 1\n\n$ grep foo myfile\n$ CHECK=$?\n$ [ $CHECK -eq 0] &amp;&amp; echo 'Match found'; [ $CHECK -ne 0] &amp;&amp; echo 'No match was found'\n$ No match was found\n",
            "int\nint main(void) { /* ... */ }\n\nargc\nargv\nint main(int argc, char *argv[]) { /* ... */ }\n\nint read_file(char filename[LEN]);",
            "STATUS_ACCESS_VIOLATION (0xC0000005)\nmain\nexit"
        ]
    },
    {
        "question_id": 9410,
        "question_code": "",
        "answer_code_snippets": [
            "void func ( void (*f)(int) );\n\nf\nvoid\nint\nprint\nfunc\nvoid print ( int x ) {\n  printf(\"%d\\n\", x);\n}\n\nfunc(print);\n\nfunc\nfunc\nfunc\nfor ( int ctr = 0 ; ctr &lt; 5 ; ctr++ ) {\n  print(ctr);\n}\n\nfunc\nf\nf\n*f\nf\nprint\n*f\nvoid func ( void (*f)(int) ) {\n  for ( int ctr = 0 ; ctr &lt; 5 ; ctr++ ) {\n    (*f)(ctr);\n  }\n}\n",
            "typedef void (*functiontype)();\n\nvoid dosomething() { }\n\nfunctiontype func = &amp;dosomething;\nfunc();\n\ntypedef int (*functiontype2)(char);\n\nint dosomethingwithchar(char a) { return 1; }\n\nfunctiontype2 func2 = &amp;dosomethingwithchar\nint result = func2('a');\n\nboost::function&lt;int (char a)&gt; functiontype2;\n",
            "std::function&lt;bool (int)&gt;\n\nbool\nint\n// g++ test.cpp --std=c++11\n#include &lt;functional&gt;\n\ndouble Combiner(double a, double b, std::function&lt;double (double,double)&gt; func){\n  return func(a,b);\n}\n\ndouble Add(double a, double b){\n  return a+b;\n}\n\ndouble Mult(double a, double b){\n  return a*b;\n}\n\nint main(){\n  Combiner(12,13,Add);\n  Combiner(12,13,Mult);\n}\n\n// g++ test.cpp --std=c++11\n\ntemplate&lt;class T&gt;\ndouble Combiner(double a, double b, T func){\n  return func(a,b);\n}\n\ndouble Add(double a, double b){\n  return a+b;\n}\n\ndouble Mult(double a, double b){\n  return a*b;\n}\n\nint main(){\n  Combiner(12,13,Add);\n  Combiner(12,13,Mult);\n}\n",
            "#include &lt;stdio.h&gt;\n\nvoid print();\nvoid execute(void());\n\nint main()\n{\n    execute(print); // sends address of print\n    return 0;\n}\n\nvoid print()\n{\n    printf(\"Hello!\");\n}\n\nvoid execute(void f()) // receive address of print\n{\n    f();\n}\n\n#include &lt;stdio.h&gt;\n\nvoid print();\nvoid execute(void (*f)());\n\nint main()\n{\n    execute(&amp;print); // sends address of print\n    return 0;\n}\n\nvoid print()\n{\n    printf(\"Hello!\");\n}\n\nvoid execute(void (*f)()) // receive address of print\n{\n    f();\n}\n",
            "void foo(int bar(int, int));\n\nvoid foo(int (*bar)(int, int));\n",
            "compare\nsorting\nbool compare(int a, int b) {\n    return a &gt; b;\n}\n\nvoid bubble_sort(int arr[], int n, bool (&amp;cmp)(int a, int b)) {\n\n    for (int i = 0;i &lt; n - 1;i++) {\n        for (int j = 0;j &lt; (n - 1 - i);j++) {\n            \n            if (cmp(arr[j], arr[j + 1])) {\n                swap(arr[j], arr[j + 1]);\n            }\n        }\n    }\n}\n\nmain\nint main()\n{\n    int i, n = 10, key = 11;\n    int arr[10] = { 20, 22, 18, 8, 12, 3, 6, 12, 11, 15 };\n\n    bubble_sort(arr, n, compare);\n    cout&lt;&lt;&quot;Sorted Order&quot;&lt;&lt;endl;\n    for (int i = 0;i &lt; n;i++) {\n        cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;\n    }\n}\n\nSorted Order\n3 6 8 11 12 12 15 18 20 22\n",
            "typedef int function();\n\nfunction *g(function *f)\n{\n    f();\n    return f;\n}\n\nint main(void)\n{\n    function f;\n\n    function *fn = g(f);\n\n    fn();\n}\n\nint f() { return 0; }\n",
            "#include &lt;stdio.h&gt;\n\nint IncMultInt(int a, int b)\n{\n    a++;\n    return a * b;\n}\n\nint main(int argc, char *argv[])\n\n{\n    int a = 5;\n    int b = 7;\n\n    printf(\"%d * %d = %d\\n\", a, b, IncMultInt(a, b));\n\n    b = 9;\n\n    // Create some local code with it's own local variable\n    printf(\"%d * %d = %d\\n\", a, b,  ( { int _a = a+1; _a * b; } ) );\n\n    return 0;\n}\n"
        ]
    },
    {
        "question_id": 2550774,
        "question_code": "size_t\nsizeof\nfor\nfor(i = 0; i &lt; some_size; i++)\n\nint i;\nsize_t i;",
        "answer_code_snippets": [
            "size_t\nsize_t\nstddef.h\nstdlib.h\nstddef.h\nsize_t\nsize_t\nsize_t",
            "size_t\nstrlen()\nsize_t\nsize_t\nsize_t\nsize_t s1 = strlen(str1);\nsize_t s2 = strlen(str2);\n\nstr2\nstr1\nint diff = s2 - s1; /* bad */\n\ndiff\ns2 &lt; s1\nint\nlong long\ns1\ns2\nsize_t\nfgets\nsize_t\nint",
            "size_t\nunsigned char\nunsigned short\nunsigned int\nunsigned long\nunsigned long long\nsize_t\nstddef.h\ntypedef unsigned long size_t;\n",
            "echo | gcc -E -xc -include 'stddef.h' - | grep size_t\n\ntypedef long unsigned int size_t;\n\nstddef.h\nsrc/gcc/ginclude/stddef.h\nmalloc\nsize_t\nsizeof",
            "size_t\nsize_t\nptrdiff_t\nsize_t\nptrdiff_t\nintptr_t\nuintptr_t\nsize_t\nptrdiff_t\nfar\nintptr_t\nsize_t\nptrdiff_t\nlong\nlong\nlong\nint\nint\nlong\nint\nlong\nint\nlong long int",
            "size_t\nsizeof\nptrdiff_t",
            "size_t\nint\nsize_t\nsizeof(void*)\nint\nsize_t\nssize_t\nint\nsize_t\nssize_t\nmmap()",
            "size_t\nsizeof\nconst\nsize_t\nconst\nconst size_t number;\n\nsize_t\n32-bit\nunsigned int\n64-bit\nunsigned long long int\nsize_t\nsize_t\n&lt;stdio.h&gt;\n&lt;stddef.h&gt;\n&lt;stdlib.h&gt;\n&lt;string.h&gt;\n&lt;time.h&gt;\n&lt;wchar.h&gt;\nconst\n#include &lt;stdio.h&gt;\n\nint main()\n{\n    const size_t value = 200;\n    size_t i;\n    int arr[value];\n\n    for (i = 0 ; i &lt; value ; ++i)\n    {\n        arr[i] = i;\n    }\n\n    size_t size = sizeof(arr);\n    printf(&quot;size = %zu\\n&quot;, size);\n}\n\nsize = 800\nconst\n#include &lt;stdio.h&gt;\n\nint main()\n{\n    size_t value = 200;\n    size_t i;\n    int arr[value];\n\n    for (i = 0; i &lt; value; ++i)\n    {\n        arr[i] = i;\n    }\n\n    size_t size = sizeof(arr);\n    printf(&quot;size = %zu\\n&quot;, size);\n}\n\nsize = 800",
            "size_t\nstddef.h\ntypedef unsigned long long size_t;\n\nsize_t\n&lt;stdio.h&gt;\nsize_t\nsize_t\n#include &lt;stdio.h&gt;\n\nvoid disp_ary(int *ary, size_t ary_size)\n{\n    for (int i = 0; i &lt; ary_size; i++)\n    {\n        printf(&quot;%d &quot;, ary[i]);\n    }\n}\n \nint main(void)\n{\n    int arr[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 0};\n    int ary_size = sizeof(arr)/sizeof(int);\n    disp_ary(arr, ary_size);\n    return 0;\n}\n\nsize_t\nld\nstack-size\nmalloc\nmemcpy\nstrlen\nsize_t\nsize_t\nsize_t\nconst char* reverse(char *orig)\n{\n  size_t len = strlen(orig);\n  char *rev = orig + len - 1;\n  while (rev &gt;= orig)\n  {\n    printf(&quot;%c&quot;, *rev);\n    rev = rev - 1;  // &lt;= See below\n  }\n  return rev;\n}\n\nint main() {\n  char *string = &quot;123&quot;;\n  printf(&quot;%c&quot;, reverse(string));\n}\n// Output: 321\n\n0x7ff626939004 &quot;123&quot;  // &lt;= orig\n0x7ff626939006 &quot;3&quot;    // &lt;= rev - 1 of 3\n0x7ff626939005 &quot;23&quot;   // &lt;= rev - 2 of 3\n0x7ff626939004 &quot;123&quot;  // &lt;= rev - 3 of 3\n0x7ff6aade9003 &quot;&quot;     // &lt;= rev is indeterminant. This can be exploited as an out of bounds bug to read memory contents that this program has no business reading.\n\nsize_t\nsize_t\nsize_t\nvoid print_reverse(int *orig, size_t ary_size)\n{\n  int *rev = orig + ary_size - 1;\n  while (rev &gt;= orig)\n  {\n    printf(&quot;%i&quot;, *rev);\n    rev = rev - 1;\n  }\n}\n\nint main()\n{\n  int nums[] = {1, 2, 3};\n  print_reverse(nums, sizeof(nums)/sizeof(*nums));\n\n  return 0;\n}\n\n0x617d3ffb44 1  // &lt;= orig\n0x617d3ffb4c 3  // &lt;= rev - 1 of 3\n0x617d3ffb48 2  // &lt;= rev - 2 of 3\n0x617d3ffb44 1  // &lt;= rev - 3 of 3\n\nt_size\nsize_t",
            "typedef\nunsigned int\nunsigned long",
            "// C program to demonstrate that size_t or\n// any unsigned int type should be used \n// carefully when used in a loop\n\n#include&lt;stdio.h&gt;\nint main()\n{\nconst size_t N = 10;\nint a[N];\n\n// This is fine\nfor (size_t n = 0; n &lt; N; ++n)\na[n] = n;\n\n// But reverse cycles are tricky for unsigned \n// types as can lead to infinite loop\nfor (size_t n = N-1; n &gt;= 0; --n)\nprintf(\"%d \", a[n]);\n}\n\nOutput\nInfinite loop and then segmentation fault\n",
            "size_t\nunsigned\nsizeof(size_t) &gt;= sizeof(void*)\n"
        ]
    },
    {
        "question_id": 612097,
        "question_code": "ls",
        "answer_code_snippets": [
            "std::filesystem\n#include &lt;string&gt;\n#include &lt;iostream&gt;\n#include &lt;filesystem&gt;\nnamespace fs = std::filesystem;\n\nint main()\n{\n    std::string path = &quot;/path/to/directory&quot;;\n    for (const auto &amp; entry : fs::directory_iterator(path))\n        std::cout &lt;&lt; entry.path() &lt;&lt; std::endl;\n}\n\ndirent.h\nDIR *dir;\nstruct dirent *ent;\nif ((dir = opendir (&quot;c:\\\\src\\\\&quot;)) != NULL) {\n  /* print all the files and directories within directory */\n  while ((ent = readdir (dir)) != NULL) {\n    printf (&quot;%s\\n&quot;, ent-&gt;d_name);\n  }\n  closedir (dir);\n} else {\n  /* could not open directory */\n  perror (&quot;&quot;);\n  return EXIT_FAILURE;\n}\n",
            "std::filesystem::directory_iterator\n#include &lt;string&gt;\n#include &lt;iostream&gt;\n#include &lt;filesystem&gt;\nnamespace fs = std::filesystem;\n \nint main() {\n  std::string path = &quot;/path/to/directory&quot;;\n\n  for (const auto &amp; entry : fs::directory_iterator(path)) {\n    std::cout &lt;&lt; entry.path() &lt;&lt; std::endl;\n  }\n}\n\nstd::filesystem::recursive_directory_iterator",
            "bool find_file(const path &amp; dir_path,         // in this directory,\n               const std::string &amp; file_name, // search for this name,\n               path &amp; path_found)             // placing path here if found\n{\n    if (!exists(dir_path)) \n        return false;\n\n    directory_iterator end_itr; // default construction yields past-the-end\n\n    for (directory_iterator itr(dir_path); itr != end_itr; ++itr)\n    {\n        if (is_directory(itr-&gt;status()))\n        {\n            if (find_file(itr-&gt;path(), file_name, path_found)) \n                return true;\n        }\n        else if (itr-&gt;leaf() == file_name) // see below\n        {\n            path_found = itr-&gt;path();\n            return true;\n        }\n    }\n    return false;\n}\n\nlen = strlen(name);\ndirp = opendir(\".\");\nwhile ((dp = readdir(dirp)) != NULL)\n        if (dp-&gt;d_namlen == len &amp;&amp; !strcmp(dp-&gt;d_name, name)) {\n                (void)closedir(dirp);\n                return FOUND;\n        }\n(void)closedir(dirp);\nreturn NOT_FOUND;\n\n#include &lt;windows.h&gt;\n#include &lt;tchar.h&gt;\n#include &lt;stdio.h&gt;\n\nvoid _tmain(int argc, TCHAR *argv[])\n{\n   WIN32_FIND_DATA FindFileData;\n   HANDLE hFind;\n\n   if( argc != 2 )\n   {\n      _tprintf(TEXT(\"Usage: %s [target_file]\\n\"), argv[0]);\n      return;\n   }\n\n   _tprintf (TEXT(\"Target file is %s\\n\"), argv[1]);\n   hFind = FindFirstFile(argv[1], &amp;FindFileData);\n   if (hFind == INVALID_HANDLE_VALUE) \n   {\n      printf (\"FindFirstFile failed (%d)\\n\", GetLastError());\n      return;\n   } \n   else \n   {\n      _tprintf (TEXT(\"The first file found is %s\\n\"), \n                FindFileData.cFileName);\n      FindClose(hFind);\n   }\n}\n",
            "#include &lt;Windows.h&gt;\n\nvector&lt;string&gt; get_all_files_names_within_folder(string folder)\n{\n    vector&lt;string&gt; names;\n    string search_path = folder + \"/*.*\";\n    WIN32_FIND_DATA fd; \n    HANDLE hFind = ::FindFirstFile(search_path.c_str(), &amp;fd); \n    if(hFind != INVALID_HANDLE_VALUE) { \n        do { \n            // read all (real) files in current folder\n            // , delete '!' read other 2 default folder . and ..\n            if(! (fd.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY) ) {\n                names.push_back(fd.cFileName);\n            }\n        }while(::FindNextFile(hFind, &amp;fd)); \n        ::FindClose(hFind); \n    } \n    return names;\n}\n\n*.*\n*.ext",
            "tinydir_dir dir;\ntinydir_open(&amp;dir, \"/path/to/dir\");\n\nwhile (dir.has_next)\n{\n    tinydir_file file;\n    tinydir_readfile(&amp;dir, &amp;file);\n\n    printf(\"%s\", file.name);\n    if (file.is_dir)\n    {\n        printf(\"/\");\n    }\n    printf(\"\\n\");\n\n    tinydir_next(&amp;dir);\n}\n\ntinydir_close(&amp;dir);\n\nreaddir_r\nUNICODE",
            "glob\nvector&lt;string&gt;\n#include &lt;glob.h&gt;\n#include &lt;vector&gt;\nusing std::vector;\n\nvector&lt;string&gt; globVector(const string&amp; pattern){\n    glob_t glob_result;\n    glob(pattern.c_str(),GLOB_TILDE,NULL,&amp;glob_result);\n    vector&lt;string&gt; files;\n    for(unsigned int i=0;i&lt;glob_result.gl_pathc;++i){\n        files.push_back(string(glob_result.gl_pathv[i]));\n    }\n    globfree(&amp;glob_result);\n    return files;\n}\n\nvector&lt;string&gt; files = globVector(\"./*\");\n",
            "#include &lt;stdio.h&gt;\n#include &lt;dirent.h&gt;\n#include &lt;sys/types.h&gt;\n\nint main(int argc, char** argv) { \n    list_dir(&quot;myFolderName&quot;);\n    return EXIT_SUCCESS;\n}  \n\nstatic void list_dir(const char *path) {\n    struct dirent *entry;\n    DIR *dir = opendir(path);\n    if (dir == NULL) {\n        return;\n    }\n\n    while ((entry = readdir(dir)) != NULL) {\n        printf(&quot;%s\\n&quot;,entry-&gt;d_name);\n    }\n\n    closedir(dir);\n}\n\ndirent.h\nstruct dirent {\n    ino_t d_ino; /* inode number */\n    off_t d_off; /* offset to the next dirent */\n    unsigned short d_reclen; /* length of this record */\n    unsigned char d_type; /* type of file */\n    char d_name[256]; /* filename */\n};\n",
            "glob()\n#include &lt;glob.h&gt;\n\nglob_t glob_result;\nglob(\"/your_directory/*\",GLOB_TILDE,NULL,&amp;glob_result);\nfor(unsigned int i=0; i&lt;glob_result.gl_pathc; ++i){\n  cout &lt;&lt; glob_result.gl_pathv[i] &lt;&lt; endl;\n}\n",
            "C++11\nboost::filesystem\n#include &lt;string&gt;\n#include &lt;iostream&gt;\n#include &lt;boost/filesystem.hpp&gt;\nusing namespace std;\nusing namespace boost::filesystem;\n\nint main()\n{\n    path p(\"D:/AnyFolder\");\n    for (auto i = directory_iterator(p); i != directory_iterator(); i++)\n    {\n        if (!is_directory(i-&gt;path())) //we eliminate directories\n        {\n            cout &lt;&lt; i-&gt;path().filename().string() &lt;&lt; endl;\n        }\n        else\n            continue;\n    }\n}\n\nfile1.txt\nfile2.dat\n",
            "foldername\ngetNextFile\nfilename\nwindows.h\nstdio.h\nclass FileGetter{\n    WIN32_FIND_DATAA found; \n    HANDLE hfind;\n    char folderstar[255];       \n    int chk;\n\npublic:\n    FileGetter(char* folder){       \n        sprintf(folderstar,\"%s\\\\*.*\",folder);\n        hfind = FindFirstFileA(folderstar,&amp;found);\n        //skip .\n        FindNextFileA(hfind,&amp;found);        \n    }\n\n    int getNextFile(char* fname){\n        //skips .. when called for the first time\n        chk=FindNextFileA(hfind,&amp;found);\n        if (chk)\n            strcpy(fname, found.cFileName);     \n        return chk;\n    }\n\n};\n",
            "namespace fs = experimental::filesystem;\n#include &lt;string&gt;\n#include &lt;iostream&gt;\n#include &lt;filesystem&gt;\n\nusing namespace std;\nnamespace fs = experimental::filesystem;\n\nint main()\n{\n    string path = \"C:\\\\splits\\\\\";\n    for (auto &amp; p : fs::directory_iterator(path))\n        cout &lt;&lt; p &lt;&lt; endl;\n    int n;\n    cin &gt;&gt; n;\n}\n",
            "#include &lt;string&gt;\n#include &lt;iostream&gt;\n#include &lt;filesystem&gt;\nnamespace fs = std::filesystem;\n\nint main() {\n    std::string path = &quot;/path/to/directory&quot;;\n    for (const auto &amp; entry : fs::directory_iterator(path))\n        std::cout &lt;&lt; entry.path() &lt;&lt; std::endl;\n}\n",
            "char **getKeys(char *data_dir, char* tablename, int *num_keys)\n{\n    char** arr = malloc(MAX_RECORDS_PER_TABLE*sizeof(char*));\nint i = 0;\nfor (;i &lt; MAX_RECORDS_PER_TABLE; i++)\n    arr[i] = malloc( (MAX_KEY_LEN+1) * sizeof(char) );  \n\n\nchar *buf = (char *)malloc( (MAX_KEY_LEN+1)*sizeof(char) );\nsnprintf(buf, MAX_KEY_LEN+1, \"%s/%s\", data_dir, tablename);\n\nDIR* tableDir = opendir(buf);\nstruct dirent* getInfo;\n\nreaddir(tableDir); // ignore '.'\nreaddir(tableDir); // ignore '..'\n\ni = 0;\nwhile(1)\n{\n\n\n    getInfo = readdir(tableDir);\n    if (getInfo == 0)\n        break;\n    strcpy(arr[i++], getInfo-&gt;d_name);\n}\n*(num_keys) = i;\nreturn arr;\n}\n",
            "#include &lt;windows.h&gt;\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nstring wchar_t2string(const wchar_t *wchar)\n{\n    string str = \"\";\n    int index = 0;\n    while(wchar[index] != 0)\n    {\n        str += (char)wchar[index];\n        ++index;\n    }\n    return str;\n}\n\nwchar_t *string2wchar_t(const string &amp;str)\n{\n    wchar_t wchar[260];\n    int index = 0;\n    while(index &lt; str.size())\n    {\n        wchar[index] = (wchar_t)str[index];\n        ++index;\n    }\n    wchar[index] = 0;\n    return wchar;\n}\n\nvector&lt;string&gt; listFilesInDirectory(string directoryName)\n{\n    WIN32_FIND_DATA FindFileData;\n    wchar_t * FileName = string2wchar_t(directoryName);\n    HANDLE hFind = FindFirstFile(FileName, &amp;FindFileData);\n\n    vector&lt;string&gt; listFileNames;\n    listFileNames.push_back(wchar_t2string(FindFileData.cFileName));\n\n    while (FindNextFile(hFind, &amp;FindFileData))\n        listFileNames.push_back(wchar_t2string(FindFileData.cFileName));\n\n    return listFileNames;\n}\n\nvoid main()\n{\n    vector&lt;string&gt; listFiles;\n    listFiles = listFilesInDirectory(\"C:\\\\*.txt\");\n    for each (string str in listFiles)\n        cout &lt;&lt; str &lt;&lt; endl;\n}\n",
            "int exploreDirectory(const char *dirpath, char ***list, int *numItems) {\n    struct dirent **direntList;\n    int i;\n    errno = 0;\n\n    if ((*numItems = scandir(dirpath, &amp;direntList, NULL, alphasort)) == -1)\n        return errno;\n\n    if (!((*list) = malloc(sizeof(char *) * (*numItems)))) {\n        fprintf(stderr, \"Error in list allocation for file list: dirpath=%s.\\n\", dirpath);\n        exit(EXIT_FAILURE);\n    }\n\n    for (i = 0; i &lt; *numItems; i++) {\n        (*list)[i] = stringDuplication(direntList[i]-&gt;d_name);\n    }\n\n    for (i = 0; i &lt; *numItems; i++) {\n        free(direntList[i]);\n    }\n\n    free(direntList);\n\n    return 0;\n}\n",
            "#include &lt;string&gt;\n#include &lt;iostream&gt;\n#include &lt;filesystem&gt;\n\nusing namespace std;\nnamespace fs = filesystem;\nint main()\n{\n    string path = &quot;\\\\path\\\\to\\\\directory&quot;;\n    // string path = &quot;/path/to/directory&quot;;\n    for (auto &amp; p : fs::recursive_directory_iterator(path))\n        cout &lt;&lt; p.path() &lt;&lt; endl;\n}\n\ncl /EHsc /W4 /WX /std:c++17 ListFiles.cpp",
            "system( \"dir /b /s /a-d * &gt; file_names.txt\" );\n",
            "#include &lt;ftw.h&gt;\n\nint AnalizeDirectoryElement (const char *fpath, \n                            const struct stat *sb,\n                            int tflag, \n                            struct FTW *ftwbuf) {\n\n  if (tflag == FTW_F) {\n    std::string strFileName(fpath);\n\n    DoSomethingWith(strFileName);\n  }\n  return 0; \n}\n\nvoid WalkDirectoryTree (const char * pchFileName) {\n\n  int nFlags = 0;\n\n  if (nftw(pchFileName, AnalizeDirectoryElement, 20, nFlags) == -1) {\n    perror(\"nftw\");\n  }\n}\n\nint main() {\n  WalkDirectoryTree(\"some_dir/\");\n}\n",
            "#include &lt;iostream&gt;\n#include &lt;filesystem&gt;\n#include &lt;string&gt;\n#include &lt;direct.h&gt;\nusing namespace std;\nnamespace fs = std::experimental::filesystem;\nvoid ShowListFile(string path)\n{\nfor(auto &amp;p: fs::directory_iterator(path))  /*get directory */\n     cout&lt;&lt;p.path().filename()&lt;&lt;endl;   // get file name\n}\n\nint main() {\n\nShowListFile(\"C:/Users/dell/Pictures/Camera Roll/\");\ngetchar();\nreturn 0;\n}\n",
            "void filefinder()\nmain\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include \"dirent.h\"\n\nstring path = \"C:/folder\"; //Put a valid path here for folder\n\nvoid filefinder()\n{\n    DIR *directory = opendir(path.c_str());\n    struct dirent *direntStruct;\n\n    if (directory != NULL) {\n        while (direntStruct = readdir(directory)) {\n            printf(\"File Name: %s\\n\", direntStruct-&gt;d_name); //If you are using &lt;stdio.h&gt;\n            //std::cout &lt;&lt; direntStruct-&gt;d_name &lt;&lt; std::endl; //If you are using &lt;iostream&gt;\n        }\n    }\n    closedir(directory);\n}\n",
            "std::filesystem::directory_entry\n&lt;&lt;\nstd::cout &lt;&lt; p &lt;&lt; std::endl;\n#include &lt;iostream&gt;\n#include &lt;filesystem&gt;\n#include &lt;string&gt;\nnamespace fs = std::filesystem;\n\nint main() {\n    std::string path = \"/path/to/directory\";\n    for(const auto&amp; p : fs::directory_iterator(path))\n        std::cout &lt;&lt; p.path() &lt;&lt; std::endl;\n}\n\np\nstd::cout &lt;&lt;",
            "#include &lt;algorithm&gt;\n#include &lt;filesystem&gt;\n#include &lt;ranges&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main() {\n    vector&lt;filesystem::path&gt; filePaths;\n    ranges::transform(filesystem::directory_iterator(&quot;.&quot;),     \n    back_inserter(filePaths), [](const auto&amp; dirFile){return dirFile.path();} );\n}\n",
            "#include&lt;io.h&gt;\n#include&lt;iostream.h&gt;\n#include&lt;string&gt;\nusing namespace std;\n\nvoid TraverseFilesUsingDFS(const string&amp; folder_path){\n   _finddata_t file_info;\n   string any_file_pattern = folder_path + \"\\\\*\";\n   intptr_t handle = _findfirst(any_file_pattern.c_str(),&amp;file_info);\n   //If folder_path exsist, using any_file_pattern will find at least two files \".\" and \"..\", \n   //of which \".\" means current dir and \"..\" means parent dir\n   if (handle == -1){\n       cerr &lt;&lt; \"folder path not exist: \" &lt;&lt; folder_path &lt;&lt; endl;\n       exit(-1);\n   }\n   //iteratively check each file or sub_directory in current folder\n   do{\n       string file_name=file_info.name; //from char array to string\n       //check whtether it is a sub direcotry or a file\n       if (file_info.attrib &amp; _A_SUBDIR){\n            if (file_name != \".\" &amp;&amp; file_name != \"..\"){\n               string sub_folder_path = folder_path + \"\\\\\" + file_name;                \n               TraverseFilesUsingDFS(sub_folder_path);\n               cout &lt;&lt; \"a sub_folder path: \" &lt;&lt; sub_folder_path &lt;&lt; endl;\n            }\n       }\n       else\n            cout &lt;&lt; \"file name: \" &lt;&lt; file_name &lt;&lt; endl;\n    } while (_findnext(handle, &amp;file_info) == 0);\n    //\n    _findclose(handle);\n}\n",
            "#include &lt;string&gt;\n#include &lt;Windows.h&gt;\n#include &lt;vector&gt;\n#include &lt;locale&gt;\n#include &lt;codecvt&gt;\n\nstd::vector&lt;std::string&gt; listFilesInDir(std::string path)\n{\n    std::vector&lt;std::string&gt; names;\n    //Convert string to wstring\n    std::wstring search_path = std::wstring_convert&lt;std::codecvt_utf8&lt;wchar_t&gt;&gt;().from_bytes(path);\n    WIN32_FIND_DATA fd;\n    HANDLE hFind = FindFirstFile(search_path.c_str(), &amp;fd);\n    if (hFind != INVALID_HANDLE_VALUE) \n    {\n        do \n        {\n            // read all (real) files in current folder\n            // , delete '!' read other 2 default folder . and ..\n            if (!(fd.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY)) \n            {\n                //convert from wide char to narrow char array\n                char ch[260];\n                char DefChar = ' ';\n                WideCharToMultiByte(CP_ACP, 0, fd.cFileName, -1, ch, 260, &amp;DefChar, NULL);\n                names.push_back(ch);\n            }\n        } \n        while (::FindNextFile(hFind, &amp;fd));\n        ::FindClose(hFind);\n    }\n    return names;\n}\n",
            "#include &lt;vector&gt;\n#include &lt;string&gt;\n#include &lt;algorithm&gt;\n\n#ifdef _WIN32\n#include &lt;windows.h&gt;\nstd::vector&lt;std::string&gt; files_in_directory(std::string path)\n{\n    std::vector&lt;std::string&gt; files;\n\n    // check directory exists\n    char fullpath[MAX_PATH];\n    GetFullPathName(path.c_str(), MAX_PATH, fullpath, 0);\n    std::string fp(fullpath);\n    if (GetFileAttributes(fp.c_str()) != FILE_ATTRIBUTE_DIRECTORY)\n        return files;\n\n    // get file names\n    WIN32_FIND_DATA findfiledata;\n    HANDLE hFind = FindFirstFile((LPCSTR)(fp + &quot;\\\\*&quot;).c_str(), &amp;findfiledata);\n    if (hFind != INVALID_HANDLE_VALUE)\n    {\n        do \n        {\n            files.push_back(findfiledata.cFileName);\n        } \n        while (FindNextFile(hFind, &amp;findfiledata));\n        FindClose(hFind);\n    }\n\n    // delete current and parent directories\n    files.erase(std::find(files.begin(), files.end(), &quot;.&quot;));\n    files.erase(std::find(files.begin(), files.end(), &quot;..&quot;));\n\n    // sort in alphabetical order\n    std::sort(files.begin(), files.end());\n\n    return files;\n}\n#else\n#include &lt;dirent.h&gt;\nstd::vector&lt;std::string&gt; files_in_directory(std::string directory)\n{\n    std::vector&lt;std::string&gt; files;\n\n    // open directory\n    DIR *dir;\n    dir = opendir(directory.c_str());\n    if (dir == NULL)\n        return files;\n\n    // get file names\n    struct dirent *ent;\n    while ((ent = readdir(dir)) != NULL)\n        files.push_back(ent-&gt;d_name);\n    closedir(dir);\n\n    // delete current and parent directories\n    files.erase(std::find(files.begin(), files.end(), &quot;.&quot;));\n    files.erase(std::find(files.begin(), files.end(), &quot;..&quot;));\n\n    // sort in alphabetical order\n    std::sort(files.begin(), files.end());\n\n    return files;\n}\n#endif  // _WIN32\n",
            "#include &lt;bits/stdc++.h&gt;\n#include &lt;dirent.h&gt;\nusing namespace std;\n\nint main(){\n    DIR *dpdf;\n    struct dirent *epdf;\n    dpdf = opendir(&quot;./&quot;);\n    \n    if (dpdf != NULL){\n    while (epdf = readdir(dpdf)){\n        cout &lt;&lt; epdf-&gt;d_name &lt;&lt; std::endl;\n    }\n    }\n    closedir(dpdf);\n    return 0;\n}\n",
            "#include &lt;stdio.h&gt;\n#include &lt;sys/stat.h&gt;\n#include &lt;iostream&gt;\n#include &lt;dirent.h&gt;\n#include &lt;map&gt;\n\nstd::map&lt;int, std::string&gt; getFile(std::string p, std::string e = \"\", unsigned char s = '/'){\n    if ( p.size() &gt; 0 ){\n        if (p.back() != s) p += s;\n    }\n    if ( e.size() &gt; 0 ){\n        if ( e.at(0) != '.' &amp;&amp; !(e.size() == 1 &amp;&amp; e.at(0) == '*') ) e = \".\" + e;\n    }\n\n    DIR *dir;\n    struct dirent *ent;\n    struct stat sb;\n    std::map&lt;int, std::string&gt; r = {{999, \"FAILED\"}};\n    std::string temp;\n    int f = 0;\n    bool fd;\n\n    if ( (dir = opendir(p.c_str())) != NULL ){\n        r.erase (999);\n        while ((ent = readdir (dir)) != NULL){\n            temp = ent-&gt;d_name;\n            fd = temp.find(\".\") != std::string::npos? true : false;\n            temp = p + temp;\n\n            if (stat(temp.c_str(), &amp;sb) == 0 &amp;&amp; S_ISREG(sb.st_mode)){\n                if ( e.size() == 1 &amp;&amp; e.at(0) == '*' ){\n                    r[f] = temp;\n                    f++;\n                } else {\n                    if (e.size() == 0){\n                        if ( fd == false ){\n                            r[f] = temp;\n                            f++;\n                        }\n                        continue;\n                    }\n\n                    if (e.size() &gt; temp.size()) continue;\n\n                    if ( temp.substr(temp.size() - e.size()) == e ){\n                        r[f] = temp;\n                        f++;\n                    }\n                }\n            }\n        }\n\n        closedir(dir);\n        return r;\n    } else {\n        return r;\n    }\n}\n\nvoid printMap(auto &amp;m){\n    for (const auto &amp;p : m) {\n        std::cout &lt;&lt; \"m[\" &lt;&lt; p.first &lt;&lt; \"] = \" &lt;&lt; p.second &lt;&lt; std::endl;\n    }\n}\n\nint main(){\n    std::map&lt;int, std::string&gt; k = getFile(\"./\", \"\");\n    printMap(k);\n    return 0;\n}\n",
            "#include&lt;iostream&gt;\n#include &lt;dirent.h&gt;\nusing namespace std;\nchar ROOT[]={'.'};\n\nvoid listfiles(char* path){\n    DIR * dirp = opendir(path);\n    dirent * dp;\n    while ( (dp = readdir(dirp)) !=NULL ) {\n         cout &lt;&lt; dp-&gt;d_name &lt;&lt; \" size \" &lt;&lt; dp-&gt;d_reclen&lt;&lt;std::endl;\n    }\n    (void)closedir(dirp);\n}\n\nint main(int argc, char **argv)\n{\n    char* path;\n    if (argc&gt;1) path=argv[1]; else path=ROOT;\n\n    cout&lt;&lt;\"list files in [\"&lt;&lt;path&lt;&lt;\"]\"&lt;&lt;std::endl;\n    listfiles(path);\n\n    return 0;\n}\n"
        ]
    },
    {
        "question_id": 63166,
        "question_code": "",
        "answer_code_snippets": [
            "#include &quot;windows.h&quot;\n\nMEMORYSTATUSEX memInfo;\nmemInfo.dwLength = sizeof(MEMORYSTATUSEX);\nGlobalMemoryStatusEx(&amp;memInfo);\nDWORDLONG totalVirtualMem = memInfo.ullTotalPageFile;\n\n DWORDLONG virtualMemUsed = memInfo.ullTotalPageFile - memInfo.ullAvailPageFile;\n\n#include &quot;windows.h&quot;\n#include &quot;psapi.h&quot;\n\nPROCESS_MEMORY_COUNTERS_EX pmc;\nGetProcessMemoryInfo(GetCurrentProcess(), (PROCESS_MEMORY_COUNTERS*)&amp;pmc, sizeof(pmc));\nSIZE_T virtualMemUsedByMe = pmc.PrivateUsage;\n\nDWORDLONG totalPhysMem = memInfo.ullTotalPhys;\n\nDWORDLONG physMemUsed = memInfo.ullTotalPhys - memInfo.ullAvailPhys;\n\nSIZE_T physMemUsedByMe = pmc.WorkingSetSize;\n\n#include &quot;TCHAR.h&quot;\n#include &quot;pdh.h&quot;\n\nstatic PDH_HQUERY cpuQuery;\nstatic PDH_HCOUNTER cpuTotal;\n\nvoid init(){\n    PdhOpenQuery(NULL, NULL, &amp;cpuQuery);\n    // You can also use L&quot;\\\\Processor(*)\\\\% Processor Time&quot; and get individual CPU values with PdhGetFormattedCounterArray()\n    PdhAddEnglishCounter(cpuQuery, L&quot;\\\\Processor(_Total)\\\\% Processor Time&quot;, NULL, &amp;cpuTotal);\n    PdhCollectQueryData(cpuQuery);\n}\n\ndouble getCurrentValue(){\n    PDH_FMT_COUNTERVALUE counterVal;\n\n    PdhCollectQueryData(cpuQuery);\n    PdhGetFormattedCounterValue(cpuTotal, PDH_FMT_DOUBLE, NULL, &amp;counterVal);\n    return counterVal.doubleValue;\n}\n\n#include &quot;windows.h&quot;\n\nstatic ULARGE_INTEGER lastCPU, lastSysCPU, lastUserCPU;\nstatic int numProcessors;\nstatic HANDLE self;\n\nvoid init(){\n    SYSTEM_INFO sysInfo;\n    FILETIME ftime, fsys, fuser;\n\n    GetSystemInfo(&amp;sysInfo);\n    numProcessors = sysInfo.dwNumberOfProcessors;\n\n    GetSystemTimeAsFileTime(&amp;ftime);\n    memcpy(&amp;lastCPU, &amp;ftime, sizeof(FILETIME));\n\n    self = GetCurrentProcess();\n    GetProcessTimes(self, &amp;ftime, &amp;ftime, &amp;fsys, &amp;fuser);\n    memcpy(&amp;lastSysCPU, &amp;fsys, sizeof(FILETIME));\n    memcpy(&amp;lastUserCPU, &amp;fuser, sizeof(FILETIME));\n}\n\ndouble getCurrentValue(){\n    FILETIME ftime, fsys, fuser;\n    ULARGE_INTEGER now, sys, user;\n    double percent;\n\n    GetSystemTimeAsFileTime(&amp;ftime);\n    memcpy(&amp;now, &amp;ftime, sizeof(FILETIME));\n\n    GetProcessTimes(self, &amp;ftime, &amp;ftime, &amp;fsys, &amp;fuser);\n    memcpy(&amp;sys, &amp;fsys, sizeof(FILETIME));\n    memcpy(&amp;user, &amp;fuser, sizeof(FILETIME));\n    percent = (sys.QuadPart - lastSysCPU.QuadPart) +\n        (user.QuadPart - lastUserCPU.QuadPart);\n    percent /= (now.QuadPart - lastCPU.QuadPart);\n    percent /= numProcessors;\n    lastCPU = now;\n    lastUserCPU = user;\n    lastSysCPU = sys;\n\n    return percent * 100;\n}\n\ngetrusage()\n/proc\n#include &quot;sys/types.h&quot;\n#include &quot;sys/sysinfo.h&quot;\n\nstruct sysinfo memInfo;\n\nsysinfo (&amp;memInfo);\nlong long totalVirtualMem = memInfo.totalram;\n//Add other values in next statement to avoid int overflow on right hand side...\ntotalVirtualMem += memInfo.totalswap;\ntotalVirtualMem *= memInfo.mem_unit;\n\nlong long virtualMemUsed = memInfo.totalram - memInfo.freeram;\n//Add other values in next statement to avoid int overflow on right hand side...\nvirtualMemUsed += memInfo.totalswap - memInfo.freeswap;\nvirtualMemUsed *= memInfo.mem_unit;\n\n#include &quot;stdlib.h&quot;\n#include &quot;stdio.h&quot;\n#include &quot;string.h&quot;\n\nint parseLine(char* line){\n    // This assumes that a digit will be found and the line ends in &quot; Kb&quot;.\n    int i = strlen(line);\n    const char* p = line;\n    while (*p &lt;'0' || *p &gt; '9') p++;\n    line[i-3] = '\\0';\n    i = atoi(p);\n    return i;\n}\n\nint getValue(){ //Note: this value is in KB!\n    FILE* file = fopen(&quot;/proc/self/status&quot;, &quot;r&quot;);\n    int result = -1;\n    char line[128];\n\n    while (fgets(line, 128, file) != NULL){\n        if (strncmp(line, &quot;VmSize:&quot;, 7) == 0){\n            result = parseLine(line);\n            break;\n        }\n    }\n    fclose(file);\n    return result;\n}\n\nlong long totalPhysMem = memInfo.totalram;\n//Multiply in next statement to avoid int overflow on right hand side...\ntotalPhysMem *= memInfo.mem_unit;\n\nlong long physMemUsed = memInfo.totalram - memInfo.freeram;\n//Multiply in next statement to avoid int overflow on right hand side...\nphysMemUsed *= memInfo.mem_unit;\n\nint getValue(){ //Note: this value is in KB!\n    FILE* file = fopen(&quot;/proc/self/status&quot;, &quot;r&quot;);\n    int result = -1;\n    char line[128];\n\n    while (fgets(line, 128, file) != NULL){\n        if (strncmp(line, &quot;VmRSS:&quot;, 6) == 0){\n            result = parseLine(line);\n            break;\n        }\n    }\n    fclose(file);\n    return result;\n}\n\n#include &quot;stdlib.h&quot;\n#include &quot;stdio.h&quot;\n#include &quot;string.h&quot;\n\nstatic unsigned long long lastTotalUser, lastTotalUserLow, lastTotalSys, lastTotalIdle;\n\nvoid init(){\n    FILE* file = fopen(&quot;/proc/stat&quot;, &quot;r&quot;);\n    fscanf(file, &quot;cpu %llu %llu %llu %llu&quot;, &amp;lastTotalUser, &amp;lastTotalUserLow,\n        &amp;lastTotalSys, &amp;lastTotalIdle);\n    fclose(file);\n}\n\ndouble getCurrentValue(){\n    double percent;\n    FILE* file;\n    unsigned long long totalUser, totalUserLow, totalSys, totalIdle, total;\n\n    file = fopen(&quot;/proc/stat&quot;, &quot;r&quot;);\n    fscanf(file, &quot;cpu %llu %llu %llu %llu&quot;, &amp;totalUser, &amp;totalUserLow,\n        &amp;totalSys, &amp;totalIdle);\n    fclose(file);\n\n    if (totalUser &lt; lastTotalUser || totalUserLow &lt; lastTotalUserLow ||\n        totalSys &lt; lastTotalSys || totalIdle &lt; lastTotalIdle){\n        //Overflow detection. Just skip this value.\n        percent = -1.0;\n    }\n    else{\n        total = (totalUser - lastTotalUser) + (totalUserLow - lastTotalUserLow) +\n            (totalSys - lastTotalSys);\n        percent = total;\n        total += (totalIdle - lastTotalIdle);\n        percent /= total;\n        percent *= 100;\n    }\n\n    lastTotalUser = totalUser;\n    lastTotalUserLow = totalUserLow;\n    lastTotalSys = totalSys;\n    lastTotalIdle = totalIdle;\n\n    return percent;\n}\n\n#include &quot;stdlib.h&quot;\n#include &quot;stdio.h&quot;\n#include &quot;string.h&quot;\n#include &quot;sys/times.h&quot;\n#include &quot;sys/vtimes.h&quot;\n\nstatic clock_t lastCPU, lastSysCPU, lastUserCPU;\nstatic int numProcessors;\n\nvoid init(){\n    FILE* file;\n    struct tms timeSample;\n    char line[128];\n\n    lastCPU = times(&amp;timeSample);\n    lastSysCPU = timeSample.tms_stime;\n    lastUserCPU = timeSample.tms_utime;\n\n    file = fopen(&quot;/proc/cpuinfo&quot;, &quot;r&quot;);\n    numProcessors = 0;\n    while(fgets(line, 128, file) != NULL){\n        if (strncmp(line, &quot;processor&quot;, 9) == 0) numProcessors++;\n    }\n    fclose(file);\n}\n\ndouble getCurrentValue(){\n    struct tms timeSample;\n    clock_t now;\n    double percent;\n\n    now = times(&amp;timeSample);\n    if (now &lt;= lastCPU || timeSample.tms_stime &lt; lastSysCPU ||\n        timeSample.tms_utime &lt; lastUserCPU){\n        //Overflow detection. Just skip this value.\n        percent = -1.0;\n    }\n    else{\n        percent = (timeSample.tms_stime - lastSysCPU) +\n            (timeSample.tms_utime - lastUserCPU);\n        percent /= (now - lastCPU);\n        percent /= numProcessors;\n        percent *= 100;\n    }\n    lastCPU = now;\n    lastSysCPU = timeSample.tms_stime;\n    lastUserCPU = timeSample.tms_utime;\n\n    return percent;\n}\n\ngetrusage()",
            "struct statfs stats;\nif (0 == statfs(&quot;/&quot;, &amp;stats))\n{\n    myFreeSwap = (uint64_t)stats.f_bsize * stats.f_bfree;\n}\n\nsysctl -n vm.swapusage\nvm.swapusage: total = 3072.00M  used = 2511.78M  free = 560.22M  (encrypted)\n\nxsw_usage vmusage = {0};\nsize_t size = sizeof(vmusage);\nif( sysctlbyname(&quot;vm.swapusage&quot;, &amp;vmusage, &amp;size, NULL, 0)!=0 )\n{\n   perror( &quot;unable to get swap usage by calling sysctlbyname(\\&quot;vm.swapusage\\&quot;,...)&quot; );\n}\n\ntask_info\n#include&lt;mach/mach.h&gt;\n\nstruct task_basic_info t_info;\nmach_msg_type_number_t t_info_count = TASK_BASIC_INFO_COUNT;\n\nif (KERN_SUCCESS != task_info(mach_task_self(),\n                              TASK_BASIC_INFO, (task_info_t)&amp;t_info,\n                              &amp;t_info_count))\n{\n    return -1;\n}\n// resident size is in t_info.resident_size;\n// virtual size is in t_info.virtual_size;\n\nsysctl\n#include &lt;sys/types.h&gt;\n#include &lt;sys/sysctl.h&gt;\n...\nint mib[2];\nint64_t physical_memory;\nmib[0] = CTL_HW;\nmib[1] = HW_MEMSIZE;\nlength = sizeof(int64_t);\nsysctl(mib, 2, &amp;physical_memory, &amp;length, NULL, 0);\n\nhost_statistics\n#include &lt;mach/vm_statistics.h&gt;\n#include &lt;mach/mach_types.h&gt;\n#include &lt;mach/mach_init.h&gt;\n#include &lt;mach/mach_host.h&gt;\n\nint main(int argc, const char * argv[]) {\n    vm_size_t page_size;\n    mach_port_t mach_port;\n    mach_msg_type_number_t count;\n    vm_statistics64_data_t vm_stats;\n\n    mach_port = mach_host_self();\n    count = sizeof(vm_stats) / sizeof(natural_t);\n    if (KERN_SUCCESS == host_page_size(mach_port, &amp;page_size) &amp;&amp;\n        KERN_SUCCESS == host_statistics64(mach_port, HOST_VM_INFO,\n                                        (host_info64_t)&amp;vm_stats, &amp;count))\n    {\n        long long free_memory = (int64_t)vm_stats.free_count * (int64_t)page_size;\n\n        long long used_memory = ((int64_t)vm_stats.active_count +\n                                 (int64_t)vm_stats.inactive_count +\n                                 (int64_t)vm_stats.wire_count) *  (int64_t)page_size;\n        printf(&quot;free memory: %lld\\nused memory: %lld\\n&quot;, free_memory, used_memory);\n    }\n\n    return 0;\n}\n",
            "Anderson cxc # more /proc/meminfo\nMemTotal:      4083948 kB\nMemFree:       2198520 kB\nBuffers:         82080 kB\nCached:        1141460 kB\nSwapCached:          0 kB\nActive:        1137960 kB\nInactive:       608588 kB\nHighTotal:     3276672 kB\nHighFree:      1607744 kB\nLowTotal:       807276 kB\nLowFree:        590776 kB\nSwapTotal:     2096440 kB\nSwapFree:      2096440 kB\nDirty:              32 kB\nWriteback:           0 kB\nAnonPages:      523252 kB\nMapped:          93560 kB\nSlab:            52880 kB\nSReclaimable:    24652 kB\nSUnreclaim:      28228 kB\nPageTables:       2284 kB\nNFS_Unstable:        0 kB\nBounce:              0 kB\nCommitLimit:   4138412 kB\nCommitted_AS:  1845072 kB\nVmallocTotal:   118776 kB\nVmallocUsed:      3964 kB\nVmallocChunk:   112860 kB\nHugePages_Total:     0\nHugePages_Free:      0\nHugePages_Rsvd:      0\nHugepagesize:     2048 kB\n\nAnderson cxc #  more /proc/stat\ncpu  2329889 0 2364567 1063530460 9034 9463 96111 0\ncpu0 572526 0 636532 265864398 2928 1621 6899 0\ncpu1 590441 0 531079 265949732 4763 351 8522 0\ncpu2 562983 0 645163 265796890 682 7490 71650 0\ncpu3 603938 0 551790 265919440 660 0 9040 0\nintr 37124247\nctxt 50795173133\nbtime 1218807985\nprocesses 116889\nprocs_running 1\nprocs_blocked 0\n\ncpu  2330047 0 2365006 1063853632 9035 9463 96114 0\n\ncpu  2330047 0 2365007 1063854028 9035 9463 96114 0\n\n19340 (whatever) S 19115 19115 3084 34816 19115 4202752 118200 607 0 0 770 384 2\n 7 20 0 77 0 266764385 692477952 105074 4294967295 134512640 146462952 321468364\n8 3214683328 4294960144 0 2147221247 268439552 1276 4294967295 0 0 17 0 0 0 0\n\nName:   whatever\nState:  S (sleeping)\nTgid:   19340\nPid:    19340\nPPid:   19115\nTracerPid:      0\nUid:    0       0       0       0\nGid:    0       0       0       0\nFDSize: 256\nGroups: 0 1 2 3 4 6 10 11 20 26 27\nVmPeak:   676252 kB\nVmSize:   651352 kB\nVmLck:         0 kB\nVmHWM:    420300 kB\nVmRSS:    420296 kB\nVmData:   581028 kB\nVmStk:       112 kB\nVmExe:     11672 kB\nVmLib:     76608 kB\nVmPTE:      1244 kB\nThreads:        77\nSigQ:   0/36864\nSigPnd: 0000000000000000\nShdPnd: 0000000000000000\nSigBlk: fffffffe7ffbfeff\nSigIgn: 0000000010001000\nSigCgt: 20000001800004fc\nCapInh: 0000000000000000\nCapPrm: 00000000ffffffff\nCapEff: 00000000fffffeff\nCpus_allowed:   0f\nMems_allowed:   1\nvoluntary_ctxt_switches:        6518\nnonvoluntary_ctxt_switches:     6598\n",
            "sysinfo\n   #include &lt;sys/sysinfo.h&gt;\n\n   int sysinfo(struct sysinfo *info);\n\n   Until Linux 2.3.16, sysinfo() used to return information in the\n   following structure:\n\n       struct sysinfo {\n           long uptime;             /* Seconds since boot */\n           unsigned long loads[3];  /* 1, 5, and 15 minute load averages */\n           unsigned long totalram;  /* Total usable main memory size */\n           unsigned long freeram;   /* Available memory size */\n           unsigned long sharedram; /* Amount of shared memory */\n           unsigned long bufferram; /* Memory used by buffers */\n           unsigned long totalswap; /* Total swap space size */\n           unsigned long freeswap;  /* swap space still available */\n           unsigned short procs;    /* Number of current processes */\n           char _f[22];             /* Pads structure to 64 bytes */\n       };\n\n   and the sizes were given in bytes.\n\n   Since Linux 2.3.23 (i386), 2.3.48 (all architectures) the structure\n   is:\n\n       struct sysinfo {\n           long uptime;             /* Seconds since boot */\n           unsigned long loads[3];  /* 1, 5, and 15 minute load averages */\n           unsigned long totalram;  /* Total usable main memory size */\n           unsigned long freeram;   /* Available memory size */\n           unsigned long sharedram; /* Amount of shared memory */\n           unsigned long bufferram; /* Memory used by buffers */\n           unsigned long totalswap; /* Total swap space size */\n           unsigned long freeswap;  /* swap space still available */\n           unsigned short procs;    /* Number of current processes */\n           unsigned long totalhigh; /* Total high memory size */\n           unsigned long freehigh;  /* Available high memory size */\n           unsigned int mem_unit;   /* Memory unit size in bytes */\n           char _f[20-2*sizeof(long)-sizeof(int)]; /* Padding to 64 bytes */\n       };\n\n   and the sizes are given as multiples of mem_unit bytes.\n",
            "#include &lt;windows.h&gt;\n#include &lt;stdio.h&gt;\n\n//------------------------------------------------------------------------------------------------------------------\n// Prototype(s)...\n//------------------------------------------------------------------------------------------------------------------\nCHAR cpuusage(void);\n\n//-----------------------------------------------------\ntypedef BOOL ( __stdcall * pfnGetSystemTimes)( LPFILETIME lpIdleTime, LPFILETIME lpKernelTime, LPFILETIME lpUserTime );\nstatic pfnGetSystemTimes s_pfnGetSystemTimes = NULL;\n\nstatic HMODULE s_hKernel = NULL;\n//-----------------------------------------------------\nvoid GetSystemTimesAddress()\n{\n    if(s_hKernel == NULL)\n    {\n        s_hKernel = LoadLibrary(L&quot;Kernel32.dll&quot;);\n        if(s_hKernel != NULL)\n        {\n            s_pfnGetSystemTimes = (pfnGetSystemTimes)GetProcAddress(s_hKernel, &quot;GetSystemTimes&quot;);\n            if(s_pfnGetSystemTimes == NULL)\n            {\n                FreeLibrary(s_hKernel);\n                s_hKernel = NULL;\n            }\n        }\n    }\n}\n//----------------------------------------------------------------------------------------------------------------\n\n//----------------------------------------------------------------------------------------------------------------\n// cpuusage(void)\n// ==============\n// Return a CHAR value in the range 0 - 100 representing actual CPU usage in percent.\n//----------------------------------------------------------------------------------------------------------------\nCHAR cpuusage()\n{\n    FILETIME               ft_sys_idle;\n    FILETIME               ft_sys_kernel;\n    FILETIME               ft_sys_user;\n\n    ULARGE_INTEGER         ul_sys_idle;\n    ULARGE_INTEGER         ul_sys_kernel;\n    ULARGE_INTEGER         ul_sys_user;\n\n    static ULARGE_INTEGER     ul_sys_idle_old;\n    static ULARGE_INTEGER  ul_sys_kernel_old;\n    static ULARGE_INTEGER  ul_sys_user_old;\n\n    CHAR usage = 0;\n\n    // We cannot directly use GetSystemTimes in the C language\n    /* Add this line :: pfnGetSystemTimes */\n    s_pfnGetSystemTimes(&amp;ft_sys_idle,    /* System idle time */\n        &amp;ft_sys_kernel,  /* system kernel time */\n        &amp;ft_sys_user);   /* System user time */\n\n    CopyMemory(&amp;ul_sys_idle  , &amp;ft_sys_idle  , sizeof(FILETIME)); // Could been optimized away...\n    CopyMemory(&amp;ul_sys_kernel, &amp;ft_sys_kernel, sizeof(FILETIME)); // Could been optimized away...\n    CopyMemory(&amp;ul_sys_user  , &amp;ft_sys_user  , sizeof(FILETIME)); // Could been optimized away...\n\n    usage  =\n        (\n        (\n        (\n        (\n        (ul_sys_kernel.QuadPart - ul_sys_kernel_old.QuadPart)+\n        (ul_sys_user.QuadPart   - ul_sys_user_old.QuadPart)\n        )\n        -\n        (ul_sys_idle.QuadPart-ul_sys_idle_old.QuadPart)\n        )\n        *\n        (100)\n        )\n        /\n        (\n        (ul_sys_kernel.QuadPart - ul_sys_kernel_old.QuadPart)+\n        (ul_sys_user.QuadPart   - ul_sys_user_old.QuadPart)\n        )\n        );\n\n    ul_sys_idle_old.QuadPart   = ul_sys_idle.QuadPart;\n    ul_sys_user_old.QuadPart   = ul_sys_user.QuadPart;\n    ul_sys_kernel_old.QuadPart = ul_sys_kernel.QuadPart;\n\n    return usage;\n}\n\n\n//------------------------------------------------------------------------------------------------------------------\n// Entry point\n//------------------------------------------------------------------------------------------------------------------\nint main(void)\n{\n    int n;\n    GetSystemTimesAddress();\n    for(n=0; n&lt;20; n++)\n    {\n        printf(&quot;CPU Usage: %3d%%\\r&quot;, cpuusage());\n        Sleep(2000);\n    }\n    printf(&quot;\\n&quot;);\n    return 0;\n}\n",
            "#include &lt;mach/mach_init.h&gt;\n#include &lt;mach/mach_error.h&gt;\n#include &lt;mach/mach_host.h&gt;\n#include &lt;mach/vm_map.h&gt;\n\nstatic unsigned long long _previousTotalTicks = 0;\nstatic unsigned long long _previousIdleTicks = 0;\n\n// Returns 1.0f for &quot;CPU fully pinned&quot;, 0.0f for &quot;CPU idle&quot;, or somewhere in between\n// You'll need to call this at regular intervals, since it measures the load between\n// the previous call and the current one.\nfloat GetCPULoad()\n{\n   host_cpu_load_info_data_t cpuinfo;\n   mach_msg_type_number_t count = HOST_CPU_LOAD_INFO_COUNT;\n   if (host_statistics(mach_host_self(), HOST_CPU_LOAD_INFO, (host_info_t)&amp;cpuinfo, &amp;count) == KERN_SUCCESS)\n   {\n      unsigned long long totalTicks = 0;\n      for(int i=0; i&lt;CPU_STATE_MAX; i++) totalTicks += cpuinfo.cpu_ticks[i];\n      return CalculateCPULoad(cpuinfo.cpu_ticks[CPU_STATE_IDLE], totalTicks);\n   }\n   else return -1.0f;\n}\n\nfloat CalculateCPULoad(unsigned long long idleTicks, unsigned long long totalTicks)\n{\n  unsigned long long totalTicksSinceLastTime = totalTicks-_previousTotalTicks;\n  unsigned long long idleTicksSinceLastTime  = idleTicks-_previousIdleTicks;\n  float ret = 1.0f-((totalTicksSinceLastTime &gt; 0) ? ((float)idleTicksSinceLastTime)/totalTicksSinceLastTime : 0);\n  _previousTotalTicks = totalTicks;\n  _previousIdleTicks  = idleTicks;\n  return ret;\n}\n",
            "#include &lt;atomic.h&gt;\n#include &lt;libc.h&gt;\n#include &lt;pthread.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#include &lt;sys/iofunc.h&gt;\n#include &lt;sys/neutrino.h&gt;\n#include &lt;sys/resmgr.h&gt;\n#include &lt;sys/syspage.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;inttypes.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;sys/types.h&gt;\n#include &lt;sys/debug.h&gt;\n#include &lt;sys/procfs.h&gt;\n#include &lt;sys/syspage.h&gt;\n#include &lt;sys/neutrino.h&gt;\n#include &lt;sys/time.h&gt;\n#include &lt;time.h&gt;\n#include &lt;fcntl.h&gt;\n#include &lt;devctl.h&gt;\n#include &lt;errno.h&gt;\n\n#define MAX_CPUS 32\n\nstatic float Loads[MAX_CPUS];\nstatic _uint64 LastSutime[MAX_CPUS];\nstatic _uint64 LastNsec[MAX_CPUS];\nstatic int ProcFd = -1;\nstatic int NumCpus = 0;\n\n\nint find_ncpus(void) {\n    return NumCpus;\n}\n\nint get_cpu(int cpu) {\n    int ret;\n    ret = (int)Loads[ cpu % MAX_CPUS ];\n    ret = max(0,ret);\n    ret = min(100,ret);\n    return( ret );\n}\n\nstatic _uint64 nanoseconds( void ) {\n    _uint64 sec, usec;\n    struct timeval tval;\n    gettimeofday( &amp;tval, NULL );\n    sec = tval.tv_sec;\n    usec = tval.tv_usec;\n    return( ( ( sec * 1000000 ) + usec ) * 1000 );\n}\n\nint sample_cpus( void ) {\n    int i;\n    debug_thread_t debug_data;\n    _uint64 current_nsec, sutime_delta, time_delta;\n    memset( &amp;debug_data, 0, sizeof( debug_data ) );\n    \n    for( i=0; i&lt;NumCpus; i++ ) {\n        /* Get the sutime of the idle thread #i+1 */\n        debug_data.tid = i + 1;\n        devctl( ProcFd, DCMD_PROC_TIDSTATUS,\n        &amp;debug_data, sizeof( debug_data ), NULL );\n        /* Get the current time */\n        current_nsec = nanoseconds();\n        /* Get the deltas between now and the last samples */\n        sutime_delta = debug_data.sutime - LastSutime[i];\n        time_delta = current_nsec - LastNsec[i];\n        /* Figure out the load */\n        Loads[i] = 100.0 - ( (float)( sutime_delta * 100 ) / (float)time_delta );\n        /* Flat out strange rounding issues. */\n        if( Loads[i] &lt; 0 ) {\n            Loads[i] = 0;\n        }\n        /* Keep these for reference in the next cycle */\n        LastNsec[i] = current_nsec;\n        LastSutime[i] = debug_data.sutime;\n    }\n    return EOK;\n}\n\nint init_cpu( void ) {\n    int i;\n    debug_thread_t debug_data;\n    memset( &amp;debug_data, 0, sizeof( debug_data ) );\n/* Open a connection to proc to talk over.*/\n    ProcFd = open( &quot;/proc/1/as&quot;, O_RDONLY );\n    if( ProcFd == -1 ) {\n        fprintf( stderr, &quot;pload: Unable to access procnto: %s\\n&quot;,strerror( errno ) );\n        fflush( stderr );\n        return -1;\n    }\n    i = fcntl(ProcFd,F_GETFD);\n    if(i != -1){\n        i |= FD_CLOEXEC;\n        if(fcntl(ProcFd,F_SETFD,i) != -1){\n            /* Grab this value */\n            NumCpus = _syspage_ptr-&gt;num_cpu;\n            /* Get a starting point for the comparisons */\n            for( i=0; i&lt;NumCpus; i++ ) {\n                /*\n                * the sutime of idle thread is how much\n                * time that thread has been using, we can compare this\n                * against how much time has passed to get an idea of the\n                * load on the system.\n                */\n                debug_data.tid = i + 1;\n                devctl( ProcFd, DCMD_PROC_TIDSTATUS, &amp;debug_data, sizeof( debug_data ), NULL );\n                LastSutime[i] = debug_data.sutime;\n                LastNsec[i] = nanoseconds();\n            }\n            return(EOK);\n        }\n    }\n    close(ProcFd);\n    return(-1);\n}\n\nvoid close_cpu(void){\n    if(ProcFd != -1){\n        close(ProcFd);\n        ProcFd = -1;\n    }\n}\n\nint main(int argc, char* argv[]){\n    int i,j;\n    init_cpu();\n    printf(&quot;System has: %d CPUs\\n&quot;, NumCpus);\n    for(i=0; i&lt;20; i++) {\n        sample_cpus();\n        for(j=0; j&lt;NumCpus;j++)\n        printf(&quot;CPU #%d: %f\\n&quot;, j, Loads[j]);\n        sleep(1);\n    }\n    close_cpu();\n}\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;errno.h&gt;\n#include &lt;err.h&gt;\n#include &lt;sys/stat.h&gt;\n#include &lt;sys/types.h&gt;\n\nint main( int argc, char *argv[] ){\n    struct stat statbuf;\n    paddr_t freemem;\n    stat( &quot;/proc&quot;, &amp;statbuf );\n    freemem = (paddr_t)statbuf.st_size;\n    printf( &quot;Free memory: %d bytes\\n&quot;, freemem );\n    printf( &quot;Free memory: %d KB\\n&quot;, freemem / 1024 );\n    printf( &quot;Free memory: %d MB\\n&quot;, freemem / ( 1024 * 1024 ) );\n    return 0;\n} \n",
            "/proc/[pid]/statm\n\n    Provides information about memory usage, measured in pages.\n    The columns are:\n\n        size       (1) total program size\n                   (same as VmSize in /proc/[pid]/status)\n        resident   (2) resident set size\n                   (same as VmRSS in /proc/[pid]/status)\n        shared     (3) number of resident shared pages (i.e., backed by a file)\n                   (same as RssFile+RssShmem in /proc/[pid]/status)\n        text       (4) text (code)\n        lib        (5) library (unused since Linux 2.6; always 0)\n        data       (6) data + stack\n        dt         (7) dirty pages (unused since Linux 2.6; always 0)\n",
            "static HANDLE self;\nstatic int numProcessors;\nSYSTEM_INFO sysInfo;\n\ndouble percent;\n\nnumProcessors = sysInfo.dwNumberOfProcessors;\n\n//Getting system times information\nFILETIME SysidleTime;\nFILETIME SyskernelTime; \nFILETIME SysuserTime; \nULARGE_INTEGER SyskernelTimeInt, SysuserTimeInt;\nGetSystemTimes(&amp;SysidleTime, &amp;SyskernelTime, &amp;SysuserTime);\nmemcpy(&amp;SyskernelTimeInt, &amp;SyskernelTime, sizeof(FILETIME));\nmemcpy(&amp;SysuserTimeInt, &amp;SysuserTime, sizeof(FILETIME));\n__int64 denomenator = SysuserTimeInt.QuadPart + SyskernelTimeInt.QuadPart;  \n\n//Getting process times information\nFILETIME ProccreationTime, ProcexitTime, ProcKernelTime, ProcUserTime;\nULARGE_INTEGER ProccreationTimeInt, ProcexitTimeInt, ProcKernelTimeInt, ProcUserTimeInt;\nGetProcessTimes(self, &amp;ProccreationTime, &amp;ProcexitTime, &amp;ProcKernelTime, &amp;ProcUserTime);\nmemcpy(&amp;ProcKernelTimeInt, &amp;ProcKernelTime, sizeof(FILETIME));\nmemcpy(&amp;ProcUserTimeInt, &amp;ProcUserTime, sizeof(FILETIME));\n__int64 numerator = ProcUserTimeInt.QuadPart + ProcKernelTimeInt.QuadPart;\n//QuadPart represents a 64-bit signed integer (ULARGE_INTEGER)\n\npercent = 100*(numerator/denomenator);\n"
        ]
    },
    {
        "question_id": 199333,
        "question_code": "unsigned long b, c, c_test;\n...\nc_test=c*b;         // Possible overflow\nif (c_test/b != c) {/* There has been an overflow*/}\nelse c=c_test;      // No overflow\n\nint",
        "answer_code_snippets": [
            "#include &lt;limits.h&gt;\n\nint a = &lt;something&gt;;\nint x = &lt;something&gt;;\na += x;              /* UB */\nif (a &lt; 0) {         /* Unreliable test */\n  /* ... */\n}\n\n// For addition\n#include &lt;limits.h&gt;\n\nint a = &lt;something&gt;;\nint x = &lt;something&gt;;\nif (x &gt; 0 &amp;&amp; a &gt; INT_MAX - x) // `a + x` would overflow\nif (x &lt; 0 &amp;&amp; a &lt; INT_MIN - x) // `a + x` would underflow\n\n// For subtraction\n#include &lt;limits.h&gt;\nint a = &lt;something&gt;;\nint x = &lt;something&gt;;\nif (x &lt; 0 &amp;&amp; a &gt; INT_MAX + x) // `a - x` would overflow\nif (x &gt; 0 &amp;&amp; a &lt; INT_MIN + x) // `a - x` would underflow\n\n// For multiplication\n#include &lt;limits.h&gt;\n\nint a = &lt;something&gt;;\nint x = &lt;something&gt;;\n// There may be a need to check for -1 for two's complement machines.\n// If one number is -1 and another is INT_MIN, multiplying them we get abs(INT_MIN) which is 1 higher than INT_MAX\nif (a == -1 &amp;&amp; x == INT_MIN) // `a * x` can overflow\nif (x == -1 &amp;&amp; a == INT_MIN) // `a * x` (or `a / x`) can overflow\n// general case\nif (x != 0 &amp;&amp; a &gt; INT_MAX / x) // `a * x` would overflow\nif (x != 0 &amp;&amp; a &lt; INT_MIN / x) // `a * x` would underflow\n\nINT_MIN\n-1\nINT_MIN\nINT_MAX",
            "&lt;stdckdint.h&gt;\nbool ckd_add(type1 *result, type2 a, type3 b);\nbool ckd_sub(type1 *result, type2 a, type3 b);\nbool ckd_mul(type1 *result, type2 a, type3 b);\n\ntype1\ntype2\ntype3\n*result\ntype1\ntrue\nunsigned long b, c, c_test;\n// ...\nif (ckd_mul(&amp;c_test, c, b))\n{\n    // returned non-zero: there has been an overflow\n}\nelse\n{\n    c = c_test; // returned 0: no overflow\n}\n\n__builtin_add_overflow\n__builtin_sub_overflow\n__builtin_mul_overflow\nint\nunsigned long b, c, c_test;\n// ...\nif (__builtin_mul_overflow(c, b, &amp;c_test))\n{\n    // returned non-zero: there has been an overflow\n}\nelse\n{\n    c = c_test; // returned 0: no overflow\n}\n\n__builtin_umull_overflow\n&lt;intrin.h&gt;\naddcarry_uNN\nsubborrow_uNN\naddcarry_u8\nsubborrow_u64\nunsigned char _addcarry_u32(unsigned char c_in, unsigned int src1, unsigned int src2, unsigned int *sum);\nunsigned char _subborrow_u32(unsigned char b_in, unsigned int src1, unsigned int src2, unsigned int *diff);\n\nc_in\nb_in",
            "bool addition_is_safe(uint32_t a, uint32_t b) {\n    size_t a_bits=highestOneBitPosition(a), b_bits=highestOneBitPosition(b);\n    return (a_bits&lt;32 &amp;&amp; b_bits&lt;32);\n}\n\nbool multiplication_is_safe(uint32_t a, uint32_t b) {\n    size_t a_bits=highestOneBitPosition(a), b_bits=highestOneBitPosition(b);\n    return (a_bits+b_bits&lt;=32);\n}\n\na\nb\nbool exponentiation_is_safe(uint32_t a, uint32_t b) {\n    size_t a_bits=highestOneBitPosition(a);\n    return (a_bits*b&lt;=32);\n}\n\nsize_t highestOneBitPosition(uint32_t a) {\n    size_t bits=0;\n    while (a!=0) {\n        ++bits;\n        a&gt;&gt;=1;\n    };\n    return bits;\n}\n\nhighestOneBitPosition",
            "if ( b &gt; ULONG_MAX / a ) // a * b would overflow\n",
            "-O2\n-Wall\nif (a + b &lt; a) { /* Deal with overflow */ }\n\nb = abs(a);\nif (b &lt; 0) { /* Deal with overflow */ }\n\n-fwrapv",
            "uint32_t x, y;\nuint32_t value = x + y;\nbool overflow = value &lt; (x | y);\n\nuint32_t x, y;\nuint32_t value = x + y;\nconst bool overflow = value &lt; x; // Alternatively &quot;value &lt; y&quot; should also work\n\nuint32_t x, y;\nconst uint32_t a = (x &gt;&gt; 16U) * (y &amp; 0xFFFFU);\nconst uint32_t b = (x &amp; 0xFFFFU) * (y &gt;&gt; 16U);\nconst bool overflow = ((x &gt;&gt; 16U) * (y &gt;&gt; 16U)) +\n    (a &gt;&gt; 16U) + (b &gt;&gt; 16U);\nuint32_t value = overflow ? UINT32_MAX : x * y;\n\nuint32_t x, y;\nconst bool overflow\n{\n    [](const uint32_t x, const uint32_t y) noexcept -&gt; bool\n    {\n        const uint32_t a{(x &gt;&gt; 16U) * uint16_t(y)};\n        const uint32_t b{uint16_t(x) * (y &gt;&gt; 16U)};\n        return ((x &gt;&gt; 16U) * (y &gt;&gt; 16U)) + (a &gt;&gt; 16U) + (b &gt;&gt; 16U);\n    }(x, y)\n};\nuint32_t value{overflow ? UINT32_MAX : x * y};\n",
            "    9938.08^2 == 98765432\n    462.241^3 == 98765432\n    99.6899^4 == 98765432\n    39.7119^5 == 98765432\n    21.4998^6 == 98765432\n    13.8703^7 == 98765432\n    9.98448^8 == 98765432\n    7.73196^9 == 98765432\n    6.30174^10 == 98765432\n    5.33068^11 == 98765432\n    4.63679^12 == 98765432\n    4.12069^13 == 98765432\n    3.72429^14 == 98765432\n    3.41172^15 == 98765432\n    3.15982^16 == 98765432\n    2.95305^17 == 98765432\n    2.78064^18 == 98765432\n    2.63493^19 == 98765432\n    2.51033^20 == 98765432\n    2.40268^21 == 98765432\n    2.30883^22 == 98765432\n    2.22634^23 == 98765432\n    2.15332^24 == 98765432\n    2.08826^25 == 98765432\n    2.02995^26 == 98765432\n    1.97741^27 == 98765432\n\n    ['0', '2', '4', '5', '6', '7', '8'] 84^2 = 7056\n    ['1', '2', '3', '4', '5', '8', '9'] 59^2 = 3481\n    ['0', '1', '2', '3', '4', '5', '8', '9'] 59^2 = 3481 (+leading zero)\n    ['1', '2', '3', '5', '8'] 8^3 = 512\n    ['0', '1', '2', '3', '5', '8'] 8^3 = 512 (+leading zero)\n    ['1', '2', '4', '6'] 4^2 = 16\n    ['0', '1', '2', '4', '6'] 4^2 = 16 (+leading zero)\n    ['1', '2', '4', '6'] 2^4 = 16\n    ['0', '1', '2', '4', '6'] 2^4 = 16 (+leading zero)\n    ['1', '2', '8', '9'] 9^2 = 81\n    ['0', '1', '2', '8', '9'] 9^2 = 81 (+leading zero)\n    ['1', '3', '4', '8'] 3^4 = 81\n    ['0', '1', '3', '4', '8'] 3^4 = 81 (+leading zero)\n    ['2', '3', '6', '7', '9'] 3^6 = 729\n    ['0', '2', '3', '6', '7', '9'] 3^6 = 729 (+leading zero)\n    ['2', '3', '8'] 2^3 = 8\n    ['0', '2', '3', '8'] 2^3 = 8 (+leading zero)\n    ['2', '3', '9'] 3^2 = 9\n    ['0', '2', '3', '9'] 3^2 = 9 (+leading zero)\n    ['2', '4', '6', '8'] 8^2 = 64\n    ['0', '2', '4', '6', '8'] 8^2 = 64 (+leading zero)\n    ['2', '4', '7', '9'] 7^2 = 49\n    ['0', '2', '4', '7', '9'] 7^2 = 49 (+leading zero)\n\n    import math\n\n    m = 98765432\n    l = []\n    for i in xrange(2, 98765432):\n        inv = 1.0/i\n        r = m**inv\n        if (r &lt; 2.0): break\n        top = int(math.floor(r))\n        assert(top &lt;= m)\n\n        for j in xrange(2, top+1):\n            s = str(i) + str(j) + str(j**i)\n            l.append((sorted(s), i, j, j**i))\n            assert(j**i &lt;= m)\n\n    l.sort()\n    for s, i, j, ji in l:\n        assert(ji &lt;= m)\n        ss = sorted(set(s))\n        if s == ss:\n            print '%s %d^%d = %d' % (s, i, j, ji)\n\n        # Try with non significant zero somewhere\n        s = ['0'] + s\n        ss = sorted(set(s))\n        if s == ss:\n            print '%s %d^%d = %d (+leading zero)' % (s, i, j, ji)\n",
            "#include &lt;cstddef&gt;\n#if defined( _MSC_VER )\n#include &lt;intrin.h&gt;\n#endif\n\ninline size_t query_intel_x86_eflags(const size_t query_bit_mask)\n{\n    #if defined( _MSC_VER )\n\n        return __readeflags() &amp; query_bit_mask;\n\n    #elif defined( __GNUC__ )\n        // This code will work only on 64-bit GNU-C machines.\n        // Tested and does NOT work with Intel C++ 10.1!\n        size_t eflags;\n        __asm__ __volatile__(\n            \"pushfq \\n\\t\"\n            \"pop %%rax\\n\\t\"\n            \"movq %%rax, %0\\n\\t\"\n            :\"=r\"(eflags)\n            :\n            :\"%rax\"\n            );\n        return eflags &amp; query_bit_mask;\n\n    #else\n\n        #pragma message(\"No inline assembly will work with this compiler!\")\n            return 0;\n    #endif\n}\n\nint main(int argc, char **argv)\n{\n    int x = 1000000000;\n    int y = 20000;\n    int z = x * y;\n    int f = query_intel_x86_eflags(0x801);\n    printf(\"%X\\n\", f);\n}\n\nquery_intel_eflags(0x801)",
            "uint8_t x, y;    /* Give these values */\nconst uint16_t data16    = x + y;\nconst bool carry        = (data16 &gt; 0xFF);\nconst bool overflow     = ((~(x ^ y)) &amp; (x ^ data16) &amp; 0x80);\n\n0xFF\n0xFFFFFFFF\n0x80\n0x80000000\nuint16_t\nuint64_t\ncalloc",
            "unsigned long\nunsigned long long\nFPE_INTOVF_TRAP\nSIGFPE\nFPE_INTOVF_TRAP",
            "-ftrapv\n-ftrapv",
            "unsigned int r, a, b;\nr = a + b;\nif (r &lt; a)\n{\n    // Overflow\n}\n\nsigned int r, a, b, s;\nr = a + b;\ns = a&gt;=0;\nif (s == (b&gt;=0) &amp;&amp; s != (r&gt;=0))\n{\n    // Overflow\n}\n",
            "CLANG ARITHMETIC UNDEFINED at &lt;add.c, (9:11)&gt; :\nOp: +, Reason : Signed Addition Overflow,\nBINARY OPERATION: left (int32): 2147483647 right (int32): 1\n",
            "format ELF64\n\nsection '.text' executable\n\npublic u_mul\n\nu_mul:\n  MOV eax, edi\n  mul esi\n  jnc u_mul_ret\n  xor eax, eax\nu_mul_ret:\nret\n\nextern \"C\" unsigned int u_mul(const unsigned int a, const unsigned int b);\n\nint main() {\n    printf(\"%u\\n\", u_mul(4000000000,2)); // 0\n    printf(\"%u\\n\", u_mul(UINT_MAX/2,2)); // OK\n    return 0;\n}\n\nLIBS",
            "#define overflowflag(isOverflow){   \\\nsize_t eflags;                      \\\nasm (\"pushfl ;\"                     \\\n     \"pop %%eax\"                    \\\n    : \"=a\" (eflags));               \\\nisOverflow = (eflags &gt;&gt; 11) &amp; 1;}\n\n#include &lt;cstddef&gt;\n#include &lt;stdio.h&gt;\n#include &lt;iostream&gt;\n#include &lt;conio.h&gt;\n#if defined( _MSC_VER )\n#include &lt;intrin.h&gt;\n#include &lt;oskit/x86&gt;\n#endif\n\nusing namespace std;\n\n#define detectOverflow(isOverflow){     \\\nsize_t eflags;                      \\\nasm (\"pushfl ;\"                     \\\n    \"pop %%eax\"                     \\\n    : \"=a\" (eflags));               \\\nisOverflow = (eflags &gt;&gt; 11) &amp; 1;}\n\nint main(int argc, char **argv) {\n\n    bool endTest = false;\n    bool isOverflow;\n\n    do {\n        cout &lt;&lt; \"Enter two intergers\" &lt;&lt; endl;\n        int x = 0;\n        int y = 0;\n        cin.clear();\n        cin &gt;&gt; x &gt;&gt; y;\n        int z = x * y;\n        detectOverflow(isOverflow)\n        printf(\"\\nThe result is: %d\", z);\n        if (!isOverflow) {\n            std::cout &lt;&lt; \": no overflow occured\\n\" &lt;&lt; std::endl;\n        } else {\n            std::cout &lt;&lt; \": overflow occured\\n\" &lt;&lt; std::endl;\n        }\n\n        z = x * x * y;\n        detectOverflow(isOverflow)\n        printf(\"\\nThe result is: %d\", z);\n        if (!isOverflow) {\n            std::cout &lt;&lt; \": no overflow ocurred\\n\" &lt;&lt; std::endl;\n        } else {\n            std::cout &lt;&lt; \": overflow occured\\n\" &lt;&lt; std::endl;\n        }\n\n        cout &lt;&lt; \"Do you want to stop? (Enter \\\"y\\\" or \\\"Y)\" &lt;&lt; endl;\n\n        char c = 0;\n\n        do {\n            c = getchar();\n        } while ((c == '\\n') &amp;&amp; (c != EOF));\n\n        if (c == 'y' || c == 'Y') {\n            endTest = true;\n        }\n\n        do {\n            c = getchar();\n        } while ((c != '\\n') &amp;&amp; (c != EOF));\n\n    } while (!endTest);\n}\n",
            "jo\ninfo as\ninfo gcc",
            "mozilla::CheckedInt&lt;T&gt;\nT\nIntegerTypeTraits.h\nAttributes.h\nCompiler.h",
            "unsigned long checked_imul(unsigned long a, unsigned long b) {\n  unsigned __int128 res = (unsigned __int128)a * b;\n  if ((unsigned long)(res &gt;&gt; 64))\n    printf(\"overflow in integer multiply\");\n  return (unsigned long)res;\n}\n",
            "addition_is_safe\nbool addition_is_safe(unsigned int a, unsigned int b)\n{\n    unsigned int L_Mask = std::numeric_limits&lt;unsigned int&gt;::max();\n    L_Mask &gt;&gt;= 1;\n    L_Mask = ~L_Mask;\n\n    a &amp;= L_Mask;\n    b &amp;= L_Mask;\n\n    return ( a == 0 || b == 0 );\n}\n",
            "uint64_t foo(uint64_t a, uint64_t b) {\n    double dc;\n\n    dc = pow(a, b);\n\n    if (dc &lt; UINT_MAX) {\n       return (powu64(a, b));\n    }\n    else {\n      // Overflow\n    }\n}\n",
            "DWORD\nMy Addition(DWORD Value_A, DWORD Value_B)\n{\n    ULARGE_INTEGER a, b;\n\n    b.LowPart = Value_A;  // A 32 bit value(up to 32 bit)\n    b.HighPart = 0;\n    a.LowPart = Value_B;  // A 32 bit value(up to 32 bit)\n    a.HighPart = 0;\n\n    a.QuadPart += b.QuadPart;\n\n    // If  a.HighPart\n    // Then a.HighPart contains the overflow (carry)\n\n    return (a.LowPart + a.HighPart)\n\n    // Any overflow is stored in a.HighPart (up to 32 bits)\n",
            "... /* begin multiplication */\nunsigned multiplicand, multiplier, product, productHalf;\nint zeroesMultiplicand, zeroesMultiplier;\nzeroesMultiplicand = number_of_leading_zeroes( multiplicand );\nzeroesMultiplier   = number_of_leading_zeroes( multiplier );\nif( zeroesMultiplicand + zeroesMultiplier &lt;= 30 ) goto overflow;\nproductHalf = multiplicand * ( c &gt;&gt; 1 );\nif( (int)productHalf &lt; 0 ) goto overflow;\nproduct = productHalf * 2;\nif( multiplier &amp; 1 ){\n   product += multiplicand;\n   if( product &lt; multiplicand ) goto overflow;\n}\n..../* continue code here where \"product\" is the correct product */\n....\noverflow: /* put overflow handling code here */\n\nint number_of_leading_zeroes( unsigned value ){\n   int ctZeroes;\n   if( value == 0 ) return 32;\n   ctZeroes = 1;\n   if( ( value &gt;&gt; 16 ) == 0 ){ ctZeroes += 16; value = value &lt;&lt; 16; }\n   if( ( value &gt;&gt; 24 ) == 0 ){ ctZeroes +=  8; value = value &lt;&lt;  8; }\n   if( ( value &gt;&gt; 28 ) == 0 ){ ctZeroes +=  4; value = value &lt;&lt;  4; }\n   if( ( value &gt;&gt; 30 ) == 0 ){ ctZeroes +=  2; value = value &lt;&lt;  2; }\n   ctZeroes -= x &gt;&gt; 31;\n   return ctZeroes;\n}\n",
            "long lng;\nint n;\nfor (n = 0; n &lt; 34; ++n)\n{\n   lng = pow (2, n);\n   printf (\"%li\\n\", lng);\n}\n\nlong signed lng, lng_prev = 0;\nint n;\nfor (n = 0; n &lt; 34; ++n)\n{\n    lng = pow (2, n);\n    if (lng &lt;= lng_prev)\n    {\n        printf (\"Overflow: %i\\n\", n);\n        /* Do whatever you do in the event of overflow.  */\n    }\n    printf (\"%li\\n\", lng);\n    lng_prev = lng;\n}\n\n&lt;=\n&gt;=",
            "#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\n#define MAX 100 \n\nint mltovf(int a, int b)\n{\n    if (a &amp;&amp; b) return abs(a) &gt; MAX/abs(b);\n    else return 0;\n}\n\nmain()\n{\n    int a, b;\n\n    for (a = 0; a &lt;= MAX; a++)\n        for (b = 0; b &lt; MAX; b++) {\n\n        if (mltovf(a, b) != (a*b &gt; MAX)) \n            printf(\"Bad calculation: a: %d b: %d\\n\", a, b);\n\n    }\n}\n"
        ]
    },
    {
        "question_id": 19902828,
        "question_code": "ENT\nENOENT\nENOFILE",
        "answer_code_snippets": [
            "ENOFILE",
            "File: /usr/include/asm-generic/errno-base.h\n6: #define  ENOENT       2  /* No such file or directory */\n7: \n\nerrno 2\n\nENOENT 2 No such file or directory\n\n&quot;No such file or directory.&quot; This is a “file doesn’t exist” error for ordinary files that are referenced in contexts where they are\n"
        ]
    },
    {
        "question_id": 6964392,
        "question_code": "lorenzo@enzo:~/erlang$ gcc -lm -o euler12.bin euler12.c\nlorenzo@enzo:~/erlang$ time ./euler12.bin\n842161320\n\nreal    0m11.074s\nuser    0m11.070s\nsys 0m0.000s\n\nlorenzo@enzo:~/erlang$ time ./euler12.py \n842161320\n\nreal    1m16.632s\nuser    1m16.370s\nsys 0m0.250s\n\nlorenzo@enzo:~/Downloads/pypy-c-jit-43780-b590cf6de419-linux64/bin$ time ./pypy /home/lorenzo/erlang/euler12.py \n842161320\n\nreal    0m13.082s\nuser    0m13.050s\nsys 0m0.020s\n\nlorenzo@enzo:~/erlang$ erlc euler12.erl \nlorenzo@enzo:~/erlang$ time erl -s euler12 solve\nErlang R13B03 (erts-5.7.4) [source] [64-bit] [smp:4:4] [rq:4] [async-threads:0] [hipe] [kernel-poll:false]\n\nEshell V5.7.4  (abort with ^G)\n1&gt; 842161320\n\nreal    0m48.259s\nuser    0m48.070s\nsys 0m0.020s\n\nlorenzo@enzo:~/erlang$ ghc euler12.hs -o euler12.hsx\n[1 of 1] Compiling Main             ( euler12.hs, euler12.o )\nLinking euler12.hsx ...\nlorenzo@enzo:~/erlang$ time ./euler12.hsx \n842161320\n\nreal    2m37.326s\nuser    2m37.240s\nsys 0m0.080s\n\nMAXINT\n#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\n\nint factorCount (long n)\n{\n    double square = sqrt (n);\n    int isquare = (int) square;\n    int count = isquare == square ? -1 : 0;\n    long candidate;\n    for (candidate = 1; candidate &lt;= isquare; candidate ++)\n        if (0 == n % candidate) count += 2;\n    return count;\n}\n\nint main ()\n{\n    long triangle = 1;\n    int index = 1;\n    while (factorCount (triangle) &lt; 1001)\n    {\n        index ++;\n        triangle += index;\n    }\n    printf (&quot;%ld\\n&quot;, triangle);\n}\n\n#! /usr/bin/env python3.2\n\nimport math\n\ndef factorCount (n):\n    square = math.sqrt (n)\n    isquare = int (square)\n    count = -1 if isquare == square else 0\n    for candidate in range (1, isquare + 1):\n        if not n % candidate: count += 2\n    return count\n\ntriangle = 1\nindex = 1\nwhile factorCount (triangle) &lt; 1001:\n    index += 1\n    triangle += index\n\nprint (triangle)\n\n-module (euler12).\n-compile (export_all).\n\nfactorCount (Number) -&gt; factorCount (Number, math:sqrt (Number), 1, 0).\n\nfactorCount (_, Sqrt, Candidate, Count) when Candidate &gt; Sqrt -&gt; Count;\n\nfactorCount (_, Sqrt, Candidate, Count) when Candidate == Sqrt -&gt; Count + 1;\n\nfactorCount (Number, Sqrt, Candidate, Count) -&gt;\n    case Number rem Candidate of\n        0 -&gt; factorCount (Number, Sqrt, Candidate + 1, Count + 2);\n        _ -&gt; factorCount (Number, Sqrt, Candidate + 1, Count)\n    end.\n\nnextTriangle (Index, Triangle) -&gt;\n    Count = factorCount (Triangle),\n    if\n        Count &gt; 1000 -&gt; Triangle;\n        true -&gt; nextTriangle (Index + 1, Triangle + Index + 1)  \n    end.\n\nsolve () -&gt;\n    io:format (&quot;~p~n&quot;, [nextTriangle (1, 1) ] ),\n    halt (0).\n\nfactorCount number = factorCount' number isquare 1 0 - (fromEnum $ square == fromIntegral isquare)\n    where square = sqrt $ fromIntegral number\n          isquare = floor square\n\nfactorCount' number sqrt candidate count\n    | fromIntegral candidate &gt; sqrt = count\n    | number `mod` candidate == 0 = factorCount' number sqrt (candidate + 1) (count + 2)\n    | otherwise = factorCount' number sqrt (candidate + 1) count\n\nnextTriangle index triangle\n    | factorCount triangle &gt; 1000 = triangle\n    | otherwise = nextTriangle (index + 1) (triangle + index + 1)\n\nmain = print $ nextTriangle 1 1\n",
        "answer_code_snippets": [
            "GHC 7.0.3\ngcc 4.4.6\nLinux 2.6.29\nghc -O2 -fllvm -fforce-recomp\ngcc -O3 -lm\n-O3\n-O2\nfactorCount'\nInteger\nInt\nfactorCount'\nfromIntegral\nmod\nrem\nfactorCount'\nnumber\nsqrt\n $ time ./so\n 842161320  \n\n real    0m7.954s  \n user    0m7.944s  \n sys     0m0.004s  \n\n-fllvm\n8.182 seconds\nfactorCount number = factorCount' number isquare 1 0 - (fromEnum $ square == fromIntegral isquare)\n    where square = sqrt $ fromIntegral number\n          isquare = floor square\n\nfactorCount' :: Int -&gt; Int -&gt; Int -&gt; Int -&gt; Int\nfactorCount' number sqrt candidate0 count0 = go candidate0 count0\n  where\n  go candidate count\n    | candidate &gt; sqrt = count\n    | number `rem` candidate == 0 = go (candidate + 1) (count + 2)\n    | otherwise = go (candidate + 1) count\n\nnextTriangle index triangle\n    | factorCount triangle &gt; 1000 = triangle\n    | otherwise = nextTriangle (index + 1) (triangle + index + 1)\n\nmain = print $ nextTriangle 1 1\n\nInteger\nInt\nInt\nInt64\nWord64\nlong\n-O2\nrem\nmod",
            "+native\nexport_all\nerlc +native euler12\n-compile(export_all)\n-export([solve/0]).\nfactorCount (_, Sqrt, Candidate, Count) when Candidate == Sqrt -&gt; Count + 1;\n\nfactorCount (N) -&gt;\n    Sqrt = math:sqrt (N),\n    ISqrt = trunc(Sqrt),\n    if ISqrt == Sqrt -&gt; factorCount (N, ISqrt, 1, -1);\n       true          -&gt; factorCount (N, ISqrt, 1, 0)\n    end.\n\nfactorCount (_N, ISqrt, Candidate, Count) when Candidate &gt; ISqrt -&gt; Count;\nfactorCount ( N, ISqrt, Candidate, Count) -&gt;\n    case N rem Candidate of\n        0 -&gt; factorCount (N, ISqrt, Candidate + 1, Count + 2);\n        _ -&gt; factorCount (N, ISqrt, Candidate + 1, Count)\n    end.\n\nexport_all\n$ erlc +native euler12.erl\n$ time erl -noshell -s euler12 solve\n842161320\n\nreal    0m19.468s\nuser    0m19.450s\nsys 0m0.010s\n\n$ time ./a.out \n842161320\n\nreal    0m12.755s\nuser    0m12.730s\nsys 0m0.020s\n",
            "gcc -O3 -lm\n% time ./euler12-c \n842161320\n\n./euler12-c  11.95s \n user 0.00s \n system 99% \n cpu 11.959 total\n\n% time pypy euler12.py\n842161320\npypy euler12.py  \n16.44s user \n0.01s system \n99% cpu 16.449 total\n\nc2f583445aee\n% time ./euler12-rpython-c\n842161320\n./euler12-rpy-c  \n10.54s user 0.00s \nsystem 99% \ncpu 10.540 total\n\n% time python euler12-cython.py\n842161320\npython euler12-cython.py  \n6.27s user 0.00s \nsystem 99% \ncpu 6.274 total\n\ntarget\nmain\nsys.argv\n% translate.py euler12-rpython.py\n# euler12-rpython.py\n\nimport math, sys\n\ndef factorCount(n):\n    square = math.sqrt(n)\n    isquare = int(square)\n    count = -1 if isquare == square else 0\n    for candidate in xrange(1, isquare + 1):\n        if not n % candidate: count += 2\n    return count\n\ndef main(argv):\n    triangle = 1\n    index = 1\n    while factorCount(triangle) &lt; 1001:\n        index += 1\n        triangle += index\n    print triangle\n    return 0\n\nif __name__ == '__main__':\n    main(sys.argv)\n\ndef target(*args):\n    return main, None\n\n_euler12.pyx\n_euler12.pyx\npython setup.py build_ext --inplace\n# _euler12.pyx\nfrom libc.math cimport sqrt\n\ncdef int factorCount(int n):\n    cdef int candidate, isquare, count\n    cdef double square\n    square = sqrt(n)\n    isquare = int(square)\n    count = -1 if isquare == square else 0\n    for candidate in range(1, isquare + 1):\n        if not n % candidate: count += 2\n    return count\n\ncpdef main():\n    cdef int triangle = 1, index = 1\n    while factorCount(triangle) &lt; 1001:\n        index += 1\n        triangle += index\n    print triangle\n\n# euler12-cython.py\nimport _euler12\n_euler12.main()\n\n# setup.py\nfrom distutils.core import setup\nfrom distutils.extension import Extension\nfrom Cython.Distutils import build_ext\n\next_modules = [Extension(\"_euler12\", [\"_euler12.pyx\"])]\n\nsetup(\n  name = 'Euler12-Cython',\n  cmdclass = {'build_ext': build_ext},\n  ext_modules = ext_modules\n)\n",
            "#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\n\nstatic inline int factorCount(int n)\n{\n    double square = sqrt (n);\n    int isquare = (int)square;\n    int count = isquare == square ? -1 : 0;\n    int candidate;\n    for (candidate = 1; candidate &lt;= isquare; candidate ++)\n        if (0 == n % candidate) count += 2;\n    return count;\n}\n\nint main ()\n{\n    int triangle = 1;\n    int index = 1;\n    while (factorCount (triangle) &lt; 1001)\n    {\n        index++;\n        triangle += index;\n    }\n    printf (\"%d\\n\", triangle);\n}\n\n$ gcc -O3 -lm -o euler12 euler12.c; time ./euler12\n842161320\n./euler12  2.95s user 0.00s system 99% cpu 2.956 total\n\n$ ghc -O2 -fllvm -fforce-recomp euler12.hs; time ./euler12                                                                                      [9:40]\n[1 of 1] Compiling Main             ( euler12.hs, euler12.o )\nLinking euler12 ...\n842161320\n./euler12  9.43s user 0.13s system 99% cpu 9.602 total\n",
            "import Control.Applicative\nimport Control.Monad\nimport Data.Either\nimport Math.NumberTheory.Powers.Squares\n\nisInt :: RealFrac c =&gt; c -&gt; Bool\nisInt = (==) &lt;$&gt; id &lt;*&gt; fromInteger . round\n\nintSqrt :: (Integral a) =&gt; a -&gt; Int\n--intSqrt = fromIntegral . floor . sqrt . fromIntegral\nintSqrt = fromIntegral . integerSquareRoot'\n\nfactorize :: Int -&gt; [Int]\nfactorize 1 = []\nfactorize n = first : factorize (quot n first)\n  where first = (!! 0) $ [a | a &lt;- [2..intSqrt n], rem n a == 0] ++ [n]\n\nfactorize2 :: Int -&gt; [(Int,Int)]\nfactorize2 = foldl (\\ls@((val,freq):xs) y -&gt; if val == y then (val,freq+1):xs else (y,1):ls) [(0,0)] . factorize\n\nnumDivisors :: Int -&gt; Int\nnumDivisors = foldl (\\acc (_,y) -&gt; acc * (y+1)) 1 &lt;$&gt; factorize2\n\nnextTriangleNumber :: (Int,Int) -&gt; (Int,Int)\nnextTriangleNumber (n,acc) = (n+1,acc+n+1)\n\nforward :: Int -&gt; (Int, Int) -&gt; Either (Int, Int) (Int, Int)\nforward k val@(n,acc) = if numDivisors acc &gt; k then Left val else Right (nextTriangleNumber val)\n\nproblem12 :: Int -&gt; (Int, Int)\nproblem12 n = (!!0) . lefts . scanl (&gt;&gt;=) (forward n (1,1)) . repeat . forward $ n\n\nmain = do\n  let (n,val) = problem12 1000\n  print val\n\nghc -O3\nint factorCount (int n)\n{\n  int count = 1;\n  int candidate,tmpCount;\n  while (n % 2 == 0) {\n    count++;\n    n /= 2;\n  }\n    for (candidate = 3; candidate &lt; n &amp;&amp; candidate * candidate &lt; n; candidate += 2)\n    if (n % candidate == 0) {\n      tmpCount = 1;\n      do {\n        tmpCount++;\n        n /= candidate;\n      } while (n % candidate == 0);\n       count*=tmpCount;\n      }\n  if (n &gt; 1)\n    count *= 2;\n  return count;\n}\n\ngcc -O3 -lm\nint main ()\n{\n  int triangle = 0,count1,count2 = 1;\n  do {\n    count1 = count2;\n    count2 = ++triangle % 2 == 0 ? factorCount(triangle+1) : factorCount((triangle+1)/2);\n  } while (count1*count2 &lt; 1001);\n  printf (\"%lld\\n\", ((long long)triangle)*(triangle+1)/2);\n}\n",
            "import Data.Numbers.Primes\nimport Data.List\n\ntriangleNumbers = scanl1 (+) [1..]\nnDivisors n = product $ map ((+1) . length) (group (primeFactors n))\nanswer = head $ filter ((&gt; 500) . nDivisors) triangleNumbers\n\nmain :: IO ()\nmain = putStrLn $ \"First triangle number to have over 500 divisors: \" ++ (show answer)\n\nPS&gt; measure-command { bin\\012_slow.exe }\n\nTotalSeconds      : 16.3807409\nTotalMilliseconds : 16380.7409\n\nPS&gt; measure-command { bin\\012.exe }\n\nTotalSeconds      : 0.0383436\nTotalMilliseconds : 38.3436\n\nghc -O2 012.hs -o bin\\012.exe\nghc -O2 012_slow.hs -o bin\\012_slow.exe\n",
            "factorCount\nrange (1, isquare + 1)\nmalloc\nfactorCount()\nrange()\nrange\ndef factorial(n, acc=1):\n    if n &gt; 1:\n        acc = acc * n\n        n = n - 1\n        return factorial(n, acc)\n    else:\n        return acc\n\ndef factorial2(n):\n    if n &gt; 1:\n        f = factorial2(n-1)\n        return f*n\n    else:\n        return 1\n\ndef factorial(n, acc=1):\n    if n &gt; 1:\n        return factorial(n-1, acc*n)\n    else:\n        return acc\n\ndef factorial2(n):\n    if n &gt; 1:\n        return n*factorial(n-1)\n    else:\n        return 1\n\nacc\naccumulator",
            "factorCount number = foldr factorCount' 0 [1..isquare] -\n                     (fromEnum $ square == fromIntegral isquare)\n    where\n      square = sqrt $ fromIntegral number\n      isquare = floor square\n      factorCount' candidate\n        | number `rem` candidate == 0 = (2 +)\n        | otherwise = id\n\ntriangles :: [Int]\ntriangles = scanl1 (+) [1,2..]\n\nmain = print . head $ dropWhile ((&lt; 1001) . factorCount) triangles\n",
            "timer:tc/1 or timer:tc/2 or timer:tc/3",
            "compiling on VS x64 command prompt &gt; `for /f %f in ('dir /b *.c') do cl /O2 /Ot /Ox %f -o %f_x64_vs2012.exe`\ncompiling on cygwin with gcc x64   &gt; `for f in ./*.c; do gcc -m64 -O3 $f -o ${f}_x64_gcc.exe ; done`\ntime (unix tools) using cygwin &gt; `for f in ./*.exe; do  echo \"----------\"; echo $f ; time $f ; done`\n\n----------\n$ time python ./original.py\n\nreal    2m17.748s\nuser    2m15.783s\nsys     0m0.093s\n----------\n$ time ./original_x86_vs2012.exe\n\nreal    0m8.377s\nuser    0m0.015s\nsys     0m0.000s\n----------\n$ time ./original_x64_vs2012.exe\n\nreal    0m8.408s\nuser    0m0.000s\nsys     0m0.015s\n----------\n$ time ./original_x64_gcc.exe\n\nreal    0m20.951s\nuser    0m20.732s\nsys     0m0.030s\n\nintegertype_architecture_compiler.exe\nint\nlong\n----------\n$ time ./int_x86_vs2012.exe\n\nreal    0m8.440s\nuser    0m0.016s\nsys     0m0.015s\n----------\n$ time ./int_x64_vs2012.exe\n\nreal    0m8.408s\nuser    0m0.016s\nsys     0m0.015s\n----------\n$ time ./int32_x86_vs2012.exe\n\nreal    0m8.408s\nuser    0m0.000s\nsys     0m0.015s\n----------\n$ time ./int32_x64_vs2012.exe\n\nreal    0m8.362s\nuser    0m0.000s\nsys     0m0.015s\n----------\n$ time ./int64_x86_vs2012.exe\n\nreal    0m18.112s\nuser    0m0.000s\nsys     0m0.015s\n----------\n$ time ./int64_x64_vs2012.exe\n\nreal    0m18.611s\nuser    0m0.000s\nsys     0m0.015s\n----------\n$ time ./long_x86_vs2012.exe\n\nreal    0m8.393s\nuser    0m0.015s\nsys     0m0.000s\n----------\n$ time ./long_x64_vs2012.exe\n\nreal    0m8.440s\nuser    0m0.000s\nsys     0m0.015s\n----------\n$ time ./uint32_x86_vs2012.exe\n\nreal    0m8.362s\nuser    0m0.000s\nsys     0m0.015s\n----------\n$ time ./uint32_x64_vs2012.exe\n\nreal    0m8.393s\nuser    0m0.015s\nsys     0m0.015s\n----------\n$ time ./uint64_x86_vs2012.exe\n\nreal    0m15.428s\nuser    0m0.000s\nsys     0m0.015s\n----------\n$ time ./uint64_x64_vs2012.exe\n\nreal    0m15.725s\nuser    0m0.015s\nsys     0m0.015s\n----------\n$ time ./int_x64_gcc.exe\n\nreal    0m8.531s\nuser    0m8.329s\nsys     0m0.015s\n----------\n$ time ./int32_x64_gcc.exe\n\nreal    0m8.471s\nuser    0m8.345s\nsys     0m0.000s\n----------\n$ time ./int64_x64_gcc.exe\n\nreal    0m20.264s\nuser    0m20.186s\nsys     0m0.015s\n----------\n$ time ./long_x64_gcc.exe\n\nreal    0m20.935s\nuser    0m20.809s\nsys     0m0.015s\n----------\n$ time ./uint32_x64_gcc.exe\n\nreal    0m8.393s\nuser    0m8.346s\nsys     0m0.015s\n----------\n$ time ./uint64_x64_gcc.exe\n\nreal    0m16.973s\nuser    0m16.879s\nsys     0m0.030s\n\nint\nlong\nint32_t\nuint32_t\nint64_t\nuint64_t\n#include &lt;stdint.h&gt;\nuint32_t\n#include &lt;stdint.h&gt;",
            "-module(p12dist).  \n-author(\"Jannich Brendle, jannich@bredsaal.dk, http://blog.bredsaal.dk\").  \n-compile(export_all).\n\nserver() -&gt;  \n  server(1).\n\nserver(Number) -&gt;  \n  receive {getwork, Worker_PID} -&gt; Worker_PID ! {work,Number,Number+100},  \n  server(Number+101);  \n  {result,T} -&gt; io:format(\"The result is: \\~w.\\~n\", [T]);  \n  _ -&gt; server(Number)  \n  end.\n\nworker(Server_PID) -&gt;  \n  Server_PID ! {getwork, self()},  \n  receive {work,Start,End} -&gt; solve(Start,End,Server_PID)  \n  end,  \n  worker(Server_PID).\n\nstart() -&gt;  \n  Server_PID = spawn(p12dist, server, []),  \n  spawn(p12dist, worker, [Server_PID]),  \n  spawn(p12dist, worker, [Server_PID]),  \n  spawn(p12dist, worker, [Server_PID]),  \n  spawn(p12dist, worker, [Server_PID]).\n\nsolve(N,End,_) when N =:= End -&gt; no_solution;\n\nsolve(N,End,Server_PID) -&gt;  \n  T=round(N*(N+1)/2),\n  case (divisor(T,round(math:sqrt(T))) &gt; 500) of  \n    true -&gt;  \n      Server_PID ! {result,T};  \n    false -&gt;  \n      solve(N+1,End,Server_PID)  \n  end.\n\ndivisors(N) -&gt;  \n  divisor(N,round(math:sqrt(N))).\n\ndivisor(_,0) -&gt; 1;  \ndivisor(N,I) -&gt;  \n  case (N rem I) =:= 0 of  \n  true -&gt;  \n    2+divisor(N,I-1);  \n  false -&gt;  \n    divisor(N,I-1)  \n  end.\n\n~$ time erl -noshell -s p12dist start\n\nThe result is: 76576500.\n\n^C\n\nBREAK: (a)bort (c)ontinue (p)roc info (i)nfo (l)oaded\n       (v)ersion (k)ill (D)b-tables (d)istribution\na\n\nreal    0m5.510s\nuser    0m5.836s\nsys 0m0.152s\n",
            "package main\n\nimport \"fmt\"\nimport \"math\"\n\nfunc main() {\n    var n, m, c int\n    for i := 1; ; i++ {\n        n, m, c = i * (i + 1) / 2, int(math.Sqrt(float64(n))), 0\n        for f := 1; f &lt; m; f++ {\n            if n % f == 0 { c++ }\n    }\n    c *= 2\n    if m * m == n { c ++ }\n    if c &gt; 1001 {\n        fmt.Println(n)\n        break\n        }\n    }\n}\n\npackage main\n\nimport (\n    \"math\"\n    \"fmt\"\n )\n\n// Sieve of Eratosthenes\nfunc PrimesBelow(limit int) []int {\n    switch {\n        case limit &lt; 2:\n            return []int{}\n        case limit == 2:\n            return []int{2}\n    }\n    sievebound := (limit - 1) / 2\n    sieve := make([]bool, sievebound+1)\n    crosslimit := int(math.Sqrt(float64(limit))-1) / 2\n    for i := 1; i &lt;= crosslimit; i++ {\n        if !sieve[i] {\n            for j := 2 * i * (i + 1); j &lt;= sievebound; j += 2*i + 1 {\n                sieve[j] = true\n            }\n        }\n    }\n    plimit := int(1.3*float64(limit)) / int(math.Log(float64(limit)))\n    primes := make([]int, plimit)\n    p := 1\n    primes[0] = 2\n    for i := 1; i &lt;= sievebound; i++ {\n        if !sieve[i] {\n            primes[p] = 2*i + 1\n            p++\n            if p &gt;= plimit {\n                break\n            }\n        }\n    }\n    last := len(primes) - 1\n    for i := last; i &gt; 0; i-- {\n        if primes[i] != 0 {\n            break\n        }\n        last = i\n    }\n    return primes[0:last]\n}\n\n\n\nfunc main() {\n    fmt.Println(p12())\n}\n// Requires PrimesBelow from utils.go\nfunc p12() int {\n    n, dn, cnt := 3, 2, 0\n    primearray := PrimesBelow(1000000)\n    for cnt &lt;= 1001 {\n        n++\n        n1 := n\n        if n1%2 == 0 {\n            n1 /= 2\n        }\n        dn1 := 1\n        for i := 0; i &lt; len(primearray); i++ {\n            if primearray[i]*primearray[i] &gt; n1 {\n                dn1 *= 2\n                break\n            }\n            exponent := 1\n            for n1%primearray[i] == 0 {\n                exponent++\n                n1 /= primearray[i]\n            }\n            if exponent &gt; 1 {\n                dn1 *= exponent\n            }\n            if n1 == 1 {\n                break\n            }\n        }\n        cnt = dn * dn1\n        dn = dn1\n    }\n    return n * (n - 1) / 2\n}\n\ndef D(N):\n    if N == 1: return 1\n    sqrtN = int(N ** 0.5)\n    nf = 1\n    for d in range(2, sqrtN + 1):\n        if N % d == 0:\n            nf = nf + 1\n    return 2 * nf - (1 if sqrtN**2 == N else 0)\n\nL = 1000\nDt, n = 0, 0\n\nwhile Dt &lt;= L:\n    t = n * (n + 1) // 2\n    Dt = D(n/2)*D(n+1) if n%2 == 0 else D(n)*D((n+1)/2)\n    n = n + 1\n\nprint (t)\n",
            "#include &lt;iostream&gt;\n#include &lt;cmath&gt;\n#include &lt;tuple&gt;\n#include &lt;chrono&gt;\n\nusing namespace std;\n\n// Calculates the divisors of an integer by determining its prime factorisation.\n\nint get_divisors(long long n)\n{\n    int divisors_count = 1;\n\n    for(long long i = 2;\n        i &lt;= sqrt(n);\n        /* empty */)\n    {\n        int divisions = 0;\n        while(n % i == 0)\n        {\n            n /= i;\n            divisions++;\n        }\n\n        divisors_count *= (divisions + 1);\n\n        //here, we try to iterate more efficiently by skipping\n        //obvious non-primes like 4, 6, etc\n        if(i == 2)\n            i++;\n        else\n            i += 2;\n    }\n\n    if(n != 1) //n is a prime\n        return divisors_count * 2;\n    else\n        return divisors_count;\n}\n\nlong long euler12()\n{\n    //n and n + 1\n    long long n, n_p_1;\n\n    n = 1; n_p_1 = 2;\n\n    // divisors_x will store either the divisors of x or x/2\n    // (the later iff x is divisible by two)\n    long long divisors_n = 1;\n    long long divisors_n_p_1 = 2;\n\n    for(;;)\n    {\n        /* This loop has been unwound, so two iterations are completed at a time\n         * n and n + 1 have no prime factors in common and therefore we can\n         * calculate their divisors separately\n         */\n\n        long long total_divisors;                 //the divisors of the triangle number\n                                                  // n(n+1)/2\n\n        //the first (unwound) iteration\n\n        divisors_n_p_1 = get_divisors(n_p_1 / 2); //here n+1 is even and we\n\n        total_divisors =\n                  divisors_n\n                * divisors_n_p_1;\n\n        if(total_divisors &gt; 1000)\n            break;\n\n        //move n and n+1 forward\n        n = n_p_1;\n        n_p_1 = n + 1;\n\n        //fix the divisors\n        divisors_n = divisors_n_p_1;\n        divisors_n_p_1 = get_divisors(n_p_1);   //n_p_1 is now odd!\n\n        //now the second (unwound) iteration\n\n        total_divisors =\n                  divisors_n\n                * divisors_n_p_1;\n\n        if(total_divisors &gt; 1000)\n            break;\n\n        //move n and n+1 forward\n        n = n_p_1;\n        n_p_1 = n + 1;\n\n        //fix the divisors\n        divisors_n = divisors_n_p_1;\n        divisors_n_p_1 = get_divisors(n_p_1 / 2);   //n_p_1 is now even!\n    }\n\n    return (n * n_p_1) / 2;\n}\n\nint main()\n{\n    for(int i = 0; i &lt; 1000; i++)\n    {\n        using namespace std::chrono;\n        auto start = high_resolution_clock::now();\n        auto result = euler12();\n        auto end = high_resolution_clock::now();\n\n        double time_elapsed = duration_cast&lt;milliseconds&gt;(end - start).count();\n\n        cout &lt;&lt; result &lt;&lt; \" \" &lt;&lt; time_elapsed &lt;&lt; '\\n';\n    }\n    return 0;\n}\n",
            "// Return at least the number of factors of n.\nstatic uint64_t approxfactorcount (uint64_t n)\n{\n    uint64_t count = 1, add;\n\n#define CHECK(d)                            \\\n    do {                                    \\\n        if (n % d == 0) {                   \\\n            add = count;                    \\\n            do { n /= d; count += add; }    \\\n            while (n % d == 0);             \\\n        }                                   \\\n    } while (0)\n\n    CHECK ( 2); CHECK ( 3); CHECK ( 5); CHECK ( 7); CHECK (11); CHECK (13);\n    CHECK (17); CHECK (19); CHECK (23); CHECK (29);\n    if (n == 1) return count;\n    if (n &lt; 1ull * 31 * 31) return count * 2;\n    if (n &lt; 1ull * 31 * 31 * 37) return count * 4;\n    if (n &lt; 1ull * 31 * 31 * 37 * 37) return count * 8;\n    if (n &lt; 1ull * 31 * 31 * 37 * 37 * 41) return count * 16;\n    if (n &lt; 1ull * 31 * 31 * 37 * 37 * 41 * 43) return count * 32;\n    if (n &lt; 1ull * 31 * 31 * 37 * 37 * 41 * 43 * 47) return count * 64;\n    if (n &lt; 1ull * 31 * 31 * 37 * 37 * 41 * 43 * 47 * 53) return count * 128;\n    if (n &lt; 1ull * 31 * 31 * 37 * 37 * 41 * 43 * 47 * 53 * 59) return count * 256;\n    if (n &lt; 1ull * 31 * 31 * 37 * 37 * 41 * 43 * 47 * 53 * 59 * 61) return count * 512;\n    if (n &lt; 1ull * 31 * 31 * 37 * 37 * 41 * 43 * 47 * 53 * 59 * 61 * 67) return count * 1024;\n    if (n &lt; 1ull * 31 * 31 * 37 * 37 * 41 * 43 * 47 * 53 * 59 * 61 * 67 * 71) return count * 2048;\n    if (n &lt; 1ull * 31 * 31 * 37 * 37 * 41 * 43 * 47 * 53 * 59 * 61 * 67 * 71 * 73) return count * 4096;\n    return count * 1000000;\n}\n\n// Return the number of factors of n.\nstatic uint64_t factorcount (uint64_t n)\n{\n    uint64_t count = 1, add;\n\n    CHECK (2); CHECK (3);\n\n    uint64_t d = 5, inc = 2;\n    for (; d*d &lt;= n; d += inc, inc = (6 - inc))\n        CHECK (d);\n\n    if (n &gt; 1) count *= 2; // n must be a prime number\n    return count;\n}\n\n// Prints triangular numbers with record numbers of factors.\nstatic void printrecordnumbers (uint64_t limit)\n{\n    uint64_t record = 30000;\n\n    uint64_t count1, factor1;\n    uint64_t count2 = 1, factor2 = 1;\n\n    for (uint64_t n = 1; n &lt;= limit; ++n)\n    {\n        factor1 = factor2;\n        count1 = count2;\n\n        factor2 = n + 1; if (factor2 % 2 == 0) factor2 /= 2;\n        count2 = approxfactorcount (factor2);\n\n        if (count1 * count2 &gt; record)\n        {\n            uint64_t factors = factorcount (factor1) * factorcount (factor2);\n            if (factors &gt; record)\n            {\n                printf (\"%lluth triangular number = %llu has %llu factors\\n\", n, factor1 * factor2, factors);\n                record = factors;\n            }\n        }\n    }\n}\n",
            "zhengs-MacBook-Pro:workspace zhengzhibin$ time erl -noshell -s p12dist start\nThe result is: 842161320.\n\nreal    0m3.879s\nuser    0m14.553s\nsys     0m0.314s\nzhengs-MacBook-Pro:workspace zhengzhibin$ time erl -noshell -s euler12 solve\n842161320\n\nreal    0m10.125s\nuser    0m10.078s\nsys     0m0.046s\nzhengs-MacBook-Pro:workspace zhengzhibin$ time ./euler12.bin \n842161320\n\nreal    0m5.370s\nuser    0m5.328s\nsys     0m0.004s\nzhengs-MacBook-Pro:workspace zhengzhibin$\n",
            "#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\n\nint factorCount (long n)\n{\n    double square = sqrt (n);\n    int isquare = (int) square+1;\n    long candidate = 2;\n    int count = 1;\n    while(candidate &lt;= isquare &amp;&amp; candidate &lt;= n){\n        int c = 1;\n        while (n % candidate == 0) {\n           c++;\n           n /= candidate;\n        }\n        count *= c;\n        candidate++;\n    }\n    return count;\n}\n\nint main ()\n{\n    long triangle = 1;\n    int index = 1;\n    while (factorCount (triangle) &lt; 1001)\n    {\n        index ++;\n        triangle += index;\n    }\n    printf (&quot;%ld\\n&quot;, triangle);\n}\n"
        ]
    },
    {
        "question_id": 1653958,
        "question_code": "#ifndef HEADERFILE_H\n#define HEADERFILE_H\n\n#endif\n",
        "answer_code_snippets": [
            "HEADERFILE_H\nifndef",
            "#ifndef &lt;token&gt;\n/* code */\n#else\n/* code to include if the token is defined */\n#endif\n\n#ifndef\n#defined\n#else\n#else\n#endif\n#ifndef\n#ifndef _INCL_GUARD\n#define _INCL_GUARD\n#endif\n",
            "#ifndef __COMMON_H__\n#define __COMMON_H__\n//header file content\n#endif\n",
            "#ifndef\nHEADERFILE_H\n#define\nHEADERFILE_H\n#ifndef\n#endif\n#ifndef\n#ifndef\n#ifndef\n#ifndef\n#endif",
            "#ifndef ABOUTSCREEN_H\n#define ABOUTSCREEN_H\n\n#include &lt;fcntl.h&gt;\n#include &lt;unistd.h&gt;\n\n#define CHARGING_STATUS_FILE &quot;/cable.2/state&quot;\n\n#define LED_ON &quot;255&quot;\n#define LED_OFF &quot;0&quot;\n\nnamespace Ui\n{\n    class aboutScreen;\n}\n\nclass aboutScreen : public QWidget\n{\n    Q_OBJECT\n\npublic:\n    enum LedColors\n    {\n        OFF,\n        RED,\n        BLUE,\n        GREEN,\n        WHITE\n    };\n\n    explicit aboutScreen(QWidget *parent = 0, Ui::mainStackWidget *uiMainStackWidget = 0);\n    ~aboutScreen();\n    void init(void);\n    void writeLedStatus(QString, QString);\n\npublic slots:\n    void updateBatteryAndStorageStatus(void);\n\nprivate slots:\n    void on_backButton_pressed();\n    void on_backButton_released();\n\nprivate:\n    Ui::mainStackWidget *uiMainStackWidget;\n};\n\n#endif // ABOUTSCREEN_H\n"
        ]
    },
    {
        "question_id": 822323,
        "question_code": "",
        "answer_code_snippets": [
            "rand()\n#include &lt;time.h&gt;\n#include &lt;stdlib.h&gt;\n\nsrand(time(NULL));   // Initialization, should only be called once.\nint r = rand();      // Returns a pseudo-random integer between 0 and RAND_MAX.\n",
            "rand()\n&lt;stdlib.h&gt;\nRAND_MAX\nsrand(unsigned int seed)\n%\nrand()\n/* random int between 0 and 19 */\nint r = rand() % 20;\n\n/* Returns an integer in the range [0, n).\n *\n * Uses rand(), and so is affected-by/affects the same seed.\n */\nint randint(int n) {\n  if ((n - 1) == RAND_MAX) {\n    return rand();\n  } else {\n    // Supporting larger values for n would requires an even more\n    // elaborate implementation that combines multiple calls to rand()\n    assert (n &lt;= RAND_MAX)\n\n    // Chop off all of the values that would cause skew...\n    int end = RAND_MAX / n; // truncate skew\n    assert (end &gt; 0);\n    end *= n;\n\n    // ... and ignore results from rand() that fall above that limit.\n    // (Worst case the loop condition should succeed 50% of the time,\n    // so we can expect to bail out of this loop pretty quickly.)\n    int r;\n    while ((r = rand()) &gt;= end);\n\n    return r % n;\n  }\n}\n",
            "randombytes\n/dev/urandom\n/dev/random\n#include \"sodium.h\"\n\nint foo()\n{\n    char myString[32];\n    uint32_t myInt;\n\n    if (sodium_init() &lt; 0) {\n        /* panic! the library couldn't be initialized, it is not safe to use */\n        return 1; \n    }\n\n\n    /* myString will be an array of 32 random bytes, not null-terminated */        \n    randombytes_buf(myString, 32);\n\n    /* myInt will be a random number between 0 and 9 */\n    myInt = randombytes_uniform(10);\n}\n\nrandombytes_uniform()",
            "srand()\nsrand()\ntime()\nrand()\n    #include &lt;stdio.h&gt;\n\n    int random_number(int min_num, int max_num);\n\n    int main(void)\n    {\n        printf(&quot;Min : 1 Max : 40 %d\\n&quot;, random_number(1,40));\n        printf(&quot;Min : 100 Max : 1000 %d\\n&quot;,random_number(100,1000));\n        return 0;\n    }\n\n    int random_number(int min_num, int max_num)\n    {\n        int result = 0, low_num = 0, hi_num = 0;\n\n        if (min_num &lt; max_num)\n        {\n            low_num = min_num;\n            hi_num = max_num + 1; // include max_num in output\n        } else {\n            low_num = max_num + 1; // include max_num in output\n            hi_num = min_num;\n        }\n\n        srand(time(NULL));\n        result = (rand() % (hi_num - low_num)) + low_num;\n        return result;\n    }\n",
            "stdlib",
            "rand()\nrand()\nrand()\nsrand()\n#include &lt;stdint.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;openssl/rand.h&gt;\n\n/* Random integer in [0, limit) */\nunsigned int random_uint(unsigned int limit) {\n    union {\n        unsigned int i;\n        unsigned char c[sizeof(unsigned int)];\n    } u;\n\n    do {\n        if (!RAND_bytes(u.c, sizeof(u.c))) {\n            fprintf(stderr, \"Can't get random bytes!\\n\");\n            exit(1);\n        }\n    } while (u.i &lt; (-limit % limit)); /* u.i &lt; (2**size % limit) */\n    return u.i % limit;\n}\n\n/* Random double in [0.0, 1.0) */\ndouble random_double() {\n    union {\n        uint64_t i;\n        unsigned char c[sizeof(uint64_t)];\n    } u;\n\n    if (!RAND_bytes(u.c, sizeof(u.c))) {\n        fprintf(stderr, \"Can't get random bytes!\\n\");\n        exit(1);\n    }\n    /* 53 bits / 2**53 */\n    return (u.i &gt;&gt; 11) * (1.0/9007199254740992.0);\n}\n\nint main() {\n    printf(\"Dice: %d\\n\", (int)(random_uint(6) + 1));\n    printf(\"Double: %f\\n\", random_double());\n    return 0;\n}\n\nrand() % 10000\nrand()\nrand()\ndouble\nrand() / (double)RAND_MAX\nrand()\nRAND_bytes()\n/dev/urandom\n/dev/urandom\nsrand()\n/dev/urandom",
            "arc4random\nrand\narc4random\nuint32_t arc4random(void)\nvoid arc4random_buf(void *buf, size_t bytes)\nuint32_t arc4random_uniform(uint32_t limit)\nvoid arc4random_stir(void)\nvoid arc4random_addrandom(unsigned char *dat, int datlen)\n\narc4random\narc4random_buf\nbuf : void *\nbytes : size_t\narc4random_uniform\n0 &lt;= arc4random_uniform(limit) &lt; limit\narc4random_stir\n/dev/urandom\narc4random_addrandom\narc4random_addrandom\narc4random_stir\n/* This is C, not C++ */\n#include &lt;sys/types.h&gt;\n#include &lt;sys/stat.h&gt;\n#include &lt;fcntl.h&gt;\n#include &lt;errno.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;stdlib.h&gt; /* exit */\n#include &lt;stdio.h&gt; /* printf */\n\nint urandom_fd = -2;\n\nvoid urandom_init() {\n  urandom_fd = open(&quot;/dev/urandom&quot;, O_RDONLY);\n\n  if (urandom_fd == -1) {\n    int errsv = urandom_fd;\n    printf(&quot;Error opening [/dev/urandom]: %i\\n&quot;, errsv);\n    exit(1);\n  }\n}\n\nunsigned long urandom() {\n  unsigned long buf_impl;\n  unsigned long *buf = &amp;buf_impl;\n\n  if (urandom_fd == -2) {\n    urandom_init();\n  }\n\n  /* Read sizeof(long) bytes (usually 8) into *buf, which points to buf_impl */\n  read(urandom_fd, buf, sizeof(long));\n  return buf_impl;\n}\n\nurandom_init\n/dev/urandom\nurandom_fd\nurandom\nrand\nlong\n/dev/urandom\n/dev/urandom\n/dev/random\nopen\nurandom_init\nurandom_init\nurandom\n/dev/urandom\n/dev/random\nrand\nurandom\nrand\narc4random\n#define RAND_IMPL /* urandom(see large code block) | rand | arc4random */\n\nint myRandom(int bottom, int top){\n    return (RAND_IMPL() % (top - bottom)) + bottom;\n}\n",
            "rand\nrandom\nstdlib.h\nrand\nrandom\nrand\nrandom\nrandom\nrand\nrand\nrand",
            "rand()",
            "#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;time.h&gt;\n\n    #define randnum(min, max) \\\n        ((rand() % (int)(((max) + 1) - (min))) + (min))\n\nint main()\n{\n    srand(time(NULL));\n\n    printf(\"%d\\n\", randnum(1, 70));\n}\n\nrandnum",
            "srand(time(NULL))\n\nman srand\ntime\nsrand(time(NULL) | getHashOfString(outputName))\n\nclock_gettime\n#include&lt;time.h&gt;\nstruct timespec nanos;\nclock_gettime(CLOCK_MONOTONIC, &amp;nanos)\nsrand(nanos.tv_nsec);\n\n#include&lt;time.h&gt;\nstruct timespec nanos;\nclock_gettime(CLOCK_MONOTONIC, &amp;nanos)\nsrand(nanos.tv_nsec | getHashOfString(outputName));\n",
            "rand()\nsrand()\nint rand(void);\n\nvoid srand(unsigned seed);\n\nrandom()\nlong random(void);\n\nrandom()",
            "stdlib.h\nrand",
            "srand(time(NULL))\n#include &lt;time.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main(int argc, char **argv)\n{\n    srand((unsigned int)**main + (unsigned int)&amp;argc + (unsigned int)time(NULL));\n    srand(rand());\n\n    for (int i = 0; i &lt; 10; i++)\n        printf(\"%d\\n\", rand());\n}\n",
            "#include &lt;time.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main()\n{\n    srand(time(NULL));\n    int lowerLimit = 10, upperLimit = 50;\n    int r =  lowerLimit + rand() % (upperLimit - lowerLimit);\n    printf(\"%d\", r);\n}\n",
            "_rdrand64_step()\n#include &lt;immintrin.h&gt;\n\nuint64_t randVal;\nif(!_rdrand64_step(&amp;randVal)) {\n  // Report an error here: random number generation has failed!\n}\n// If no error occured, randVal contains a random 64-bit number\n",
            "rand()",
            "#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nvoid main() \n{\n    int visited[100];\n    int randValue, a, b, vindex = 0;\n\n    randValue = (rand() % 100) + 1;\n\n    while (vindex &lt; 100) {\n        for (b = 0; b &lt; vindex; b++) {\n            if (visited[b] == randValue) {\n                randValue = (rand() % 100) + 1;\n                b = 0;\n            }\n        }\n\n        visited[vindex++] = randValue;\n    }\n\n    for (a = 0; a &lt; 100; a++)\n        printf(\"%d \", visited[a]);\n}\n",
            "rand()\nrand()\nrand()\nrand()\nsrand()\nrandom(3)\nsrandom(3)\nrandom(3)\nrandom()\nrand()\nrandom()\nrandom()\nlrand48()\nmrand48()\narc4random()",
            "#include &lt;stdio.h&gt;\n#include &lt;dos.h&gt;\n\nint random(int range);\n\nint main(void)\n{\n    printf(\"%d\", random(10));\n    return 0;\n}\n\nint random(int range)\n{\n    struct time t;\n    int r;\n\n    gettime(&amp;t);\n    r = t.ti_sec % range;\n    return r;\n}\n",
            "#include&lt;stdio.h&gt;\n#include&lt;stdlib.h&gt;\n#include&lt;time.h&gt;\n\n//generate number in range [min,max)\nint random(int min, int max){\n    int number = min + rand() % (max - min);\n    return number; \n}\n\n//Driver code\nint main(){\n    srand(time(NULL));\n    for(int i = 1; i &lt;= 10; i++){\n        printf(\"%d\\t\", random(10, 100));\n    }\n    return 0;\n}\n",
            "urandom_open()\nint gUrandomFd = -1;\n\nint urandom_open(void)\n{\n    if (gUrandomFd == -1) {\n        gUrandomFd = open(\"/dev/urandom\", O_RDONLY);\n    }\n\n    if (gUrandomFd == -1) {\n        fprintf(stderr, \"Error opening /dev/urandom: errno [%d], strerrer [%s]\\n\",\n                  errno, strerror(errno));\n        return -1;\n    } else {\n        return 0;\n    }\n}\n\n\nvoid urandom_close(void)\n{\n    close(gUrandomFd);\n    gUrandomFd = -1;\n}\n\n\n//\n// This link essentially validates the merits of /dev/urandom:\n// http://sockpuppet.org/blog/2014/02/25/safely-generate-random-numbers/\n//\nint getRandomBuffer(uint8_t *buf, int size)\n{\n    int ret = 0; // Return value\n\n    if (gUrandomFd == -1) {\n        fprintf(stderr, \"Urandom (/dev/urandom) file not open\\n\");\n        return -1;\n    }\n\n    ret = read(gUrandomFd, buf, size);\n\n    if (ret != size) {\n        fprintf(stderr, \"Only read [%d] bytes, expected [%d]\\n\",\n                 ret, size);\n        return -1;\n    } else {\n        return 0;\n    }\n}\n",
            "rand()\nINT_MIN\nINT_MAX\nrand()\n0\nRAND_MAX\nconst int MIN = 1;\nconst int MAX = 1024;\n// Get a pseudo-random number between MIN and MAX, **inclusive**.\n// Seeding of the pseudo-random number generator automatically occurs\n// the very first time you call it.\nint random_num = utils_rand(MIN, MAX);\n\n#include &lt;assert.h&gt;\n#include &lt;stdbool.h&gt;\n#include &lt;stdlib.h&gt;\n\n/// \\brief      Use linear interpolation to rescale, or &quot;map&quot; value `val` from range\n///             `in_min` to `in_max`, inclusive, to range `out_min` to `out_max`, inclusive.\n/// \\details    Similar to Arduino's ingenious `map()` function:\n///             https://www.arduino.cc/reference/en/language/functions/math/map/\n///\n/// TODO(gabriel): turn this into a gcc statement expression instead to prevent the potential for\n/// the &quot;double evaluation&quot; bug. See `MIN()` and `MAX()` above.\n#define UTILS_MAP(val, in_min, in_max, out_min, out_max) \\\n    (((val) - (in_min)) * ((out_max) - (out_min)) / ((in_max) - (in_min)) + (out_min))\n\n/// \\brief      Obtain a pseudo-random integer value between `min` and `max`, **inclusive**.\n/// \\details    1. If `(max - min + 1) &gt; RAND_MAX`, then the range of values returned will be\n///             **scaled** to the range `max - min + 1`, and centered over the center of the\n///             range at `(min + max)/2`. Scaling the numbers means that in the case of scaling,\n///             not all numbers can even be reached. However, you will still be assured to have\n///             a random distribution of numbers across the full range.\n///             2. Also, the first time per program run that you call this function, it will\n///             automatically seed the pseudo-random number generator with your system's\n///             current time in seconds.\n/// \\param[in]  min         The minimum pseudo-random number you'd like, inclusive. Can be positive\n///                         OR negative.\n/// \\param[in]  max         The maximum pseudo-random number you'd like, inclusive. Can be positive\n///                         OR negative.\n/// \\return     A pseudo-random integer value between `min` and `max`, **inclusive**.\nint utils_rand(int min, int max)\n{\n    static bool first_run = true;\n    if (first_run)\n    {\n        // seed the pseudo-random number generator with the seconds time the very first run\n        time_t time_now_sec = time(NULL);\n        srand(time_now_sec);\n        first_run = false;\n    }\n\n    int range = max - min + 1;\n    int random_num = rand();  // random num from 0 to RAND_MAX, inclusive\n\n    if (range &gt; RAND_MAX)\n    {\n        static_assert(\n            sizeof(long int) &gt; sizeof(int),\n            &quot;This must be true or else the below mapping/scaling may have undefined overflow &quot;\n            &quot;and not work properly. In such a case, try casting to `long long int` instead of &quot;\n            &quot;just `long int`, and update this static_assert accordingly.&quot;);\n\n        random_num = UTILS_MAP((long int)random_num, (long int)0, (long int)RAND_MAX, (long int)min,\n                               (long int)max);\n        return random_num;\n    }\n\n    // This is presumably a faster approach than the map/scaling function above, so do this faster\n    // approach below whenever you don't **have** to do the more-complicated approach above.\n    random_num %= range;\n    random_num += min;\n\n    return random_num;\n}\n\n",
            "/dev/urandom\n/dev/random\nread\nfread\n/dev/random\n/dev/urandom\nentropy_avail\nioctl",
            "random()\nrandom_r()\nstruct random_data\ninitstate_r()\nrandom_r()\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#include &lt;time.h&gt;\n\nvoid xxx (void) {\n    unsigned int seed = (unsigned int) time(NULL);\n    char rnd_state[17] = {0};\n    struct random_data rnd_st_buf = {0};\n    initstate_r(seed, &amp;rnd_state[0], 17, &amp;rnd_st_buf);\n    for(size_t idx = 0; idx &lt; 8; idx++) {\n        int32_t rnd_int = 0;\n        char rnd_seq_str[6] = {0};\n        random_r(&amp;rnd_st_buf, &amp;rnd_int);\n        memcpy((char *)&amp;rnd_seq_str[0], (char *)&amp;rnd_int, 4);\n        printf(&quot;random number : 0x%08x,  \\n&quot;, rnd_int);\n    }\n}\n",
            "#include &lt;stdlib.h&gt;\n#include &lt;stdio.h&gt;\n\ntypedef double rand_type; // change double to int\n\nrand_type my_rand() {\n    char buff[sizeof(rand_type)];\n    for (size_t i = 0 ; i &lt; sizeof(rand_type) ; ++i)\n        buff[i] = (char) rand();\n    return *(rand_type *) buff;\n}\n\nint main() {\n    int i ; // srand as you want\n    for (i = 0 ; i &lt; 10 ; ++i)\n        printf(&quot;%g\\n&quot;, my_rand()); // change %g to %d\n    return 0 ;\n}\n",
            "#include &lt;mgl2/mgl_cf.h&gt;\nmgl_rnd()",
            "srand()\ntime.h\n#include&lt;time.h&gt;\nlong long random_in_range (int range) {\n  struct timespec t ;\n  clock_gettime ( CLOCK_REALTIME , &amp; t ) ;\n  return (t.tv_sec * 1000 + ( t.tv_nsec + 500000 ) / 1000000) % range ;\n}\n",
            "int random() {\n    static  unsigned long long int x = 4694882287132787932;\n    return x ^= x &lt;&lt; 10, x ^= x &gt;&gt; 13, (int)(x ^= x &gt;&gt; 10);\n}\n\n-2074755801\n2063439557\n1142195322\n\nunsigned long long int random() {\n    static  unsigned long long int x = 4694882287132787932;\n    return x ^= x &lt;&lt; 10, x ^= x &gt;&gt; 13, x ^= x &gt;&gt; 10;\n}\n"
        ]
    },
    {
        "question_id": 17307275,
        "question_code": "_Bool\nbool\nstdbool.h\nprintf\nbool x = true;\nprintf(\"%B\\n\", x);\n\ntrue\n",
        "answer_code_snippets": [
            "bool\nint\nint\nprintf()\n%d\nbool x = true;\nprintf(&quot;%d\\n&quot;, x); // prints 1\n\nprintf(&quot;Your boolean variable is: %s&quot;, x ? &quot;true&quot; : &quot;false&quot;);\n",
            "bool\nprintf(&quot;%s&quot;, x?&quot;true&quot;:&quot;false&quot;);\n",
            "bool\n#include &lt;stdio.h&gt;\n#include &lt;printf.h&gt;\n#include &lt;stdbool.h&gt;\n\nstatic int bool_arginfo(const struct printf_info *info, size_t n,\n    int *argtypes, int *size)\n{\n  if (n) {\n    argtypes[0] = PA_INT;\n    *size = sizeof(bool);\n  }\n  return 1;\n}\nstatic int bool_printf(FILE *stream, const struct printf_info *info,\n    const void *const *args)\n{\n  bool b =  *(const bool*)(args[0]);\n  int r = fputs(b ? \"true\" : \"false\", stream);\n  return r == EOF ? -1 : (b ? 4 : 5);\n}\nstatic int setup_bool_specifier()\n{\n  int r = register_printf_specifier('B', bool_printf, bool_arginfo);\n  return r;\n}\nint main(int argc, char **argv)\n{\n  int r = setup_bool_specifier();\n  if (r) return 1;\n  bool b = argc &gt; 1;\n  r = printf(\"The result is: %B\\n\", b);\n  printf(\"(written %d characters)\\n\", r);\n  return 0;\n}\n",
            "itoa()\n#define btoa(x) ((x)?\"true\":\"false\")\n\nbool x = true;\nprintf(\"%s\\n\", btoa(x));\n",
            "_Bool b = 1;\nprintf(\"%d\\n\", b);\n",
            "printf(\"%d\\n\", !!(42));\n\n#define MY_FLAG (1 &lt;&lt; 4)\nint flags = MY_FLAG;\nprintf(\"%d\\n\", !!(flags &amp; MY_FLAG));\n",
            "printf(\"%s\\n\", \"false\\0true\"+6*x);\n",
            "#include &lt;ios&gt;\n#include &lt;iostream&gt;\n\nbool b = IsSomethingTrue();\nstd::cout &lt;&lt; std::boolalpha &lt;&lt; b;\n"
        ]
    },
    {
        "question_id": 12887700,
        "question_code": "#ifdef __cplusplus",
        "answer_code_snippets": [
            "#include &lt;stdio.h&gt;\n\nstruct f { int x; };\n\nint main() {\n    f();\n}\n\nint f() {\n    return printf(&quot;hello&quot;);\n}\n\nf\nhello\nf\nstruct f\nstruct",
            "int a = 10 //* comment */ 2 \n        + 3;\n\n//\nint a = 10 + 3;\n\n/* comment */\n/\n2\nint a = 10 / 2 + 3;\n",
            "i\nint i = sizeof('a');\n\n#include &lt;stdio.h&gt;\n\nint  sz = 80;\n\nint main(void)\n{\n    struct sz { char c; };\n\n    int val = sizeof(sz);      // sizeof(int) in C,\n                               // sizeof(struct sz) in C++\n    printf(\"%d\\n\", val);\n    return 0;\n}\n",
            "int\ndouble\n#include &lt;stdio.h&gt;\n\nint main()\n{\n  auto j = 1.5;\n  printf(\"%d\", (int)sizeof(j));\n  return 0;\n}\n\nauto\nint\nauto",
            "#include &lt;stdio.h&gt;\nint main()\n{\n#if true\n    printf(\"true!\\n\");\n#else\n    printf(\"false!\\n\");\n#endif\n    return 0;\n}\n",
            "   char arr[100];\n   int s = sizeof(0, arr);       // The comma operator is used.\n\nsizeof(char*)\n   enum E { a, b, c };\n   sizeof(a) == sizeof(int);     // In C\n   sizeof(a) == sizeof(E);       // In C++\n\nsizeof(int)\nsizeof(E)\n   int f();           // int f(void) in C++\n                      // int f(*unknown*) in C\n",
            "1\n0\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main(void)\n{\n    int d = (int)(abs(0.6) + 0.5);\n    printf(\"%d\", d);\n    return 0;\n}\n\ndouble abs(double)\nabs(0.6)\n0.6\n0\nint abs(int)\nfabs\ndouble",
            "sizeof\n#include &lt;stdio.h&gt;\nint main() {\n    printf(\"%d\\n\", (int)sizeof !0);\n}\n\nsizeof(int)\nint",
            "#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    printf(\"%d\\n\", (int)sizeof('a'));\n    return 0;\n}\n\nsizeof(int)\n4",
            "//\nint f(int a, int b)\n{\n    return a //* blah */ b\n        ;\n}\n",
            "...\nint a = 4 //* */ 2\n        +2;\nprintf(\"%i\\n\",a);\n...\n",
            "#include &lt;stdio.h&gt;\n\nint x[1];\nint main(void) {\n    struct x { int a[2]; };\n    /* size of the array in C */\n    /* size of the struct in C++ */\n    printf(\"%d\\n\", (int)sizeof(x)); \n}\n",
            "#include &lt;stdio.h&gt;\n\nstruct fun{};\n\nint main()\n{\n    fun();  // In C, this calls the inline function from file 2 where as in C++\n            // this would create a variable of struct fun\n    return 0;\n}\n\n#include &lt;stdio.h&gt;\ninline void fun(void)\n{\n    printf(\"I am inline\\n\");\n} \n\nconst\nstatic\nextern\nextern",
            "#include &lt;stdio.h&gt;\n\nstruct A {\n    double a[32];\n};\n\nint main() {\n    struct B {\n        struct A {\n            short a, b;\n        } a;\n    };\n    printf(\"%d\\n\", sizeof(struct A));\n    return 0;\n}\n\n128\n32 * sizeof(double)\n4",
            "struct abort\n{\n    int x;\n};\n\nint main()\n{\n    abort();\n    return 0;\n}\n\nstruct exit\n{\n    int x;\n};\n\nint main()\n{\n    struct exit code;\n    code.x=1;\n\n    exit(code);\n\n    return 0;\n}\n",
            "#include &lt;cstdio&gt;\n\nvoid foo(int r)\n{\n  printf(\"I am C++\\n\");\n}\n\n#include &lt;stdio.h&gt;\n\nvoid foo(int r)\n{\n  printf(\"I am C\\n\");\n}\n\nextern void foo(int);\n\nint main(void)\n{\n  foo(1);\n  return 0;\n}\n\n$ diff main.cpp main.c\n$ gcc -o test main.cpp foo.cpp foo2.c\n$ ./test \nI am C++\n$ gcc -o test main.c foo.cpp foo2.c\n$ ./test \nI am C\n",
            "int main(void) {\n    const int dim = 5; \n    int array[dim];\n}\n\nsizeof array\nint main(void) {\n    const int dim = 5; \n    int array[dim] = {0};\n}\n",
            "$ cat t436.c\n#include &lt;stdio.h&gt;\n\nint x;\nstruct\n{\n    char x;\n    int y[sizeof x];\n} z;\n\nint main(void)\n{\n    printf(&quot;%d\\n&quot;, sizeof(z)); //possible output: 20 in C, 8 in C++\n    return 0;\n}\n\n$ gcc -xc t436.c &amp;&amp; ./a.exe\n20\n\n$ gcc -xc++ t436.c &amp;&amp; ./a.exe\n8\n",
            "#include &lt;stdio.h&gt;\n\ntypedef struct {} Foo;\n\nint main()\n{\n    printf(\"%zd\\n\", sizeof(Foo));\n    return 0;\n}\n",
            "=\nint a = 5;\na++ = 2;  /* error: lvalue required as left operand of assignment */\n++a = 2;  /* error: lvalue required as left operand of assignment */\n\n=\nint a = 5;\na++ = 2;  // error: lvalue required as left operand of assignment\n++a = 2;  // No error: a gets assigned to 2!\n\nint x = a;\nint x = ++a;\n\nint a;\na = 2;\n++a = 2;  // Valid in C++.\n"
        ]
    },
    {
        "question_id": 1716296,
        "question_code": "printf\nprintf",
        "answer_code_snippets": [
            "stdout\nstderr\nfprintf\nstderr\nfprintf(stderr, &quot;I will be printed immediately&quot;);\n\nstdout\nfflush\nprintf(&quot;Buffered, will be flushed&quot;);\nfflush(stdout); // Will now print everything in the stdout buffer\n\nsetbuf\nsetbuf(stdout, NULL);\n\nsetvbuf\nsetvbuf(stdout, NULL, _IONBF, 0); \n",
            "printf\nmyprog &gt;myfile.txt\n\nfflush (stdout)\nsetvbuf\nstdout\nfflush\nsetvbuf (stdout, NULL, _IONBF, BUFSIZ);\n\n7.19.3/3\nsetbuf\nsetvbuf",
            "fflush(stdout)\nfflush(NULL)\nNULL",
            "program A output\nprogram B output\nprogram B output\nprogram A output\nprogram B output\n\nproprogrgraam m AB  ououtputputt\nprproogrgram amB A  ououtputtput\nprogram B output\n",
            "printf(\"will print immediately to terminal\")",
            "setbuf(stdout, NULL);",
            "fprintf and write()\nfprintf()\nsetbuff(stream,NULL)\nfflush(FILE *stream)\nread()\nfscanf()\nfprintf()\nwrite()\nO_SYNC\nfsync(),fdatasync(),sync()"
        ]
    },
    {
        "question_id": 4955198,
        "question_code": "",
        "answer_code_snippets": [
            "p\nconst char* p = \"abc\";\n\np\np\nMemory Address (hex)    Variable name    Contents\n1000                                     'a' == 97 (ASCII)\n1001                                     'b' == 98\n1002                                     'c' == 99\n1003                                     0\n...\n2000-2003               p                1000 hex\n\np\np\np\nassert(*p == 'a');  // The first character at address p will be 'a'\nassert(p[1] == 'b'); // p[1] actually dereferences a pointer created by adding\n                     // p and 1 times the size of the things to which p points:\n                     // In this case they're char which are 1 byte in C...\nassert(*(p + 1) == 'b');  // Another notation for p[1]\n\n++p;  // Increment p so it's now 0x1001\nassert(*p == 'b');  // p == 0x1001 which is where the 'b' is...\n\nint x = 2;\nint* p_x = &amp;x;  // Put the address of the x variable into the pointer p_x\n*p_x = 4;       // Change the memory at the address in p_x to be 4\nassert(x == 4); // Check x is now 4\n\nx\n&amp;x\n-&gt;\ntypedef struct X { int i_; double d_; } X;\nX x;\nX* p = &amp;x;\np-&gt;d_ = 3.14159;  // Dereference and access data member x.d_\n(*p).d_ *= -1;    // Another equivalent notation for accessing x.d_\n\ndouble sizes[] = { 10.3, 13.4, 11.2, 19.4 };\ndouble* p = sizes;\nassert(p[0] == 10.3);  // Knows to look at all the bytes in the first double value\nassert(p[1] == 13.4);  // Actually looks at bytes from address p + 1 * sizeof(double)\n                       // (sizeof(double) is almost always eight bytes)\n++p;                   // Advance p by sizeof(double)\nassert(*p == 13.4);    // The double at memory beginning at address p has value 13.4\n*(p + 2) = 29.8;       // Change sizes[3] from 19.4 to 29.8\n                       // Note earlier ++p and + 2 here =&gt; sizes[3]\n\nmalloc\nint* p = (int*)malloc(sizeof(int)); // Get some memory somewhere...\n*p = 10;            // Dereference the pointer to the memory, then write a value in\nfn(*p);             // Call a function, passing it the value at address p\n(*p) += 3;          // Change the value, adding 3 to it\nfree(p);            // Release the memory back to the heap allocation library\n\nnew\ndelete\nint* p = new int(10); // Memory for one int with initial value 10\ndelete p;\n\np = new int[10];      // Memory for ten ints with unspecified initial value\ndelete[] p;\n\np = new int[10]();    // Memory for ten ints that are value initialised (to 0)\ndelete[] p;\n\nfree()\ndelete\nconst char* p = asprintf(\"name: %s\", name);  // Common but non-Standard printf-on-heap\n\n// Replace non-printable characters with underscores....\nfor (const char* q = p; *q; ++q)\n    if (!isprint(*q))\n        *q = '_';\n\nprintf(\"%s\\n\", p); // Only q was modified\nfree(p);\n\nconst size_t n = ...;\np += n;\n...\np -= n;  // Restore earlier value...\nfree(p);\n\nunique_ptr\n{\n    std::unique_ptr&lt;T&gt; p{new T(42, \"meaning\")};\n    call_a_function(p);\n    // The function above might throw, so delete here is unreliable, but...\n} // p's destructor's guaranteed to run \"here\", calling delete\n\nshared_ptr\n{\n    auto p = std::make_shared&lt;T&gt;(3.14, \"pi\");\n    number_storage1.may_add(p); // Might copy p into its container\n    number_storage2.may_add(p); // Might copy p into its container    } // p's destructor will only delete the T if neither may_add copied it\n\nNULL\n0\nnullptr\nconst char* p_filename = NULL; // Or \"= 0\", or \"= nullptr\" in C++\nint c;\nwhile ((c = getopt(argc, argv, \"f:\")) != -1)\n    switch (c) {\n      case f: p_filename = optarg; break;\n    }\nif (p_filename)  // Only NULL converts to false\n    ...   // Only get here if -f flag specified\n\n0\nbools\nfalse\nNULL\nstatic\nnew T();\nnew T(x, y, z);\nnew T;\n0\nNULL\nnullptr\n0\nNULL\nnullptr\nNULL\nint*\nint\nfloat*\nint\nint*",
            "int a = 10;\nint* ptr = &amp;a;\n\nprintf(\"%d\", *ptr); // With *ptr I'm dereferencing the pointer. \n                    // Which means, I am asking the value pointed at by the pointer.\n                    // ptr is pointing to the location in memory of the variable a.\n                    // In a's location, we have 10. So, dereferencing gives this value.\n\n// Since we have indirect control over a's location, we can modify its content using the pointer. This is an indirect way to access a.\n\n *ptr = 20;         // Now a's content is no longer 10, and has been modified to 20.\n",
            "int a=4 ;\nint *pA = &amp;a ;\nprintf( \"The REFERENCE/call number for the variable `a` is %p\\n\", pA ) ;\n\n// The * causes pA to DEREFERENCE...  `a` via \"callnumber\" `pA`.\nprintf( \"%d\\n\", *pA ) ; // prints 4.. \n",
            "void main() {   \n    int*    x;  // Allocate the pointer x\n    x = malloc(sizeof(int));    // Allocate an int pointee,\n                            // and set x to point to it\n    *x = 42;    // Dereference x to store 42 in its pointee   \n}\n",
            "char *p = NULL;\n*p;\n\np1 = &amp;(*p);\nsz = sizeof(*p);\n"
        ]
    },
    {
        "question_id": 11694546,
        "question_code": "*\n/\n+\n-\n%",
        "answer_code_snippets": [
            "+\n// replaces the + operator\nint add(int x, int y)\n{\n    while (x) {\n        int t = (x &amp; y) &lt;&lt; 1;\n        y ^= x;\n        x = t;\n    }\n    return y;\n}\n\nint divideby3(int num)\n{\n    int sum = 0;\n    while (num &gt; 3) {\n        sum = add(num &gt;&gt; 2, sum);\n        num = add(num &gt;&gt; 2, num &amp; 3);\n    }\n    if (num == 3)\n        sum = add(sum, 1);\n    return sum; \n}\n\nn = 4 * a + b\nn / 3 = a + (a + b) / 3\nsum += a\nn = a + b\na == 0 (n &lt; 4)\nsum += floor(n / 3);\nif n == 3, else 0",
            "#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main()\n{\n    FILE * fp=fopen(\"temp.dat\",\"w+b\");\n    int number=12346;\n    int divisor=3;\n    char * buf = calloc(number,1);\n    fwrite(buf,number,1,fp);\n    rewind(fp);\n    int result=fread(buf,divisor,number,fp);\n    printf(\"%d / %d = %d\", number, divisor, result);\n    free(buf);\n    fclose(fp);\n    return 0;\n}\n\nresult\ndouble\nfmod(number,divisor)\nfwrite\nnumber\nrewind\nfread\nnumber\ndivisor",
            "log(pow(exp(number),0.33333333333333333333)) /* :-) */\n",
            "#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main(int argc, char *argv[])\n{\n\n    int num = 1234567;\n    int den = 3;\n    div_t r = div(num,den); // div() is a standard C function.\n    printf(\"%d\\n\", r.quot);\n\n    return 0;\n}\n",
            "#include &lt;stdio.h&gt;\n\nint main() {\n  int dividend = -42, divisor = 5, quotient, remainder;\n\n  __asm__ ( \"cdq; idivl %%ebx;\"\n          : \"=a\" (quotient), \"=d\" (remainder)\n          : \"a\"  (dividend), \"b\"  (divisor)\n          : );\n\n  printf(\"%i / %i = %i, remainder: %i\\n\", dividend, divisor, quotient, remainder);\n  return 0;\n}\n",
            "// Note: itoa is non-standard but actual implementations\n// don't seem to handle negative when base != 10.\nint div3(int i) {\n    char str[42];\n    sprintf(str, \"%d\", INT_MIN); // Put minus sign at str[0]\n    if (i&gt;0)                     // Remove sign if positive\n        str[0] = ' ';\n    itoa(abs(i), &amp;str[1], 3);    // Put ternary absolute value starting at str[1]\n    str[strlen(&amp;str[1])] = '\\0'; // Drop last digit\n    return strtol(str, NULL, 3); // Read back result\n}\n",
            "+\n+\nunsigned div_by(unsigned const x, unsigned const by) {\n  unsigned floor = 0;\n  for (unsigned cmp = 0, r = 0; cmp &lt;= x;) {\n    for (unsigned i = 0; i &lt; by; i++)\n      cmp++; // that's not the + operator!\n    floor = r;\n    r++; // neither is this.\n  }\n  return floor;\n}\n\ndiv_by(100,3)\n100\n3\n++\nunsigned inc(unsigned x) {\n  for (unsigned mask = 1; mask; mask &lt;&lt;= 1) {\n    if (mask &amp; x)\n      x &amp;= ~mask;\n    else\n      return x &amp; mask;\n  }\n  return 0; // overflow (note that both x and mask are 0 here)\n}\n\n+\n-\n*\n/\n%\nunsigned add(char const zero[], unsigned const x, unsigned const y) {\n  // this exploits that &amp;foo[bar] == foo+bar if foo is of type char*\n  return (int)(uintptr_t)(&amp;((&amp;zero[x])[y]));\n}\n\nunsigned div_by(unsigned const x, unsigned const by) {\n  unsigned floor = 0;\n  for (unsigned cmp = 0, r = 0; cmp &lt;= x;) {\n    cmp = add(0,cmp,by);\n    floor = r;\n    r = add(0,r,1);\n  }\n  return floor;\n}\n\nadd\n*\ntype[]\ntype* const\n0x55555556\nint mul(int const x, int const y) {\n  return sizeof(struct {\n    char const ignore[y];\n  }[x]);\n}\n",
            "public static int div_by_3(long a) {\n    a &lt;&lt;= 30;\n    for(int i = 2; i &lt;= 32 ; i &lt;&lt;= 1) {\n        a = add(a, a &gt;&gt; i);\n    }\n    return (int) (a &gt;&gt; 32);\n}\n\npublic static long add(long a, long b) {\n    long carry = (a &amp; b) &lt;&lt; 1;\n    long sum = (a ^ b);\n    return carry == 0 ? sum : add(carry, sum);\n}\n\n1/3 = 1/4 + 1/16 + 1/64 + ...\n\na/3 = a * 1/3  \na/3 = a * (1/4 + 1/16 + 1/64 + ...)\na/3 = a/4 + a/16 + 1/64 + ...\na/3 = a &gt;&gt; 2 + a &gt;&gt; 4 + a &gt;&gt; 6 + ...\n\n11 + 6\n\n1011 + 0110  \nsum = 1011 ^ 0110 = 1101  \ncarry = (1011 &amp; 0110) &lt;&lt; 1 = 0010 &lt;&lt; 1 = 0100  \nNow you recurse!\n\n1101 + 0100  \nsum = 1101 ^ 0100 = 1001  \ncarry = (1101 &amp; 0100) &lt;&lt; 1 = 0100 &lt;&lt; 1 = 1000  \nAgain!\n\n1001 + 1000  \nsum = 1001 ^ 1000 = 0001  \ncarry = (1001 &amp; 1000) &lt;&lt; 1 = 1000 &lt;&lt; 1 = 10000  \nOne last time!\n\n0001 + 10000\nsum = 0001 ^ 10000 = 10001 = 17  \ncarry = (0001 &amp; 10000) &lt;&lt; 1 = 0\n\nDone!\n\n111\n 1011\n+0110\n-----\n10001\n\na / 3 = a/4 + a/4^2 + a/4^3 + ... + a/4^i + ... = f(a, i) + a * 1/3 * 1/4^i\nf(a, i) = a/4 + a/4^2 + ... + a/4^i\n\ndiv_by_3(a)\nx &lt;= floor(f(a, i)) &lt; a / 3\na = 3k",
            "0x55555556",
            "public static int DivideBy3(int a) {\n    bool negative = a &lt; 0;\n    if (negative) a = Negate(a);\n    int result;\n    int sub = 3 &lt;&lt; 29;\n    int threes = 1 &lt;&lt; 29;\n    result = 0;\n    while (threes &gt; 0) {\n        if (a &gt;= sub) {\n            a = Add(a, Negate(sub));\n            result = Add(result, threes);\n        }\n        sub &gt;&gt;= 1;\n        threes &gt;&gt;= 1;\n    }\n    if (negative) result = Negate(result);\n    return result;\n}\npublic static int Negate(int a) {\n    return Add(~a, 1);\n}\npublic static int Add(int a, int b) {\n    int x = 0;\n    x = a ^ b;\n    while ((a &amp; b) != 0) {\n        b = (a &amp; b) &lt;&lt; 1;\n        a = x;\n        x = a ^ b;\n    }\n    return x;\n}\n",
            "if (number == 0) return 0;\nif (number == 1) return 0;\nif (number == 2) return 0;\nif (number == 3) return 1;\nif (number == 4) return 1;\nif (number == 5) return 1;\nif (number == 6) return 2;\n\n/",
            "int DivBy3(int num) {\n    int result = 0;\n    int counter = 0;\n    while (1) {\n        if (num == counter)       //Modulus 0\n            return result;\n        counter = abs(~counter);  //++counter\n\n        if (num == counter)       //Modulus 1\n            return result;\n        counter = abs(~counter);  //++counter\n\n        if (num == counter)       //Modulus 2\n            return result;\n        counter = abs(~counter);  //++counter\n\n        result = abs(~result);    //++result\n    }\n}\n",
            "#include &lt;stdio.h&gt;\n#include &lt;stdint.h&gt;\n\nint main()\n{\n  uint32_t mod3[6] = { 0,1,2,0,1,2 };\n  uint32_t x = 1234567; // number to divide, and remainder at the end\n  uint32_t y = 0; // result\n  int bit = 31; // current bit\n  printf(\"X=%u   X/3=%u\\n\",x,x/3); // the '/3' is for testing\n\n  while (bit&gt;0)\n  {\n    printf(\"BIT=%d  X=%u  Y=%u\\n\",bit,x,y);\n    // decrement bit\n    int h = 1; while (1) { bit ^= h; if ( bit&amp;h ) h &lt;&lt;= 1; else break; }\n    uint32_t r = x&gt;&gt;bit;  // current remainder in 0..5\n    x ^= r&lt;&lt;bit;          // remove R bits from X\n    if (r &gt;= 3) y |= 1&lt;&lt;bit; // new output bit\n    x |= mod3[r]&lt;&lt;bit;    // new remainder inserted in X\n  }\n  printf(\"Y=%u\\n\",y);\n}\n",
            "DIV\nfp-compiler\ndivide_by_3.pas\nunit Divide_By_3;\ninterface\n    function div_by_3(n: integer): integer; cdecl; export;\nimplementation\n    function div_by_3(n: integer): integer; cdecl;\n    begin\n        div_by_3 := n div 3;\n    end;\nend.\n\nmain.c\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nextern int div_by_3(int n);\n\nint main(void) {\n    int n;\n    fputs(\"Enter a number: \", stdout);\n    fflush(stdout);\n    scanf(\"%d\", &amp;n);\n    printf(\"%d / 3 = %d\\n\", n, div_by_3(n));\n    return 0;\n}\n\nfpc divide_by_3.pas &amp;&amp; gcc divide_by_3.o main.c -o main\n\n$ ./main\nEnter a number: 100\n100 / 3 = 33\n",
            "int div3(int x)\n{\n  int reminder = abs(x);\n  int result = 0;\n  while(reminder &gt;= 3)\n  {\n     result++;\n\n     reminder--;\n     reminder--;\n     reminder--;\n  }\n  return result;\n}\n",
            "#include &lt;stdio.h&gt;\n\nint main()\n{\n    int aNumber = 500;\n    int gResult = 0;\n\n    int aLoop = 0;\n\n    int i = 0;\n    for(i = 0; i &lt; aNumber; i++)\n    {\n        if(aLoop == 3)\n        {\n           gResult++;\n           aLoop = 0;\n        }  \n        aLoop++;\n    }\n\n    printf(\"Reulst of %d / 3 = %d\", aNumber, gResult);\n\n    return 0;\n}\n",
            "#include &lt;stdio.h&gt;\n\nunsigned sub(unsigned two, unsigned one);\nunsigned bitdiv(unsigned top, unsigned bot);\nunsigned sub(unsigned two, unsigned one)\n{\nunsigned bor;\nbor = one;\ndo      {\n        one = ~two &amp; bor;\n        two ^= bor;\n        bor = one&lt;&lt;1;\n        } while (one);\nreturn two;\n}\n\nunsigned bitdiv(unsigned top, unsigned bot)\n{\nunsigned result, shift;\n\nif (!bot || top &lt; bot) return 0;\n\nfor(shift=1;top &gt;= (bot&lt;&lt;=1); shift++) {;}\nbot &gt;&gt;= 1;\n\nfor (result=0; shift--; bot &gt;&gt;= 1 ) {\n        result &lt;&lt;=1;\n        if (top &gt;= bot) {\n                top = sub(top,bot);\n                result |= 1;\n                }\n        }\nreturn result;\n}\n\nint main(void)\n{\nunsigned arg,val;\n\nfor (arg=2; arg &lt; 40; arg++) {\n        val = bitdiv(arg,3);\n        printf(\"Arg=%u Val=%u\\n\", arg, val);\n        }\nreturn 0;\n}\n",
            "/\neval\nfunction div3 (n) {\n    var div = String.fromCharCode(47);\n    return eval([n, div, 3].join(\"\"));\n}\n",
            "irb(main):101:0&gt; div3 = -&gt; n { s = '%0' + n.to_s + 's'; (s % '').gsub('   ', ' ').size }\n=&gt; #&lt;Proc:0x0000000205ae90@(irb):101 (lambda)&gt;\nirb(main):102:0&gt; div3[12]\n=&gt; 4\nirb(main):103:0&gt; div3[666]\n=&gt; 222\n\nC",
            "&lt;?php\n    $a = 12345;\n    $b = bcdiv($a, 3);   \n?&gt;\n\n&gt; SELECT 12345 DIV 3;\n\na:= 12345;\nb:= a div 3;\n\nmov  r8, 3\nxor  rdx, rdx   \nmov  rax, 12345\nidiv r8\n",
            "int divideByThree(int num)\n{\n  return (fma(num, 1431655766, 0) &gt;&gt; 32);\n}\n\nmath.h",
            "* / + - %\n#!/usr/bin/env python3\n\nprint('''#include &lt;stdint.h&gt;\n#include &lt;stdio.h&gt;\nconst int32_t div_by_3(const int32_t input)\n{\n''')\n\nfor i in range(-2**31, 2**31):\n    print('    if(input == %d) return %d;' % (i, i / 3))\n\n\nprint(r'''\n    return 42; // impossible\n}\nint main()\n{\n    const int32_t number = 8;\n    printf(\"%d / 3 = %d\\n\", number, div_by_3(number));\n}\n''')\n",
            "x/3 = (x/4) / (1-1/4)\n\nx/(1-1/y)\n  = x * (1+y) / (1-y^2)\n  = x * (1+y) * (1+y^2) / (1-y^4)\n  = ...\n  = x * (1+y) * (1+y^2) * (1+y^4) * ... * (1+y^(2^i)) / (1-y^(2^(i+i))\n  = x * (1+y) * (1+y^2) * (1+y^4) * ... * (1+y^(2^i))\n\nint div3(int x) {\n    x &lt;&lt;= 6;    // need more precise\n    x += x&gt;&gt;2;  // x = x * (1+(1/2)^2)\n    x += x&gt;&gt;4;  // x = x * (1+(1/2)^4)\n    x += x&gt;&gt;8;  // x = x * (1+(1/2)^8)\n    x += x&gt;&gt;16; // x = x * (1+(1/2)^16)\n    return (x+1)&gt;&gt;8; // as (1-(1/2)^32) very near 1,\n                     // we plus 1 instead of div (1-(1/2)^32)\n}\n\n+",
            "#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\n\nint main()\n{\n    int number = 8;//Any +ve no.\n    int temp = 3, result = 0;\n    while(temp &lt;= number){\n        temp = fma(temp, 1, 3); //fma(a, b, c) is a library function and returns (a*b) + c.\n        result = fma(result, 1, 1);\n    } \n    printf(\"\\n\\n%d divided by 3 = %d\\n\", number, result);\n}\n",
            "private int dividedBy3(int n) {\n        List&lt;Object&gt; a = new Object[n].ToList();\n        List&lt;Object&gt; b = new List&lt;object&gt;();\n        while (a.Count &gt; 2) {\n            a.RemoveRange(0, 3);\n            b.Add(new Object());\n        }\n        return b.Count;\n    }\n",
            "[02:31:59] [william@relativity ~]$ cat div3.c\n#import &lt;stdio.h&gt;\n#import &lt;Accelerate/Accelerate.h&gt;\n\nint main() {\n    float multiplicand = 123456.0;\n    float multiplier = 0.333333;\n    printf(\"%f * %f == \", multiplicand, multiplier);\n    cblas_sscal(1, multiplier, &amp;multiplicand, 1);\n    printf(\"%f\\n\", multiplicand);\n}\n\n[02:32:07] [william@relativity ~]$ clang div3.c -framework Accelerate -o div3 &amp;&amp; ./div3\n123456.000000 * 0.333333 == 41151.957031\n",
            "log(pow(exp(numerator),pow(denominator,-1)))",
            "with Ada.Text_IO;\n\nprocedure Divide_By_3 is\n\n   protected type Divisor_Type is\n      entry Poke;\n      entry Finish;\n   private\n      entry Release;\n      entry Stop_Emptying;\n      Emptying : Boolean := False;\n   end Divisor_Type;\n\n   protected type Collector_Type is\n      entry Poke;\n      entry Finish;\n   private\n      Emptying : Boolean := False;\n   end Collector_Type;\n\n   task type Input is\n   end Input;\n   task type Output is\n   end Output;\n\n   protected body Divisor_Type is\n      entry Poke when not Emptying and Stop_Emptying'Count = 0 is\n      begin\n         requeue Release;\n      end Poke;\n      entry Release when Release'Count &gt;= 3 or Emptying is\n         New_Output : access Output;\n      begin\n         if not Emptying then\n            New_Output := new Output;\n            Emptying := True;\n            requeue Stop_Emptying;\n         end if;\n      end Release;\n      entry Stop_Emptying when Release'Count = 0 is\n      begin\n         Emptying := False;\n      end Stop_Emptying;\n      entry Finish when Poke'Count = 0 and Release'Count &lt; 3 is\n      begin\n         Emptying := True;\n         requeue Stop_Emptying;\n      end Finish;\n   end Divisor_Type;\n\n   protected body Collector_Type is\n      entry Poke when Emptying is\n      begin\n         null;\n      end Poke;\n      entry Finish when True is\n      begin\n         Ada.Text_IO.Put_Line (Poke'Count'Img);\n         Emptying := True;\n      end Finish;\n   end Collector_Type;\n\n   Collector : Collector_Type;\n   Divisor : Divisor_Type;\n\n   task body Input is\n   begin\n      Divisor.Poke;\n   end Input;\n\n   task body Output is\n   begin\n      Collector.Poke;\n   end Output;\n\n   Cur_Input : access Input;\n\n   -- Input value:\n   Number : Integer := 18;\nbegin\n   for I in 1 .. Number loop\n      Cur_Input := new Input;\n   end loop;\n   Divisor.Finish;\n   Collector.Finish;\nend Divide_By_3;\n"
        ]
    },
    {
        "question_id": 2649334,
        "question_code": "",
        "answer_code_snippets": [
            "-------------------------------------------------------------------------\n|  +-  |    Shared(dynamic)       |   Static Library (Linkages)         |\n-------------------------------------------------------------------------\n|Pros: | less memory use          |   an executable, using own libraries|\n|      |                          |     ,coming with the program,       |\n|      |                          |   doesn't need to worry about its   |\n|      |                          |   compilebility subject to libraries|\n-------------------------------------------------------------------------\n|Cons: | implementations of       |   bigger memory uses                |\n|      | libraries may be altered |                                     |\n|      | subject to OS  and its   |                                     |\n|      | version, which may affect|                                     |\n|      | the compilebility and    |                                     |\n|      | runnability of the code  |                                     |\n-------------------------------------------------------------------------\n"
        ]
    },
    {
        "question_id": 558122,
        "question_code": "static\nstatic\nstatic\nvoid print_matrix\na.c\na.h\n\"a.c\"\n\"print_matrix@@....) already defined in a.obj\"\nstatic void print_matrix\n.c\nmain.c\n.h\n.c",
        "answer_code_snippets": [
            "static\nC\nstatic",
            "static\n#include &lt;stdio.h&gt;\n\n/* Undefined behavior: already defined in main.\n * Binutils 2.24 gives an error and refuses to link.\n * https://stackoverflow.com/questions/27667277/why-does-borland-compile-with-multiple-definitions-of-same-object-in-different-c\n */\n/*void f() { puts(\"a f\"); }*/\n\n/* OK: only declared, not defined. Will use the one in main. */\nvoid f(void);\n\n/* OK: only visible to this file. */\nstatic void sf() { puts(\"a sf\"); }\n\nvoid a() {\n    f();\n    sf();\n}\n\n#include &lt;stdio.h&gt;\n\nvoid a(void);        \n\nvoid f() { puts(\"main f\"); }\n\nstatic void sf() { puts(\"main sf\"); }\n\nvoid m() {\n    f();\n    sf();\n}\n\nint main() {\n    m();\n    a();\n    return 0;\n}\n\ngcc -c a.c -o a.o\ngcc -c main.c -o main.o\ngcc -o main main.o a.o\n./main\n\nmain f\nmain sf\nmain f\na sf\n\nsf\nf\nstatic\nstatic\nthis\nstatic\nstatic\ninternal linkage\ninternal linkage\nSTB_LOCAL\nint f() { return 0; }\nstatic int sf() { return 0; }\n\nreadelf -s main.o\n\nNum:    Value          Size Type    Bind   Vis      Ndx Name\n  5: 000000000000000b    11 FUNC    LOCAL  DEFAULT    1 sf\n  9: 0000000000000000    11 FUNC    GLOBAL DEFAULT    1 f\n\nValue\n.bss\nSTB_LOCAL\nstatic\nSTB_GLOBAL\n-O3\nsf\nextern\nstatic\nextern",
            "add(int a, b)",
            ".cpp\nstatic functions\nstatic member function",
            "static\nexternal\n.c\n.cpp\nstatic\nstatic\n.c\n.cpp\nstatic\nstatic\nstatic\nstatic",
            "Person* tom = new Person();\ntom-&gt;setName(\"Tom\");\n\nPerson* tom = Person::createNewPerson();\n",
            "#include &lt;stdio.h&gt;\n\nstatic void test() \n{\n    ghost(); // This is an unexist function.\n}\n\nint main()\n{\n    int ret = 0;\n\n#ifdef TEST\n#else\n    test();\n#endif\n    return (ret);\n} \n\ngcc -o main main.c\n\ngcc -DTEST -O2 -o main main.c\n"
        ]
    },
    {
        "question_id": 5431941,
        "question_code": "feof()\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint\nmain(int argc, char **argv)\n{\n    char *path = &quot;stdin&quot;;\n    FILE *fp = argc &gt; 1 ? fopen(path=argv[1], &quot;r&quot;) : stdin;\n\n    if( fp == NULL ){\n        perror(path);\n        return EXIT_FAILURE;\n    }\n\n    while( !feof(fp) ){  /* THIS IS WRONG */\n        /* Read and process data from file… */\n    }\n    if( fclose(fp) != 0 ){\n        perror(path);\n        return EXIT_FAILURE;\n    }\n    return EXIT_SUCCESS;\n}\n",
        "answer_code_snippets": [
            "while(!feof(file))\nwhile(!feof(file))\n  for (;;) {\n      size_t n = fread(buf, 1, bufsize, infile);\n      consume(buf, n);\n      if (n == 0) { break; }\n  }\n\nn\nscanf\n  for (int a, b, c; scanf(&quot;%d %d %d&quot;, &amp;a, &amp;b, &amp;c) == 3; ) {\n      consume(a, b, c);\n  }\n\nscanf\n  for (int n; std::cin &gt;&gt; n; ) {\n      consume(n);\n  }\n\nstd::cin\ngood()\n  for (std::string line; std::getline(std::cin, line); ) {\n      consume(line);\n  }\n\nstd::cin\nwrite(2)\n  char const * p = buf;\n  ssize_t n = bufsize;\n  for (ssize_t k = bufsize; (k = write(fd, p, n)) &gt; 0; p += k, n -= k) {}\n  if (n != 0) { /* error, failed to write complete buffer */ }\n\nk\ngetline()\n  char *buffer = NULL;\n  size_t bufsiz = 0;\n  ssize_t nbytes;\n  while ((nbytes = getline(&amp;buffer, &amp;bufsiz, fp)) != -1)\n  {\n      /* Use nbytes of data in buffer */\n  }\n  free(buffer);\n\nnbytes\n-1\n  std::string input = &quot;   123   &quot;;   // example\n\n  std::istringstream iss(input);\n  int value;\n  if (iss &gt;&gt; value &gt;&gt; std::ws &amp;&amp; iss.get() == EOF) {\n      consume(value);\n  } else {\n      // error, &quot;input&quot; is not parsable as an integer\n  }\n\niss\nvalue\niss.get()\nstrto*l",
            "/* WARNING: demonstration of bad coding technique!! */\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nFILE *Fopen(const char *path, const char *mode);\n\nint\nmain(int argc, char **argv)\n{\n    FILE *in = argc &gt; 1 ? Fopen(argv[1], &quot;r&quot;) : stdin;\n    unsigned count = 0;\n\n    /* WARNING: this is a bug */\n    while( !feof(in) ) {  /* This is WRONG! */\n        fgetc(in);\n        count++;\n    }\n    printf(&quot;Number of characters read: %u\\n&quot;, count);\n    return EXIT_SUCCESS;\n}\n\nFILE *\nFopen(const char *path, const char *mode)\n{\n    FILE *f = fopen(path, mode);\n    if( f == NULL ) {\n        perror(path);\n        exit(EXIT_FAILURE);\n    }\n    return f;\n}\n\n$ ./a.out &lt; /dev/null\nNumber of characters read: 1\n\nfeof()\nfgetc()\nEOF\nfeof()\nfeof()\nfeof()\nfeof()\nfread()\nfeof\nferror\nfgetc\nEOF\nfeof()\nfgetc\nEOF\nfeof()\nfread()\nfscanf()\nfgetc()\nfeof()\nfgetc()\nEOF\nfeof()\nwhile(!feof(p))\nferror()\nwhile(!feof(p) &amp;&amp; !ferror(p))\nwhile(!feof(f))\nfeof\nferror\n#include &lt;assert.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint\nmain(int argc, char **argv)\n{\n    FILE *in = stdin;\n    unsigned count = 0;\n\n    while( getc(in) != EOF ){\n        count++;\n    }\n    if( feof(in) ){\n        printf(&quot;Number of characters read: %u\\n&quot;, count);\n    } else if( ferror(in) ){\n        perror(&quot;stdin&quot;);\n    } else {\n        assert(0);\n    }\n    return EXIT_SUCCESS;\n}\n",
            "while (!feof(f))\nwhile (!feof(f))",
            "feof()\nwhile (fgets(line, sizeof(line), file)) {\n    /* note that fgets don't strip the terminating \\n, checking its\n       presence allow to handle lines longer that sizeof(line), not showed here */\n    ...\n}\nif (ferror(file)) {\n   /* IO failure */\n} else if (feof(file)) {\n   /* format error (not possible with fgets, but would be with fscanf) or end of file */\n} else {\n   /* format error (not possible with fgets, but would be with fscanf) */\n}\n",
            "feof(F)\nF\nF\nEOF\n^D\nfeof",
            "feof()\nFILE\ntrue\nfgetc()\n#include &lt;stdio.h&gt;\n\nint main(int argc, char *argv[])\n{\n  FILE *in = fopen(\"testfile.txt\", \"r\");\n\n  while(1) {\n    char c = fgetc(in);\n    if (feof(in)) break;\n    printf(\"%c\", c);\n  }\n\n  fclose(in);\n  return 0;\n}\n\n#include &lt;stdio.h&gt;\n\nint main(int argc, char *argv[])\n{\n  FILE *in = fopen(\"testfile.txt\", \"r\");\n\n  while(!feof(in)) {\n    printf(\"%c\", fgetc(in));\n  }\n\n  fclose(in);\n  return 0;\n}\n"
        ]
    },
    {
        "question_id": 1674032,
        "question_code": "static const int var = 5;\n\n#define var 5\n\nenum { var = 5 };\n",
        "answer_code_snippets": [
            "static const int var = 5;\n#define var 5\nenum { var = 5 };",
            "static const\n\n#ifdef VAR // Very bad name, not long enough, too general, etc..\n  static int const var = VAR;\n#else\n  static int const var = 5; // default value\n#endif\n\n__FILE__\n__LINE__",
            "#define\nenum\nconst\nconst\nconst int\ncase\nconst int\nconst\nconst\n#define\nenum\nconst\nconst\nstatic",
            "static const\n#define\n#define\nstatic const",
            "#define\n#define MAXLEN 5\n\nvoid foo(void) {\n   int bar[MAXLEN];\n}\n\nstatic const\nconst int maxlen = 5;\n\nvoid foo() {\n   int bar[maxlen];\n}\n\nstatic\nconst",
            "const\nconst\nstatic int const NUMBER_OF_FINGERS_PER_HAND = 5;\nstatic int const NUMBER_OF_HANDS = 2;\n\n// initializer element is not constant, this does not work.\nstatic int const NUMBER_OF_FINGERS = NUMBER_OF_FINGERS_PER_HAND \n                                     * NUMBER_OF_HANDS;\n\nstatic uint8_t const ARRAY_SIZE = 16;\nstatic int8_t const lookup_table[ARRAY_SIZE] = {\n    1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16}; // ARRAY_SIZE not a constant!\n\nconst",
            "static const\n#define var 5\nint foo[var];\nstatic const int var = 5;\nstatic const\n#define\n#define",
            "#define PI 3.1416\n\nconst double PI = 3.1416; //or static const...\n",
            "#define var 5\nmystruct.var\nstruct mystruct {\n    int var;\n};\n\n#define var 5\n\nint main() {\n    struct mystruct foo;\n    foo.var = 1;\n    return 0;\n}\n\n#define",
            "#include &lt;stdio.h&gt;\n\nenum {ENUM_DEFINED=16};\nenum {ENUM_DEFINED=32};\n\n#define DEFINED_DEFINED 16\n#define DEFINED_DEFINED 32\n\nint main(int argc, char *argv[]) {\n\n   printf(\"%d, %d\\n\", DEFINED_DEFINED, ENUM_DEFINED);\n\n   return(0);\n}\n\nmain.c:6:7: error: redefinition of enumerator 'ENUM_DEFINED'\nenum {ENUM_DEFINED=32};\n      ^\nmain.c:5:7: note: previous definition is here\nenum {ENUM_DEFINED=16};\n      ^\nmain.c:9:9: warning: 'DEFINED_DEFINED' macro redefined [-Wmacro-redefined]\n#define DEFINED_DEFINED 32\n        ^\nmain.c:8:9: note: previous definition is here\n#define DEFINED_DEFINED 16\n        ^\n",
            "const int const_value = 5;\n\nconst int const_value = 5;\nint *mutable_value = (int*) &amp;const_value;\n*mutable_value = 3;\nprintf(\"%i\", const_value); // The output may be 5 or 3, depending on the compiler.\n\n#define CONST_VALUE 5\n",
            "static const\n#define",
            "#define\nenum {number_ten = 10};\n",
            "#define mymax 100\n\nprintf(\"address of constant is %p\",&amp;mymax);\nconst int mymax_var=100\n\nprintf(\"address of constant is %p\",&amp;mymax_var);",
            "const int\n#define",
            "#define\n#define\n#define myValue 7\nmyValue\n7"
        ]
    },
    {
        "question_id": 2397984,
        "question_code": "",
        "answer_code_snippets": [
            "#include &lt;iostream&gt;\n    \nint main()\n{\n    char* p = &quot;hello!\\n&quot;;   // yes I know, deprecated conversion\n    p[0] = 'y';\n    p[5] = 'w';\n    std::cout &lt;&lt; p;\n}\n\np\n&quot;hello!\\n&quot;\nyellow\ni++ + ++i",
            "int\nchar\nchar\nchar\nvoid fun(int n, int m);\n\nint fun1() {\n    std::cout &lt;&lt; &quot;fun1&quot;;\n    return 1;\n}\nint fun2() {\n    std::cout &lt;&lt; &quot;fun2&quot;;\n    return 2;\n}\n\n//...\n\nfun(fun1(), fun2()); // which one is executed first?\n\nfun(fun1(), fun2());\nsizeof(int)\nsizeof(int)\n++i+i++",
            "int scaled_velocity(int v, unsigned char pow)\n{\n  if (v &gt; 250)\n    v = 250;\n  if (v &lt; -250)\n    v = -250;\n  return v &lt;&lt; pow;\n}\n\nv &lt;&lt; pow\nv\nv\nv",
            "[[indeterminate]]\n[[indeterminate]]"
        ]
    },
    {
        "question_id": 654754,
        "question_code": "malloc()\nint main()\n{\n    char *a = malloc(1024);\n    /* Do some arbitrary stuff with 'a' (no alloc functions) */\n    return 0;\n}\n\nfree\naaa = 123\nmalloc",
        "answer_code_snippets": [
            "free()",
            "main(int argc, char *argv[])\nfoo_entry_point(char **args, struct foo *f)\nchar *t;\n\nfor (i=0; i &lt; 255; i++) {\n    t = strdup(foo-&gt;name);\n    let_strtok_eat_away_at(t);\n}\n",
            "&lt;/handwaving&gt;",
            "malloc()\nfree()\nmalloc()\nfree()\nfree()",
            "free()\nmalloc()\nmalloc()"
        ]
    },
    {
        "question_id": 12774207,
        "question_code": "/* SOMETHING */\ninline bool exist(const std::string&amp; name)\n{\n    /* SOMETHING */\n}\n",
        "answer_code_snippets": [
            "#include &lt;sys/stat.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;string&gt;\n#include &lt;fstream&gt;\n\ninline bool exists_test0 (const std::string&amp; name) {\n    ifstream f(name.c_str());\n    return f.good();\n}\n\ninline bool exists_test1 (const std::string&amp; name) {\n    if (FILE *file = fopen(name.c_str(), &quot;r&quot;)) {\n        fclose(file);\n        return true;\n    } else {\n        return false;\n    }   \n}\n\ninline bool exists_test2 (const std::string&amp; name) {\n    return ( access( name.c_str(), F_OK ) != -1 );\n}\n\ninline bool exists_test3 (const std::string&amp; name) {\n  struct stat buffer;   \n  return (stat (name.c_str(), &amp;buffer) == 0); \n}\n\nexists_test0\nexists_test1\nexists_test2\nexists_test3\nstat()\ng++\nfopen",
            "std::experimental::filesystem::exists(\"helloworld.txt\");\n\nstd::filesystem::exists(\"helloworld.txt\");\n",
            "bool is_file_exist(const char *fileName)\n{\n    std::ifstream infile(fileName);\n    return infile.good();\n}\n",
            "boost::filesystem::exists(fileName)\n\nstd::filesystem::exists(fileName)\n",
            "fopen",
            "#ifdef _WIN32\n   #include &lt;io.h&gt; \n   #define access    _access_s\n#else\n   #include &lt;unistd.h&gt;\n#endif\n\nbool FileExists( const std::string &amp;Filename )\n{\n    return access( Filename.c_str(), 0 ) == 0;\n}\n",
            "#include &lt;sys/stat.h&gt;\nint exist(const char *name)\n{\n  struct stat   buffer;\n  return (stat (name, &amp;buffer) == 0);\n}\n",
            "2018-05-05 00:35:35\nRunning ./filesystem\nRun on (8 X 2661 MHz CPU s)\nCPU Caches:\n  L1 Data 32K (x4)\n  L1 Instruction 32K (x4)\n  L2 Unified 256K (x4)\n  L3 Unified 8192K (x1)\n--------------------------------------------------\nBenchmark           Time           CPU Iterations\n--------------------------------------------------\nuse_stat          815 ns        813 ns     861291\nuse_open         2007 ns       1919 ns     346273\nuse_access       1186 ns       1006 ns     683024\nuse_boost         831 ns        830 ns     831233\n\n#include &lt;string.h&gt;                                                                                                                                                                                                                                           \n#include &lt;stdlib.h&gt;                                                                                                                                                                                                                                           \n#include &lt;sys/types.h&gt;                                                                                                                                                                                                                                        \n#include &lt;sys/stat.h&gt;                                                                                                                                                                                                                                         \n#include &lt;unistd.h&gt;                                                                                                                                                                                                                                           \n#include &lt;dirent.h&gt;                                                                                                                                                                                                                                           \n#include &lt;fcntl.h&gt;                                                                                                                                                                                                                                            \n#include &lt;unistd.h&gt;                                                                                                                                                                                                                                           \n\n#include \"boost/filesystem.hpp\"                                                                                                                                                                                                                               \n\n#include &lt;benchmark/benchmark.h&gt;                                                                                                                                                                                                                              \n\nconst std::string fname(\"filesystem.cpp\");                                                                                                                                                                                                                    \nstruct stat buf;                                                                                                                                                                                                                                              \n\n// Use stat function                                                                                                                                                                                                                                          \nvoid use_stat(benchmark::State &amp;state) {                                                                                                                                                                                                                      \n    for (auto _ : state) {                                                                                                                                                                                                                                    \n        benchmark::DoNotOptimize(stat(fname.data(), &amp;buf));                                                                                                                                                                                                   \n    }                                                                                                                                                                                                                                                         \n}                                                                                                                                                                                                                                                             \nBENCHMARK(use_stat);                                                                                                                                                                                                                                          \n\n// Use open function                                                                                                                                                                                                                                          \nvoid use_open(benchmark::State &amp;state) {                                                                                                                                                                                                                      \n    for (auto _ : state) {                                                                                                                                                                                                                                    \n        int fd = open(fname.data(), O_RDONLY);                                                                                                                                                                                                                \n        if (fd &gt; -1) close(fd);                                                                                                                                                                                                                               \n    }                                                                                                                                                                                                                                                         \n}                                                                                                                                                                                                                                                             \nBENCHMARK(use_open);                                  \n// Use access function                                                                                                                                                                                                                                        \nvoid use_access(benchmark::State &amp;state) {                                                                                                                                                                                                                    \n    for (auto _ : state) {                                                                                                                                                                                                                                    \n        benchmark::DoNotOptimize(access(fname.data(), R_OK));                                                                                                                                                                                                 \n    }                                                                                                                                                                                                                                                         \n}                                                                                                                                                                                                                                                             \nBENCHMARK(use_access);                                                                                                                                                                                                                                        \n\n// Use boost                                                                                                                                                                                                                                                  \nvoid use_boost(benchmark::State &amp;state) {                                                                                                                                                                                                                     \n    for (auto _ : state) {                                                                                                                                                                                                                                    \n        boost::filesystem::path p(fname);                                                                                                                                                                                                                     \n        benchmark::DoNotOptimize(boost::filesystem::exists(p));                                                                                                                                                                                               \n    }                                                                                                                                                                                                                                                         \n}                                                                                                                                                                                                                                                             \nBENCHMARK(use_boost);                                                                                                                                                                                                                                         \n\nBENCHMARK_MAIN();   \n",
            "inline bool exist(const std::string&amp; name)\n{\n    ifstream file(name);\n    if(!file)            // If the file was not found, then file is 0, i.e. !file=1 or true.\n        return false;    // The file was not found.\n    else                 // If the file was found, then file is non-0.\n        return true;     // The file was found.\n}\n",
            "bool b = std::ifstream('filename').good();",
            "inline bool exist(const std::string&amp; name)\n{\n    OFSTRUCT of_struct;\n    return OpenFile(name.c_str(), &amp;of_struct, OF_EXIST) != INVALID_HANDLE_VALUE &amp;&amp; of_struct.nErrCode == 0;\n}\n\ninline bool exist(const std::string&amp; name)\n{\n    HANDLE hFile = CreateFile(name.c_str(), GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);\n    if (hFile != NULL &amp;&amp; hFile != INVALID_HANDLE)\n    {\n         CloseFile(hFile);\n         return true;\n    }\n    return false;\n}\n\ninline bool exist(const std::string&amp; name)\n{\n    return GetFileAttributes(name.c_str()) != INVALID_FILE_ATTRIBUTES;\n}\n",
            "#include &lt;sys/stat.h&gt;\nint FileExists(char *path)\n{\n    struct stat fileStat; \n    if ( stat(path, &amp;fileStat) )\n    {\n        return 0;\n    }\n    if ( !S_ISREG(fileStat.st_mode) )\n    {\n        return 0;\n    }\n    return 1;\n}\n\nint DirExists(char *path)\n{\n    struct stat fileStat;\n    if ( stat(path, &amp;fileStat) )\n    {\n        return 0;\n    }\n    if ( !S_ISDIR(fileStat.st_mode) )\n    {\n        return 0;\n    }\n    return 1;\n}\n",
            "std::ifstream\nis_open\nfail",
            "&amp;&amp;\nstd::filesystem::directory_iterator\nboost::filesystem::directory_iterator\nopendir\nreaddir\ndirent.h\ndirent.h\ngetdents64\nFindFirstFileEx\nFindExInfoBasic\nFIND_FIRST_EX_LARGE_FETCH\ndirent.h\nFindFirstFile\ndirread\ndirreadall\nread\nread",
            "#include &lt;fstream&gt;\n#include &lt;iostream&gt;\n\nvoid FileExists(std::string myfile){\nstd::ifstream file(myfile.c_str());\n\nif (file) {\n    std::cout &lt;&lt; &quot;file exists&quot; &lt;&lt; std::endl;\n}\nelse {\n    std::cout &lt;&lt; &quot;file doesn't exist&quot; &lt;&lt; std::endl;\n}\n}\n\nint main() {\nFileExists(&quot;myfile.txt&quot;);\n\nreturn 0;\n}\n",
            "all_of (begin(R), end(R), [](auto&amp;p){ exists(p); })\n\nR\nexists()\nbool exists (string const&amp; p) { return ifstream{p}; }\n\nbool exists (const char* p) {\n    #if defined(_WIN32) || defined(_WIN64)\n    return p &amp;&amp; 0 != PathFileExists (p);\n    #else\n    struct stat sb;\n    return p &amp;&amp; 0 == stat (p, &amp;sb);\n    #endif\n}\n",
            "#include &lt;experimental/filesystem&gt;\n\nbool is_file_exist(std::string&amp; str) {   \n    namespace fs = std::experimental::filesystem;\n    fs::path p(str);\n    return fs::exists(p);\n}\n",
            "#include &lt;iostream&gt;\n#include &lt;fstream&gt;\nusing namespace std;\n    \nvoid main(){\n   SearchFile(&quot;test.txt&quot;);\n}\n\nbool SearchFile(const char *file)\n{\n   ifstream infile(file);\n   if (!infile.good())\n   {\n    // If file is not there\n    exit(1);\n   }\n}\n",
            "CFileStatus FileStatus;\nBOOL bFileExists = CFile::GetStatus(FileName,FileStatus);\n\nFileName",
            "    #include &lt;stdio.h&gt;\n    #include &lt;stdbool.h&gt;\n    #include &lt;errno.h&gt;\n\n    bool isFileExist(char fileName[]) {\n        FILE *fp = fopen(fileName, \"r\");\n        if (fp) {\n            fclose(fp);\n            return true;\n        }\n        return errno != ENOENT;\n    }\n\n    bool isFileCanBeRead(char fileName[]) {\n        FILE *fp = fopen(fileName, \"r\");\n        if (fp) {\n            fclose(fp);\n            return true;\n        }\n        return errno != ENOENT &amp;&amp; errno != EPERM;\n    }\n",
            "if(exists(file)) {                           /* point A */\n    /* handle existence condition */\n    return;\n}\n\ndo_something_with(file);                     /* point B */\n\nr = do_something_with_unless_exists(file);\n\nif(r == 0)\n    success;\nelse if(errno == EEXIST)\n    /* handle existence condition */\nelse\n    /* handle other error */\n\ndo_something_with_unless_exists\nopen()\nO_CREAT\nO_EXCL\nfopen()\n&quot;wx&quot;\nmkdir()\nerrno == EEXIST\nmkdir",
            "bool DoesExistFile(std::wstring filePath)\n{\n    bool result = true;\n\n    HANDLE fileHandle = CreateFile(\n        filePath.c_str(),\n        GENERIC_READ,\n        0,\n        NULL,\n        OPEN_EXISTING,\n        0,\n        NULL);\n\n    if ((fileHandle != NULL) &amp;&amp; (fileHandle != INVALID_HANDLE_VALUE))\n        CloseHandle(fileHandle);\n    else\n    {\n        DWORD error = GetLastError();\n\n        if ((error == ERROR_FILE_NOT_FOUND) || (error == ERROR_PATH_NOT_FOUND))\n            result = false;\n    }\n\n    return result;\n}\n",
            "fstream file(\"file_name.txt\");\n\nif (file.good()) \n{\n    std::cout &lt;&lt; \"file is good.\" &lt;&lt; endl;\n}\nelse \n{\n    std::cout &lt;&lt; \"file isnt good\" &lt;&lt; endl;\n}\n"
        ]
    },
    {
        "question_id": 330793,
        "question_code": "typedef struct MY_TYPE {\n  bool flag;\n  short int value;\n  double stuff;\n} MY_TYPE;\n\nvoid function(void) {\n  MY_TYPE a;\n  ...\n  a = { true, 15, 0.123 }\n}\n\nMY_TYPE",
        "answer_code_snippets": [
            "MY_TYPE a = { .flag = true, .value = 123, .stuff = 0.456 };\n",
            "MY_TYPE a;\n\na = (MY_TYPE) { .flag = true, .value = 123, .stuff = 0.456 };\n...\na = (MY_TYPE) { .value = 234, .stuff = 1.234, .flag = false };\n\na = (MY_TYPE) { true,  123, 0.456 };\n...\na = (MY_TYPE) { false, 234, 1.234 };\n",
            "typedef struct Item {\n    int a;\n    float b;\n    char* name;\n} Item;\n\nint main(void) {\n    Item item = { 5, 2.2, &quot;George&quot; };\n    return 0;\n}\n",
            "a = (MYTYPE){ true, 15, 0.123 };",
            "struct point \n{\n    double x;\n    double y;\n    double z;\n}\n\np = {1.2, 1.3}; \n\nstruct\nunion\narray\nint a[6] = { 0, 0, 15, 0, 29, 0 };\n\nint a[6] = {[4] = 29, [2] = 15 }; // or\nint a[6] = {[4]29 , [2]15 }; // or\nint widths[] = { [0 ... 9] = 1, [10 ... 99] = 2, [100] = 3 };\n\nstruct point { int x, y; };\n\nstruct point p = { .y = 2, .x = 3 }; or\nstruct point p = { y: 2, x: 3 };\n\nint a[6] = { 0, v1, v2, 0, v4, 0 };\n\nint a[6] = { [1] = v1, v2, [4] = v4 };\n\nint whitespace[256] = { [' '] = 1, ['\\t'] = 1, ['\\h'] = 1,\n                        ['\\f'] = 1, ['\\n'] = 1, ['\\r'] = 1 };\n\nstruct point ptarray[10] = { [2].y = yv2, [2].x = xv2, [0].x = xv0 };\n",
            "MY_TYPE a = { .stuff = 0.456, .flag = true, .value = 123 };\n\nparagraph 7\n6.7.8 Initialization\nparagraph 9\nInitializing unions and structs\n6.7.9 Initialization\nparagraph 9\n6.7.9 Initialization\nparagraph 9",
            "MY_TYPE a = { true, 15, 0.123 };\n",
            "typedef struct Item {\n    int a;\n    float b;\n    char* name;\n} Item;\n\nint main(void) {\n    Item item = {5, 2.2, &quot;George&quot;};\n    return 0;\n}\n\nvariable.members\nvariable.members\n0\n'\\0'\nchar\n0\nchar\nNULL",
            "// in a header:\ntypedef unsigned char uchar;\n\nstruct fields {\n  uchar num;\n  uchar lbl[35];\n};\n\n// in an actual c file (I have 2 in this case)\nstruct fields labels[] = {\n  {0, &quot;Package&quot;},\n  {1, &quot;Version&quot;},\n  {2, &quot;Apport&quot;},\n  {3, &quot;Architecture&quot;},\n  {4, &quot;Bugs&quot;},\n  {5, &quot;Description-md5&quot;},\n  {6, &quot;Essential&quot;},\n  {7, &quot;Filename&quot;},\n  {8, &quot;Ghc-Package&quot;},\n  {9, &quot;Gstreamer-Version&quot;},\n  {10, &quot;Homepage&quot;},\n  {11, &quot;Installed-Size&quot;},\n  {12, &quot;MD5sum&quot;},\n  {13, &quot;Maintainer&quot;},\n  {14, &quot;Modaliases&quot;},\n  {15, &quot;Multi-Arch&quot;},\n  {16, &quot;Npp-Description&quot;},\n  {17, &quot;Npp-File&quot;},\n  {18, &quot;Npp-Name&quot;},\n  {19, &quot;Origin&quot;}\n};\n",
            "MY_TYPE a = { true, 1, 0.1 };\n\nMY_TYPE a = { .stuff = 0.1, .flag = true, .value = 1 }; //designated initializer, not available in c++\n\nMY_TYPE a;\na = (MY_TYPE) { true,  1, 0.1 };\n\nMY_TYPE m (true, 1, 0.1); //works in C++, not available in C\n\n#include &lt;stdio.h&gt;\n\nstruct MY_TYPE\n{\n    int a;\n    int b;\n}m = {5,6};\n\nint main()\n{\n    printf(&quot;%d  %d\\n&quot;,m.a,m.b);    \n    return 0;\n}\n",
            "void function(void) {\n  MY_TYPE a;\n  a.flag = true;\n  a.value = 15;\n  a.stuff = 0.123;\n}\n",
            "MY_TYPE a = { true,15,0.123 };",
            "typedef struct test {\n    int num;\n    char* str;\n} test;\n\ntest tt = {\n    num: 42,\n    str: \"nice\"\n};\n",
            "structure\nMY_TYPE a = {flag:true, value:123, stuff:0.456};\n",
            "typedef struct book\n{\n    char title[10];\n    char author[10];\n    float price;\n} book;\n\nint main() {\n    book b1={\"DS\", \"Ajay\", 250.0};\n\n    printf(\"%s \\t %s \\t %f\", b1.title, b1.author, b1.price);\n\n    return 0;\n}\n",
            "{...}\n= {0};\ntypedef MyStruct_t{ int x, int a, int b; } MyStruct;\ndefine INIT_MyStruct(A,B) { 0, A, B}\nvoid init_MyStruct(MyStruct* thiz, int a, int b) {\n  thiz-&gt;a = a; thiz-&gt;b = b; }\n\nthiz\nthis\nMyStruct data = {0}; //all is zero!\ninit_MyStruct(&amp;data, 3, 456);\n",
            "typedef struct {\n    char *str;\n    size_t len;\n    jsmntok_t *tok;\n    int tsz;\n} jsmn_ts;\n\n#define jsmn_ts_default (jsmn_ts){NULL, 0, NULL, 0}\n\njsmn_ts mydata = jsmn_ts_default; /* initialization of a single struct */\n\njsmn_ts myarray[10] = {jsmn_ts_default, jsmn_ts_default}; /* initialization of\n                                                    first 2 structs in the array */\n"
        ]
    },
    {
        "question_id": 34732,
        "question_code": "",
        "answer_code_snippets": [
            "nm\nnm -gD yourLib.so\n\nnm -gDC yourLib.so\n\nobjdump\n-C\n$ objdump -TC libz.so\n\nlibz.so:     file format elf64-x86-64\n\nDYNAMIC SYMBOL TABLE:\n0000000000002010 l    d  .init  0000000000000000              .init\n0000000000000000      DF *UND*  0000000000000000  GLIBC_2.2.5 free\n0000000000000000      DF *UND*  0000000000000000  GLIBC_2.2.5 __errno_location\n0000000000000000  w   D  *UND*  0000000000000000              _ITM_deregisterTMCloneTable\n\nreadelf\n$ readelf -Ws libz.so\nSymbol table '.dynsym' contains 112 entries:\n   Num:    Value          Size Type    Bind   Vis      Ndx Name\n     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND\n     1: 0000000000002010     0 SECTION LOCAL  DEFAULT   10\n     2: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND free@GLIBC_2.2.5 (14)\n     3: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __errno_location@GLIBC_2.2.5 (14)\n     4: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND _ITM_deregisterTMCloneTable\n",
            ".so\nreadelf -Ws /usr/lib/libexample.so\n\n.so\nreadelf -Ws /usr/lib/libstdc++.so.6 | grep '^\\([[:space:]]\\+[^[:space:]]\\+\\)\\{6\\}[[:space:]]\\+[[:digit:]]\\+'\n\nreadelf -Ws /usr/lib/libstdc++.so.6 | awk '{print $8}';\n",
            "objdump -TC /usr/lib/libexample.so\n",
            "nm -D libNAME.so\n\nnm -g libNAME.a\n",
            ".so\nnm\nnm --demangle --dynamic --defined-only --extern-only &lt;my.so&gt;\n# nm --demangle --dynamic --defined-only --extern-only /usr/lib64/libqpid-proton-cpp.so | grep work | grep add\n0000000000049500 T proton::work_queue::add(proton::internal::v03::work)\n0000000000049580 T proton::work_queue::add(proton::void_function0&amp;)\n000000000002e7b0 W proton::work_queue::impl::add_void(proton::internal::v03::work)\n000000000002b1f0 T proton::container::impl::add_work_queue()\n000000000002dc50 T proton::container::impl::container_work_queue::add(proton::internal::v03::work)\n000000000002db60 T proton::container::impl::connection_work_queue::add(proton::internal::v03::work)\n\n--with-symbol-versions",
            ".so\nreadelf\nobjdump\nnm",
            "nm -g\nobjcopy\nnm\n-g",
            "objdump -h /path/to/object\n\nobjdump -g /path/to/object\n"
        ]
    },
    {
        "question_id": 38561,
        "question_code": "printf\n%d\n%i\nsigned int\nlong",
        "answer_code_snippets": [
            "l\nunsigned long n;\nlong m;\n\nprintf(\"%lu %ld\", n, m);\n",
            "unsigned long n;\nprintf(\"%lu\", n);   // unsigned long\n\nlong n;\nprintf(\"%ld\", n);   // signed long\n",
            "long\nint\nlong n;\nunsigned long un;\nprintf(\"%ld\", n); // signed\nprintf(\"%lu\", un); // unsigned\n\nlong long\nlong long n;\nunsigned long long un;\nprintf(\"%lld\", n); // signed\nprintf(\"%llu\", un); // unsigned\n\nprintf(\"%l64d\", n); // signed\nprintf(\"%l64u\", un); // unsigned\n\nunsigned long long n;\nprintf(\"0x%016llX\", n); // \"0x\" followed by \"0-padded\", \"16 char wide\", \"long long\", \"HEX with 0-9A-F\"\n\n0x00000000DEADBEEF\n\nchar c;       // 8 bits\nshort s;      // 16 bits\nint i;        // 32 bits (on modern platforms)\nlong l;       // 32 bits\nlong long ll; // 64 bits \n",
            "%ld\nprintf",
            "\"%lu\"\n\"%ld\"",
            "unsigned long long\nunsigned long long n;\nprintf(&quot;%llu&quot;, n);\n\nprintf(&quot;%llu&quot;, n)"
        ]
    },
    {
        "question_id": 24848359,
        "question_code": "while(1) {\n    // Some code\n}\n\nwhile(2) {\n    //Some code\n}\n\nwhile\ntrue\nfalse\ntrue\nwhile\nwhile(1)\nwhile(2)",
        "answer_code_snippets": [
            "int main(void) {\n    while(1) {}\n    return 0;\n}\n\nint main(void) {\n    while(2) {}\n    return 0;\n}\n\n-O0\ngcc main.c -S -masm=intel\n-O0\n    .file   &quot;main.c&quot;\n    .intel_syntax noprefix\n    .def    __main; .scl    2;  .type   32; .endef\n    .text\n    .globl  main\n    .def    main;   .scl    2;  .type   32; .endef\n    .seh_proc   main\nmain:\n    push    rbp\n    .seh_pushreg    rbp\n    mov rbp, rsp\n    .seh_setframe   rbp, 0\n    sub rsp, 32\n    .seh_stackalloc 32\n    .seh_endprologue\n    call    __main\n.L2:\n    jmp .L2\n    .seh_endproc\n    .ident  &quot;GCC: (tdm64-2) 4.8.1&quot;\n\n-O1\n    .file   &quot;main.c&quot;\n    .intel_syntax noprefix\n    .def    __main; .scl    2;  .type   32; .endef\n    .text\n    .globl  main\n    .def    main;   .scl    2;  .type   32; .endef\n    .seh_proc   main\nmain:\n    sub rsp, 40\n    .seh_stackalloc 40\n    .seh_endprologue\n    call    __main\n.L2:\n    jmp .L2\n    .seh_endproc\n    .ident  &quot;GCC: (tdm64-2) 4.8.1&quot;\n\n-O2\n-O3\n    .file   &quot;main.c&quot;\n    .intel_syntax noprefix\n    .def    __main; .scl    2;  .type   32; .endef\n    .section    .text.startup,&quot;x&quot;\n    .p2align 4,,15\n    .globl  main\n    .def    main;   .scl    2;  .type   32; .endef\n    .seh_proc   main\nmain:\n    sub rsp, 40\n    .seh_stackalloc 40\n    .seh_endprologue\n    call    __main\n.L2:\n    jmp .L2\n    .seh_endproc\n    .ident  &quot;GCC: (tdm64-2) 4.8.1&quot;\n\n .L2:\n    jmp .L2\n    .seh_endproc\n    .ident  &quot;GCC: (tdm64-2) 4.8.1&quot;\n\n.L2:\n    jmp .L2\n\njmp\n.L2\nL2:\n    goto L2;\n\njmp\nwhile(42) {}\n\nwhile(1==1) {}\n\nwhile(2==2) {}\n\nwhile(4&lt;7) {}\n\nwhile(3==3 &amp;&amp; 4==4) {}\n\nwhile(8-9 &lt; 0) {}\n\nwhile(4.3 * 3e4 &gt;= 2 &lt;&lt; 6) {}\n\nwhile(-0.1 + 02) {}\n\n#include&lt;math.h&gt;\n\nwhile(sqrt(7)) {}\n\nwhile(hypot(3,4)) {}\n\nint x(void) {\n    return 1;\n}\n\nwhile(x()) {}\n\n#include&lt;math.h&gt;\n\ndouble x(void) {\n    return sqrt(7);\n}\n\nwhile(x()) {}\n\n-O0\nx\n.L4:\n    call    x\n    testl   %eax, %eax\n    jne .L4\n    movl    $0, %eax\n    addq    $32, %rsp\n    popq    %rbp\n    ret\n    .seh_endproc\n    .ident  &quot;GCC: (tdm64-2) 4.8.1&quot;\n\nsqrt(7)\n.L4:\n    call    x\n    xorpd   %xmm1, %xmm1\n    ucomisd %xmm1, %xmm0\n    jp  .L4\n    xorpd   %xmm1, %xmm1\n    ucomisd %xmm1, %xmm0\n    jne .L4\n    movl    $0, %eax\n    addq    $32, %rsp\n    popq    %rbp\n    ret\n    .seh_endproc\n    .ident  &quot;GCC: (tdm64-2) 4.8.1&quot;\n\n-O1\njmp",
            "while(1)\nwhile(2)\nwhile(1)\nwhile(2)\nwhile(1)\nwhile(n)\nwhile(w)\nwhile(x2)\nwhile(2)\nwhile(1)",
            "while (1)\n1\nwhile (2)\n2\nint n = 4;\nswitch (n) {\n    case 2+2: break;\n    case 4:   break;\n}\n\n2+2\n1 == 0\n2 == 0\nint\n0\nwhile\n1\n2 != 0\nwhile (1)\nwhile(2)\nwhile(1)\nwhile(2)\nwhile(1)\nwhile(1)",
            "1 == 0\n2 == 0",
            "while (1)\nyyy:\n    xor eax, eax\n    cmp eax, 1     (or 2, depending on your code)\n    je xxx\n    jmp yyy\nxxx:\n    ...\n\nxxx:\n    jmp xxx\n",
            "1 = 00000001\n2 = 00000010\n\nwhile(1) { }\nwhile(2) { }\nwhile(-1) { }\nwhile(3) { }\nwhile(32) { }",
            "while(1)\nfor(;;)\nwhile(1)\nwhile(2)\nwhile(1)\nwhile(2)\nwhile(1)\nwhile(2)",
            "while(1) {}",
            "for (;;)\n",
            "unsigned long i = 0;\nwhile (1) { if (++i == 1000000000) break; }\n\nunsigned long i = 0;\nwhile (2) { if (++i == 1000000000) break; }\n",
            "!= 0",
            "while (2)\nwhile (1)\nwhile (true)\nbreak\n1\nwhile (2)\nwhile (1 + 1 == 2)\nwhile (1 + 5 - 2 - (1 * 3) == 0.5 - 4 + ((9 * 2) / 4.0)) {\n    if (succeed())\n        break;\n}\n\n2",
            "#define while(x) sleep(x);\n\nwhile(1)\nwhile(2)",
            "while(2)\ncmp eax, 2\n00000000 - 00000010  cmp eax, 2\n00000000 - 00000001 cmp eax, 1\ncmp"
        ]
    },
    {
        "question_id": 111928,
        "question_code": "printf\nprintf(&quot;%d %x %o\\n&quot;, 10, 10, 10); //prints &quot;10 A 12\\n&quot;\nprintf(&quot;%b\\n&quot;, 10); // prints &quot;%b\\n&quot;\n",
        "answer_code_snippets": [
            "#define BYTE_TO_BINARY_PATTERN &quot;%c%c%c%c%c%c%c%c&quot;\n#define BYTE_TO_BINARY(byte)  \\\n  ((byte) &amp; 0x80 ? '1' : '0'), \\\n  ((byte) &amp; 0x40 ? '1' : '0'), \\\n  ((byte) &amp; 0x20 ? '1' : '0'), \\\n  ((byte) &amp; 0x10 ? '1' : '0'), \\\n  ((byte) &amp; 0x08 ? '1' : '0'), \\\n  ((byte) &amp; 0x04 ? '1' : '0'), \\\n  ((byte) &amp; 0x02 ? '1' : '0'), \\\n  ((byte) &amp; 0x01 ? '1' : '0') \n\nprintf(&quot;Leading text &quot;BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(byte));\n\nprintf(&quot;m: &quot;BYTE_TO_BINARY_PATTERN&quot; &quot;BYTE_TO_BINARY_PATTERN&quot;\\n&quot;,\n  BYTE_TO_BINARY(m&gt;&gt;8), BYTE_TO_BINARY(m));\n\nBYTE_TO_BINARY",
            "// Assumes little endian\nvoid printBits(size_t const size, void const * const ptr)\n{\n    unsigned char *b = (unsigned char*) ptr;\n    unsigned char byte;\n    int i, j;\n    \n    for (i = size-1; i &gt;= 0; i--) {\n        for (j = 7; j &gt;= 0; j--) {\n            byte = (b[i] &gt;&gt; j) &amp; 1;\n            printf(&quot;%u&quot;, byte);\n        }\n    }\n    puts(&quot;&quot;);\n}\n\nint main(int argc, char* argv[])\n{\n    int i = 23;\n    uint ui = UINT_MAX;\n    float f = 23.45f;\n    printBits(sizeof(i), &amp;i);\n    printBits(sizeof(ui), &amp;ui);\n    printBits(sizeof(f), &amp;f);\n    return 0;\n}\n",
            "#include &lt;stdio.h&gt;      /* printf */\n#include &lt;string.h&gt;     /* strcat */\n#include &lt;stdlib.h&gt;     /* strtol */\n\nconst char *byte_to_binary\n(\n    int x\n)\n{\n    static char b[9];\n    b[0] = '\\0';\n\n    int z;\n    for (z = 128; z &gt; 0; z &gt;&gt;= 1)\n    {\n        strcat(b, ((x &amp; z) == z) ? &quot;1&quot; : &quot;0&quot;);\n    }\n\n    return b;\n}\n\nint main\n(\n    void\n)\n{\n    {\n        /* binary string to int */\n\n        char *tmp;\n        char *b = &quot;0101&quot;;\n\n        printf(&quot;%d\\n&quot;, strtol(b, &amp;tmp, 2));\n    }\n\n    {\n        /* byte to binary string */\n\n        printf(&quot;%s\\n&quot;, byte_to_binary(5));\n    }\n    \n    return 0;\n}\n",
            "const char *bit_rep[16] = {\n    [ 0] = \"0000\", [ 1] = \"0001\", [ 2] = \"0010\", [ 3] = \"0011\",\n    [ 4] = \"0100\", [ 5] = \"0101\", [ 6] = \"0110\", [ 7] = \"0111\",\n    [ 8] = \"1000\", [ 9] = \"1001\", [10] = \"1010\", [11] = \"1011\",\n    [12] = \"1100\", [13] = \"1101\", [14] = \"1110\", [15] = \"1111\",\n};\n\nvoid print_byte(uint8_t byte)\n{\n    printf(\"%s%s\", bit_rep[byte &gt;&gt; 4], bit_rep[byte &amp; 0x0F]);\n}\n",
            "%b",
            "#include &lt;stdio.h&gt;\n\nvoid print_binary(unsigned int number)\n{\n    if (number &gt;&gt; 1) {\n        print_binary(number &gt;&gt; 1);\n    }\n    putc((number &amp; 1) ? '1' : '0', stdout);\n}\n\n0b",
            "int8\n16\n32\n64\nINT8\n/* --- PRINTF_BYTE_TO_BINARY macro's --- */\n#define PRINTF_BINARY_PATTERN_INT8 \"%c%c%c%c%c%c%c%c\"\n#define PRINTF_BYTE_TO_BINARY_INT8(i)    \\\n    (((i) &amp; 0x80ll) ? '1' : '0'), \\\n    (((i) &amp; 0x40ll) ? '1' : '0'), \\\n    (((i) &amp; 0x20ll) ? '1' : '0'), \\\n    (((i) &amp; 0x10ll) ? '1' : '0'), \\\n    (((i) &amp; 0x08ll) ? '1' : '0'), \\\n    (((i) &amp; 0x04ll) ? '1' : '0'), \\\n    (((i) &amp; 0x02ll) ? '1' : '0'), \\\n    (((i) &amp; 0x01ll) ? '1' : '0')\n\n#define PRINTF_BINARY_PATTERN_INT16 \\\n    PRINTF_BINARY_PATTERN_INT8              PRINTF_BINARY_PATTERN_INT8\n#define PRINTF_BYTE_TO_BINARY_INT16(i) \\\n    PRINTF_BYTE_TO_BINARY_INT8((i) &gt;&gt; 8),   PRINTF_BYTE_TO_BINARY_INT8(i)\n#define PRINTF_BINARY_PATTERN_INT32 \\\n    PRINTF_BINARY_PATTERN_INT16             PRINTF_BINARY_PATTERN_INT16\n#define PRINTF_BYTE_TO_BINARY_INT32(i) \\\n    PRINTF_BYTE_TO_BINARY_INT16((i) &gt;&gt; 16), PRINTF_BYTE_TO_BINARY_INT16(i)\n#define PRINTF_BINARY_PATTERN_INT64    \\\n    PRINTF_BINARY_PATTERN_INT32             PRINTF_BINARY_PATTERN_INT32\n#define PRINTF_BYTE_TO_BINARY_INT64(i) \\\n    PRINTF_BYTE_TO_BINARY_INT32((i) &gt;&gt; 32), PRINTF_BYTE_TO_BINARY_INT32(i)\n/* --- end macros --- */\n\n#include &lt;stdio.h&gt;\nint main() {\n    long long int flag = 1648646756487983144ll;\n    printf(\"My Flag \"\n           PRINTF_BINARY_PATTERN_INT64 \"\\n\",\n           PRINTF_BYTE_TO_BINARY_INT64(flag));\n    return 0;\n}\n\nMy Flag 0001011011100001001010110111110101111000100100001111000000101000\n\nMy Flag 00010110,11100001,00101011,01111101,01111000,10010000,11110000,00101000\n",
            "#define FMT_BUF_SIZE (CHAR_BIT*sizeof(uintmax_t)+1)\n\nchar *binary_fmt(uintmax_t x, char buf[static FMT_BUF_SIZE])\n{\n    char *s = buf + FMT_BUF_SIZE;\n    *--s = 0;\n    if (!x) *--s = '0';\n    for (; x; x /= 2) *--s = '0' + x%2;\n    return s;\n}\n\nchar tmp[FMT_BUF_SIZE];\nprintf(&quot;%s\\n&quot;, binary_fmt(x, tmp));\n\nx",
            "&quot;%b&quot;\nprintf()\nb\nB\nprintf()\nprintf()\nprintf()\nfprintf()\nsprintf()\nvsprintf()\n&quot;%s&quot;\nprintf()\n#include &lt;assert.h&gt;\n#include &lt;limits.h&gt;\n#define TO_BASE_N (sizeof(unsigned)*CHAR_BIT + 1)\n\n//                               v--compound literal--v\n#define TO_BASE(x, b) my_to_base((char [TO_BASE_N]){&quot;&quot;}, (x), (b))\n\n// Tailor the details of the conversion function as needed\n// This one does not display unneeded leading zeros\n// Use return value, not `buf`\nchar *my_to_base(char buf[TO_BASE_N], unsigned i, int base) {\n  assert(base &gt;= 2 &amp;&amp; base &lt;= 36);\n  char *s = &amp;buf[TO_BASE_N - 1];\n  *s = '\\0';\n  do {\n    s--;\n    *s = &quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;[i % base];\n    i /= base;\n  } while (i);\n\n  // Could employ memmove here to move the used buffer to the beginning\n  // size_t len = &amp;buf[TO_BASE_N] - s;\n  // memmove(buf, s, len);\n\n  return s;\n}\n\n#include &lt;stdio.h&gt;\nint main(void) {\n  int ip1 = 0x01020304;\n  int ip2 = 0x05060708;\n  printf(&quot;%s %s\\n&quot;, TO_BASE(ip1, 16), TO_BASE(ip2, 16));\n  printf(&quot;%s %s\\n&quot;, TO_BASE(ip1, 2), TO_BASE(ip2, 2));\n  puts(TO_BASE(ip1, 8));\n  puts(TO_BASE(ip1, 36));\n  return 0;\n}\n\n1020304 5060708\n1000000100000001100000100 101000001100000011100001000\n100401404\nA2F44\n",
            "void printbits(my_integer_type x)\n{\n    for(int i=sizeof(x)&lt;&lt;3; i; i--)\n        putchar('0'+((x&gt;&gt;(i-1))&amp;1));\n}\n\n#define printbits_n(x,n) for (int i=n;i;i--,putchar('0'|(x&gt;&gt;i)&amp;1))\n#define printbits_32(x) printbits_n(x,32)\n\nchar *int_to_bitstring_alloc(int x, int count)\n{\n    count = count&lt;1 ? sizeof(x)*8 : count;\n    char *pstr = malloc(count+1);\n    for(int i = 0; i&lt;count; i++)\n        pstr[i] = '0' | ((x&gt;&gt;(count-1-i))&amp;1);\n    pstr[count]=0;\n    return pstr;\n}\n\n#define BITSIZEOF(x)    (sizeof(x)*8)\n\nchar *int_to_bitstring_static(int x, int count)\n{\n    static char bitbuf[BITSIZEOF(x)+1];\n    count = (count&lt;1 || count&gt;BITSIZEOF(x)) ? BITSIZEOF(x) : count;\n    for(int i = 0; i&lt;count; i++)\n        bitbuf[i] = '0' | ((x&gt;&gt;(count-1-i))&amp;1);\n    bitbuf[count]=0;\n    return bitbuf;\n}\n\n// memory allocated string returned which needs to be freed\nchar *pstr = int_to_bitstring_alloc(0x97e50ae6, 17);\nprintf(\"bits = 0b%s\\n\", pstr);\nfree(pstr);\n\n// no free needed but you need to copy the string to save it somewhere else\nchar *pstr2 = int_to_bitstring_static(0x97e50ae6, 17);\nprintf(\"bits = 0b%s\\n\", pstr2);\n",
            "const char* byte_to_binary(int x)\n{\n    static char b[sizeof(int)*8+1] = {0};\n    int y;\n    long long z;\n\n    for (z = 1LL&lt;&lt;sizeof(int)*8-1, y = 0; z &gt; 0; z &gt;&gt;= 1, y++) {\n        b[y] = (((x &amp; z) == z) ? '1' : '0');\n    }\n    b[y] = 0;\n\n    return b;\n}\n",
            "%B\nprintf\n/*\n * File:   main.c\n * Author: Techplex.Engineer\n *\n * Created on February 14, 2012, 9:16 PM\n */\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;printf.h&gt;\n#include &lt;math.h&gt;\n#include &lt;string.h&gt;\n\nstatic int printf_arginfo_M(const struct printf_info *info, size_t n, int *argtypes)\n{\n    /* &quot;%M&quot; always takes one argument, a pointer to uint8_t[6]. */\n    if (n &gt; 0) {\n        argtypes[0] = PA_POINTER;\n    }\n    return 1;\n}\n\nstatic int printf_output_M(FILE *stream, const struct printf_info *info, const void *const *args)\n{\n    int value = 0;\n    int len;\n\n    value = *(int **) (args[0]);\n\n    // Beginning of my code ------------------------------------------------------------\n    char buffer [50] = &quot;&quot;;  // Is this bad?\n    char buffer2 [50] = &quot;&quot;;  // Is this bad?\n    int bits = info-&gt;width;\n    if (bits &lt;= 0)\n        bits = 8;  // Default to 8 bits\n\n    int mask = pow(2, bits - 1);\n    while (mask &gt; 0) {\n        sprintf(buffer, &quot;%s&quot;, ((value &amp; mask) &gt; 0 ? &quot;1&quot; : &quot;0&quot;));\n        strcat(buffer2, buffer);\n        mask &gt;&gt;= 1;\n    }\n    strcat(buffer2, &quot;\\n&quot;);\n    // End of my code --------------------------------------------------------------\n    len = fprintf(stream, &quot;%s&quot;, buffer2);\n    return len;\n}\n\nint main(int argc, char** argv)\n{\n    register_printf_specifier('B', printf_output_M, printf_arginfo_M);\n\n    printf(&quot;%4B\\n&quot;, 65);\n\n    return EXIT_SUCCESS;\n}\n",
            "pBin\npBinFill\npBinFill\npBinFill\n#define kDisplayWidth 64\n\nchar* pBin(long int x,char *so)\n{\n  char s[kDisplayWidth+1];\n  int i = kDisplayWidth;\n  s[i--] = 0x00;  // terminate string\n  do {  // fill in array from right to left\n    s[i--] = (x &amp; 1) ? '1' : '0';  // determine bit\n    x &gt;&gt;= 1;  // shift right 1 bit\n  } while (x &gt; 0);\n  i++;  // point to last valid character\n  sprintf(so, &quot;%s&quot;, s+i);  // stick it in the temp string string\n  return so;\n}\n\nchar* pBinFill(long int x, char *so, char fillChar)\n{\n  // fill in array from right to left\n  char s[kDisplayWidth+1];\n  int i = kDisplayWidth;\n  s[i--] = 0x00;  // terminate string\n  do {  // fill in array from right to left\n    s[i--] = (x &amp; 1) ? '1' : '0';\n    x &gt;&gt;= 1;  // shift right 1 bit\n  } while (x &gt; 0);\n  while (i &gt;= 0) s[i--] = fillChar;  // fill with fillChar \n  sprintf(so, &quot;%s&quot;, s);\n  return so;\n}\n\nvoid test()\n{\n  char so[kDisplayWidth+1];  // working buffer for pBin\n  long int val = 1;\n  do {\n    printf(&quot;%ld =\\t\\t%#lx =\\t\\t0b%s\\n&quot;, val, val, pBinFill(val, so, '0'));\n    val *= 11;  // generate test data\n  } while (val &lt; 100000000);\n}\n\n00000001 =  0x000001 =  0b00000000000000000000000000000001\n00000011 =  0x00000b =  0b00000000000000000000000000001011\n00000121 =  0x000079 =  0b00000000000000000000000001111001\n00001331 =  0x000533 =  0b00000000000000000000010100110011\n00014641 =  0x003931 =  0b00000000000000000011100100110001\n00161051 =  0x02751b =  0b00000000000000100111010100011011\n01771561 =  0x1b0829 =  0b00000000000110110000100000101001\n19487171 = 0x12959c3 =  0b00000001001010010101100111000011\n",
            "char buffer [33];\nitoa(value, buffer, 2);\nprintf(\"\\nbinary: %s\\n\", buffer);\n",
            "void bin(int n)\n{\n    /* Step 1 */\n    if (n &gt; 1)\n        bin(n/2);\n    /* Step 2 */\n    printf(\"%d\", n % 2);\n}\n",
            "#include &lt;stdio.h&gt;\n#include &lt;stdint.h&gt;\n#include &lt;string.h&gt;\n#include &lt;limits.h&gt;\n\n#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__\n#define for_endian(size) for (int i = 0; i &lt; size; ++i)\n#elif __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__\n#define for_endian(size) for (int i = size - 1; i &gt;= 0; --i)\n#else\n#error &quot;Endianness not detected&quot;\n#endif\n\n#define printb(value)                                   \\\n({                                                      \\\n        typeof(value) _v = value;                       \\\n        __printb((typeof(_v) *) &amp;_v, sizeof(_v));       \\\n})\n\n#define MSB_MASK 1 &lt;&lt; (CHAR_BIT - 1)\n\nvoid __printb(void *value, size_t size)\n{\n        unsigned char uc;\n        unsigned char bits[CHAR_BIT + 1];\n\n        bits[CHAR_BIT] = '\\0';\n        for_endian(size) {\n                uc = ((unsigned char *) value)[i];\n                memset(bits, '0', CHAR_BIT);\n                for (int j = 0; uc &amp;&amp; j &lt; CHAR_BIT; ++j) {\n                        if (uc &amp; MSB_MASK)\n                                bits[j] = '1';\n                        uc &lt;&lt;= 1;\n                }\n                printf(&quot;%s &quot;, bits);\n        }\n        printf(&quot;\\n&quot;);\n}\n\nint main(void)\n{\n        uint8_t c1 = 0xff, c2 = 0x44;\n        uint8_t c3 = c1 + c2;\n\n        printb(c1);\n        printb((char) 0xff);\n        printb((short) 0xff);\n        printb(0xff);\n        printb(c2);\n        printb(0x44);\n        printb(0x4411ff01);\n        printb((uint16_t) c3);\n        printb('A');\n        printf(&quot;\\n&quot;);\n\n        return 0;\n}\n\n$ ./printb \n11111111 \n11111111 \n00000000 11111111 \n00000000 00000000 00000000 11111111 \n01000100 \n00000000 00000000 00000000 01000100 \n01000100 00010001 11111111 00000001 \n00000000 01000011 \n00000000 00000000 00000000 01000001 \n",
            "void\nprint_binary(unsigned int n)\n{\n    unsigned int mask = 0;\n    /* this grotesque hack creates a bit pattern 1000... */\n    /* regardless of the size of an unsigned int */\n    mask = ~mask ^ (~mask &gt;&gt; 1);\n\n    for(; mask != 0; mask &gt;&gt;= 1) {\n        putchar((n &amp; mask) ? '1' : '0');\n    }\n\n}\n",
            "#include &lt;stdio.h&gt;\nint main()\n{\n    int n = 156;\n    printf(&quot; n_dec: %d\\n n_bin: %08b\\n&quot;, n, n);\n    return 0;\n}\n\nubuntu@server:~$ ./a.out\n n_dec: 156\n n_bin: 10011100\nubuntu@server:~$\n",
            "inline std::string format_binary(unsigned int x)\n{\n    static char b[33];\n    b[32] = '\\0';\n\n    for (int z = 0; z &lt; 32; z++) {\n        b[31-z] = ((x&gt;&gt;z) &amp; 0x1) ? '1' : '0';\n    }\n\n    return b;\n}\n",
            "#include &lt;bitset&gt;\nMyIntegralType  num = 10;\nprint(\"%s\\n\",\n    std::bitset&lt;sizeof(num) * 8&gt;(num).to_string().insert(0, \"0b\").c_str()\n); // prints \"0b1010\\n\"\n\nstd::cout &lt;&lt; std::bitset&lt;sizeof(num) * 8&gt;(num);",
            "void print_binary(int number, int num_digits) {\n    int digit;\n    for(digit = num_digits - 1; digit &gt;= 0; digit--) {\n        printf(\"%c\", number &amp; (1 &lt;&lt; digit) ? '1' : '0');\n    }\n}\n",
            "void print_ulong_bin(const unsigned long * const var, int bits) {\n        int i;\n\n        #if defined(__LP64__) || defined(_LP64)\n                if( (bits &gt; 64) || (bits &lt;= 0) )\n        #else\n                if( (bits &gt; 32) || (bits &lt;= 0) )\n        #endif\n                return;\n\n        for(i = 0; i &lt; bits; i++) { \n                printf(\"%lu\", (*var &gt;&gt; (bits - 1 - i)) &amp; 0x01);\n        }\n}\n",
            "char *\nformat_binary(unsigned int x)\n{\n    #define MAXLEN 8 // width of output format\n    #define MAXCNT 4 // count per printf statement\n    static char fmtbuf[(MAXLEN+1)*MAXCNT];\n    static int count = 0;\n    char *b;\n    count = count % MAXCNT + 1;\n    b = &amp;fmtbuf[(MAXLEN+1)*count];\n    b[MAXLEN] = '\\0';\n    for (int z = 0; z &lt; MAXLEN; z++) { b[MAXLEN-1-z] = ((x&gt;&gt;z) &amp; 0x1) ? '1' : '0'; }\n    return b;\n}\n",
            "template&lt;class T&gt;\ninline std::string format_binary(T x)\n{\n    char b[sizeof(T)*8+1] = {0};\n\n    for (size_t z = 0; z &lt; sizeof(T)*8; z++)\n        b[sizeof(T)*8-1-z] = ((x&gt;&gt;z) &amp; 0x1) ? '1' : '0';\n\n    return std::string(b);\n}\n\nunsigned int value32 = 0x1e127ad;\nprintf( \"  0x%x: %s\\n\", value32, format_binary(value32).c_str() );\n\nunsigned long long value64 = 0x2e0b04ce0;\nprintf( \"0x%llx: %s\\n\", value64, format_binary(value64).c_str() );\n\n  0x1e127ad: 00000001111000010010011110101101\n0x2e0b04ce0: 0000000000000000000000000000001011100000101100000100110011100000\n",
            "6\n6\n110\n\"110\"\nchar buf[]\nprintf()\n\"%08lu\"\n\"%*lX\"\n#include &lt;stdint.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;inttypes.h&gt;\n\nunsigned long char_to_bin10(char ch) {\n  unsigned char uch = ch;\n  unsigned long sum = 0;\n  unsigned long power = 1;\n  while (uch) {\n    if (uch &amp; 1) {\n      sum += power;\n      }\n   power *= 10;\n   uch /= 2;\n  }\n  return sum;\n}\n\nuint64_t uint16_to_bin16(uint16_t u) {\n  uint64_t sum = 0;\n  uint64_t power = 1;\n  while (u) {\n    if (u &amp; 1) {\n      sum += power;\n      }\n    power *= 16;\n    u /= 2;\n  }\n  return sum;\n}\n\nvoid test(void) {\n  printf(\"%lu\\n\", char_to_bin10(0xF1));\n  // 11110001\n  printf(\"%\" PRIX64 \"\\n\", uint16_to_bin16(0xF731));\n  // 1111011100110001\n}\n"
        ]
    },
    {
        "question_id": 145270,
        "question_code": "",
        "answer_code_snippets": [
            "#include &lt;iostream&gt;\n\nclass Foo{\n    public:\n        void bar(){\n            std::cout &lt;&lt; \"Hello\" &lt;&lt; std::endl;\n        }\n};\n\nextern \"C\" {\n    Foo* Foo_new(){ return new Foo(); }\n    void Foo_bar(Foo* foo){ foo-&gt;bar(); }\n}\n\ng++ -c -fPIC foo.cpp -o foo.o\ng++ -shared -Wl,-soname,libfoo.so -o libfoo.so  foo.o\n\nfrom ctypes import cdll\nlib = cdll.LoadLibrary('./libfoo.so')\n\nclass Foo(object):\n    def __init__(self):\n        self.obj = lib.Foo_new()\n\n    def bar(self):\n        lib.Foo_bar(self.obj)\n\nf = Foo()\nf.bar() #and you will see \"Hello\" on the screen\n",
            "pybind11",
            "/* File : example.c */\nint fact(int n) {\n    if (n &lt;= 1) return 1;\n    else return n*fact(n-1);\n}\n\n/* example.i */\n%module example\n%{\n/* Put header files here or function declarations like below */\nextern int fact(int n);\n%}\n\nextern int fact(int n);\n\nswig -python example.i\ngcc -fPIC -c example.c example_wrap.c -I/usr/local/include/python2.7\ngcc -shared example.o example_wrap.o -o _example.so\n\n&gt;&gt;&gt; import example\n&gt;&gt;&gt; example.fact(5)\n120\n",
            "#include &lt;vector&gt;\n#include \"code.h\"\n\nusing namespace std;\n\nvector&lt;double&gt; average (vector&lt; vector&lt;double&gt; &gt; i_matrix) {\n\n  // Compute average of each row..\n  vector &lt;double&gt; averages;\n  for (int r = 0; r &lt; i_matrix.size(); r++){\n    double rsum = 0.0;\n    double ncols= i_matrix[r].size();\n    for (int c = 0; c&lt; i_matrix[r].size(); c++){\n      rsum += i_matrix[r][c];\n    }\n    averages.push_back(rsum/ncols);\n  }\n  return averages;\n}\n\n#ifndef _code\n#define _code\n\n#include &lt;vector&gt;\n\nstd::vector&lt;double&gt; average (std::vector&lt; std::vector&lt;double&gt; &gt; i_matrix);\n\n#endif\n\ng++ -c -fPIC code.cpp\n\n%module code\n%{\n#include \"code.h\"\n%}\n%include \"std_vector.i\"\nnamespace std {\n\n  /* On a side note, the names VecDouble and VecVecdouble can be changed, but the order of first the inner vector matters! */\n  %template(VecDouble) vector&lt;double&gt;;\n  %template(VecVecdouble) vector&lt; vector&lt;double&gt; &gt;;\n}\n\n%include \"code.h\"\n\nswig -c++ -python code.i\n\ng++ -c -fPIC code_wrap.cxx  -I/usr/include/python2.7 -I/usr/lib/python2.7\ng++ -shared -Wl,-soname,_code.so -o _code.so code.o code_wrap.o\n\n#!/usr/bin/env python\n\nimport code\na= [[3,5,7],[8,10,12]]\nprint a\nb = code.average(a)\nprint \"Assignment done\"\nprint a\nprint b\n",
            "    $ pip install cppyy\n\n    $ cat foo.h\n    class Foo {\n    public:\n        void bar();\n    };\n\n    $ cat foo.cpp\n    #include \"foo.h\"\n    #include &lt;iostream&gt;\n\n    void Foo::bar() { std::cout &lt;&lt; \"Hello\" &lt;&lt; std::endl; }\n\n    $ g++ -c -fPIC foo.cpp -o foo.o\n    $ g++ -shared -Wl,-soname,libfoo.so -o libfoo.so  foo.o\n\n    $ python\n    &gt;&gt;&gt; import cppyy\n    &gt;&gt;&gt; cppyy.include(\"foo.h\")\n    &gt;&gt;&gt; cppyy.load_library(\"foo\")\n    &gt;&gt;&gt; from cppyy.gbl import Foo\n    &gt;&gt;&gt; f = Foo()\n    &gt;&gt;&gt; f.bar()\n    Hello\n    &gt;&gt;&gt;\n\n    $ python\n    &gt;&gt;&gt; import cppyy\n    &gt;&gt;&gt; f = cppyy.gbl.Foo()\n    &gt;&gt;&gt; f.bar()\n    Hello\n    &gt;&gt;&gt;\n\n    &gt;&gt;&gt; v = cppyy.gbl.std.vector[cppyy.gbl.Foo]()\n    &gt;&gt;&gt; v.push_back(f)\n    &gt;&gt;&gt; len(v)\n    1\n    &gt;&gt;&gt; v[0].bar()\n    Hello\n    &gt;&gt;&gt;\n",
            "#include &lt;string&gt;\n\n#include &lt;pybind11/pybind11.h&gt;\n\nstruct ClassTest {\n    ClassTest(const std::string &amp;name, int i) : name(name), i(i) { }\n    void setName(const std::string &amp;name_) { name = name_; }\n    const std::string getName() const { return name + &quot;z&quot;; }\n    void setI(const int i) { this-&gt;i = i; }\n    const int getI() const { return i + 1; }\n    std::string name;\n    int i;\n};\n\nnamespace py = pybind11;\n\nPYBIND11_PLUGIN(class_test) {\n    py::module m(&quot;my_module&quot;, &quot;pybind11 example plugin&quot;);\n    py::class_&lt;ClassTest&gt;(m, &quot;ClassTest&quot;)\n        .def(py::init&lt;const std::string &amp;, int&gt;())\n        .def(&quot;setName&quot;, &amp;ClassTest::setName)\n        .def(&quot;getName&quot;, &amp;ClassTest::getName)\n        .def_readwrite(&quot;name&quot;, &amp;ClassTest::name)\n        .def(&quot;setI&quot;, &amp;ClassTest::setI)\n        .def(&quot;getI&quot;, &amp;ClassTest::getI)\n        .def_readwrite(&quot;i&quot;, &amp;ClassTest::i);\n    return m.ptr();\n}\n\n#!/usr/bin/env python3\n\nimport class_test\n\nmy_class_test = class_test.ClassTest(&quot;abc&quot;, 1);\nprint(my_class_test.getName())\nprint(my_class_test.getI())\nmy_class_test.setName(&quot;012&quot;)\nmy_class_test.setI(2)\nprint(my_class_test.getName())\nprint(my_class_test.getI())\nassert(my_class_test.getName() == &quot;012z&quot;)\nassert(my_class_test.getI() == 3)\n\n#!/usr/bin/env bash\nset -eux\nsudo apt install pybind11-dev\ng++ `python3-config --cflags` -shared -std=c++11 -fPIC class_test.cpp \\\n  -o class_test`python3-config --extension-suffix` `python3-config --libs`\n./class_test_main.py\n\nabcz\n2\n012z\n3\n\nmy_class_test.setI(&quot;abc&quot;)\n\nTraceback (most recent call last):\n  File &quot;/home/ciro/test/./class_test_main.py&quot;, line 9, in &lt;module&gt;\n    my_class_test.setI(&quot;abc&quot;)\nTypeError: setI(): incompatible function arguments. The following argument types are supported:\n    1. (self: my_module.ClassTest, arg0: int) -&gt; None\n\nInvoked with: &lt;my_module.ClassTest object at 0x7f2980254fb0&gt;, 'abc'\n\nClassTest\nname\nstd::string\nstr\nclass_test.cpython-36m-x86_64-linux-gnu.so\nclass_test_main.py\nclass_test\nBoost.Python",
            "import cppyy\nimport numpy as np\ncppyy.include('Buffer.h')\n\n\ns = cppyy.gbl.Buffer()\nnumpy_array = np.empty(32000, np.float64)\ns.get_numpy_array(numpy_array.data, numpy_array.size)\nprint(numpy_array[:20])\n\nstruct Buffer {\n  void get_numpy_array(double *ad, int size) {\n    for( long i=0; i &lt; size; i++)\n        ad[i]=i;\n  }\n};\n",
            "&gt;&gt;&gt; from ctypes import *\n&gt;&gt;&gt; libc = cdll.msvcrt\n&gt;&gt;&gt; print libc.time(None)\n1438069008\n&gt;&gt;&gt; printf = libc.printf\n&gt;&gt;&gt; printf(\"Hello, %s\\n\", \"World!\")\nHello, World!\n14\n&gt;&gt;&gt; printf(\"%d bottles of beer\\n\", 42)\n42 bottles of beer\n19\n",
            "runcython"
        ]
    },
    {
        "question_id": 4264127,
        "question_code": "double\nprintf\n%f\n%lf\n%f\n#include &lt;stdio.h&gt;\n\nint main()\n{\n   double d = 1.4;\n   printf(&quot;%lf&quot;, d); // Is this wrong?\n}\n",
        "answer_code_snippets": [
            "\"%f\"\nfloat\nfloat\nprintf\ndouble\nprintf\n\"%lf\"\nl\nf\nprintf\nscanf\nfscanf\nfloat\ndouble\nscanf\nfloat\ndouble\nscanf\n%f\nfloat\n%lf\ndouble\nlong double\n%Lf\nprintf\nscanf",
            "%lf\nprintf\nfprintf\nfprintf\nprintf\nsprintf\nfscanf\nfprintf\n%f\n%Lf\nfscanf\n%f\n%lf\n%Lf",
            "%f\n%g\n%e\nl\nscanf\ndouble\nprintf",
            "%lf\nprintf\ndouble\n%lf\nprintf\ndouble\nprintf\nscanf\n%lf\ndouble\nprintf\n%f\n%lf\n%f\nprintf\n%f\nfloat\n%lf\ndouble\n%Lf\nlong double\nprintf\nscanf",
            "%Lf\nL\ndoubles\n%e\n%E\n%f\n%g\n%G"
        ]
    },
    {
        "question_id": 5029840,
        "question_code": "char\nint",
        "answer_code_snippets": [
            "char a = 'a';\nint ia = (int)a; \n/* note that the int cast is not necessary -- int ia = a would suffice */\n\n'0' -&gt; 0\n'1' -&gt; 1\nchar a = '4';\nint ia = a - '0';\n/* check here if ia is bounded by 0 and 9 */\n\na - '0'\n((int)a) - ((int)'0')\n0\n1\n9\na",
            "int x = (int)character - 48;\n\nint x = character - '0';  // The (int) cast is not necessary.\n",
            "int\nint\nchar\nchar\nint\nchar c = 'a'; // narrowing on C\nint a = c;\n",
            "  int str[] = {'h', 'e', 'l', 'l', 'o', '\\0' };\n  \n  for(i=0; i&lt;6; i++)\n  {\n    printf(&quot;%c&quot;, str[i]);\n  }\n\nchar ch = '5';\nch = ch - '0';\n\nchar ch = (int)53;\nch = ch - (int)48;\n\nch = (int)ch - (int)48;\n\nch = (char)( (int)ch - (int)48 );\n",
            "char c = somevalue;\nsigned char sc = c;\nunsigned char uc = c;\nint n = c;\n\nchar c = somevalue;\nsigned char sc = c;\nunsigned char uc = c;\n// Might not be true: int(c) == int(sc) and int(c) == int(uc).\nint nc = (unsigned char)c;\nint nsc = (unsigned char)sc;\nint nuc = (unsigned char)uc;\n// Always true: nc == nsc and nc == nuc.\n\nchar c = negative_char;  // Assuming CHAR_MIN &lt; 0.\nint n = c;\nbool b = isupper(n);  // Undefined behavior.\n\nchar c = negative_char;\nbool b = isupper(c);\n\ntemplate&lt;int (&amp;F)(int)&gt;\nint safe_ctype(unsigned char c) { return F(c); }\n\n//...\nchar c = CHAR_MIN;\nbool b = safe_ctype&lt;isupper&gt;(c);  // No UB.\n\nstd::string s = &quot;value that may contain negative chars; e.g. user input&quot;;\nstd::transform(s.begin(), s.end(), s.begin(), &amp;safe_ctype&lt;toupper&gt;);\n// Must wrap toupper to eliminate UB in this case, you can't cast\n// to unsigned char because the function is called inside transform.\n\nint ord(char c) { return (unsigned char)c; }\nchar chr(int n) {\n  assert(0 &lt;= n);  // Or other error-/sanity-checking.\n  assert(n &lt;= UCHAR_MAX);\n  return (unsigned char)n;\n}\n\n// Ord and chr are named to match similar functions in other languages\n// and libraries.\n",
            "static_cast&lt;int&gt;\nint num = static_cast&lt;int&gt;(letter); // if letter='a', num=97\n\n(int)",
            "null\nchar* something = \"123456\";\n\nint number = parseInt(something);\n\nint parseInt(char* chars)\n{\n    int sum = 0;\n    int len = strlen(chars);\n    for (int x = 0; x &lt; len; x++)\n    {\n        int n = chars[len - (x + 1)] - '0';\n        sum = sum + powInt(n, x);\n    }\n    return sum;\n}\n\nint powInt(int x, int y)\n{\n    for (int i = 0; i &lt; y; i++)\n    {\n        x *= 10;\n    }\n    return x;\n}\n",
            "int\nchar\nchar",
            "/* chartoint: convert char simbols to unsigned int*/\nint chartoint(char s[])\n{\n\n    int i, n;\n    n = 0;\n    for (i = 0; isdigit(s[i]); ++i){\n        n = 10 * n + (s[i] - '0');\n    }\n    return n; \n}\n\nprintf(&quot;char 00: %d \\r\\n&quot;, chartoint(&quot;00&quot;));\nprintf(&quot;char 01: %d \\r\\n&quot;, chartoint(&quot;01&quot;));\nprintf(&quot;char 255: %d \\r\\n&quot;, chartoint(&quot;255&quot;));\n",
            "typedef unsigned char UChar;\n\nchar myCppFunc( char c )\n{\n    return char( someCFunc( UChar( c ) ) );\n}\n\nUChar( c )\nunsigned char\nint\nint\nint( UChar( c ) )",
            "\"7c7c7d7d7d7d7c7c7c7d7d7d7d7c7c7c7c7c7c7d7d7c7c7c7c7d7c7d7d7d7c7c2e2e2e\"\nunsigned int* char2int(char *a, int len)\n{\n    int i,u;\n    unsigned int *val = malloc(len*sizeof(unsigned long));\n\n    for(i=0,u=0;i&lt;len;i++){\n        if(i%2==0){\n            if(a[i] &lt;= 57)\n                val[u] = (a[i]-50)&lt;&lt;4;\n            else\n                val[u] = (a[i]-55)&lt;&lt;4;\n        }\n        else{\n            if(a[i] &lt;= 57)\n                val[u] += (a[i]-50);\n            else\n                val[u] += (a[i]-55);\n            u++;\n        }\n    }\n    return val;\n}\n",
            "char ch = 16;\nint in = ch;\n\nlong long lo = ch;\n",
            "long long ChardToint(char *arr, size_t len){\n   \nint toptenf=1;\nlong long toptenLf=10000000LL;\nlong long makeintf=3000000000000;\n \n   \n  makeintf= 0LL;\n\n\n   int holdNumberf=0;\nfor(int i=len-1;i&gt;=0 ;i--){\n switch(arr[i]){\n      case '0':\n      holdNumberf=0;\n      break;\n      case '1':\n      holdNumberf=1;\n      break;\n      case '2':\n      holdNumberf=2;\n      break;\n      case '3':\n      holdNumberf=3;\n      break;\n      case '4':\n      holdNumberf=4;\n      break;\n      case '5':\n      holdNumberf=5;\n      break;\n      case '6':\n      holdNumberf=6;\n      break;\n      case '7':\n      holdNumberf=7;\n      break;\n      case '8':\n      holdNumberf=8;\n      break;\n      case '9':\n      holdNumberf=9;\n      break;\n\n      default:\n       holdNumberf=0;\n}\n  if(toptenf&gt;=10000000){\n      makeintf=makeintf+holdNumberf*toptenLf;\n      \n  \n      toptenLf=toptenLf*10; \n   }else{\n     makeintf=makeintf+holdNumberf*toptenf; \n     \n\n    toptenf=toptenf*10;  \n   }\n}\nreturn makeintf;\n\n}\n",
            "int charToint(char a){\nchar *p = &amp;a;\nint k = atoi(p);\nreturn k;\n}\n"
        ]
    },
    {
        "question_id": 7724569,
        "question_code": "g++\ngcc",
        "answer_code_snippets": [
            "CMakeLists.txt\nmkdir Release\ncd Release\ncmake -DCMAKE_BUILD_TYPE=Release ..\nmake\n\nDebug\nmkdir Debug\ncd Debug\ncmake -DCMAKE_BUILD_TYPE=Debug ..\nmake\n\nRelease\nDebug\nRelWithDebInfo\nMinSizeRel\nCMAKE_&lt;LANG&gt;_FLAGS_&lt;CONFIG&gt;_INIT\nset(CMAKE_CXX_FLAGS_DEBUG_INIT \"-Wall\")\nset(CMAKE_CXX_FLAGS_RELEASE_INIT \"-Wall\")\n",
            "# Configure the build\ncmake -S . -B build/ -D CMAKE_BUILD_TYPE=Debug\n\n# Actually build the binaries\ncmake --build build/\n\n# Configure a release build\ncmake -S . -B build/ -D CMAKE_BUILD_TYPE=Release\n\n# Build release binaries\ncmake --build build/\n\n# Configure the build\ncmake -S . -B build\n\n# Build debug binaries\ncmake --build build --config Debug\n\n# Build release binaries\ncmake --build build --config Release\n\nadd_library(foobar)\n\n# Add this compile definition for debug builds, this same logic works for\n# target_compile_options, target_link_options, etc.\ntarget_compile_definitions(foobar PRIVATE\n    $&lt;$&lt;CONFIG:Debug&gt;:\n        FOOBAR_DEBUG=1\n    &gt;\n)\n",
            "CMAKE_BUILD_TYPE\ncmake -DCMAKE_BUILD_TYPE=value\nRelease\nDebug\nset_source_files_properties(yourfile.c LANGUAGE CXX) \n",
            "CMAKE_CXX_FLAGS\nstring(APPEND CMAKE_CXX_FLAGS_DEBUG &quot; -g3&quot;)\nadd_compile_options\nadd_compile_options(\n  &quot;-Wall&quot; &quot;-Wpedantic&quot; &quot;-Wextra&quot; &quot;-fexceptions&quot;\n  &quot;$&lt;$&lt;CONFIG:DEBUG&gt;:-O0;-g3;-ggdb&gt;&quot;\n)\n\nDEBUG\n;",
            "set(CMAKE_CONFIGURATION_TYPES \"Release\" CACHE STRING \"\" FORCE)\n\nset(CMAKE_CONFIGURATION_TYPES \"Debug\" CACHE STRING \"\" FORCE)\n",
            "cmake --build {$PWD} --config &lt;cfg&gt;\n&lt;cfg&gt;"
        ]
    },
    {
        "question_id": 131803,
        "question_code": "size_t\nint\nunsigned int",
        "answer_code_snippets": [
            "size_t\nsizeof\noffsetof\nsize_t\nunsigned int",
            "size_t\nsize_t",
            "size_t\nsize_t\nsize_t\nunsigned int\nunsigned int\n4294967295\n4294967295\nunsigned long int\nlong\nsize_t\nsize_t\nunsigned int\nunsigned long\nunsigned long long",
            "stddef.h' to be whatever type the system's\nfixincludes' script will massage the system's",
            "size_t\nunsigned int\nsize_t\nunsigned long long"
        ]
    },
    {
        "question_id": 246127,
        "question_code": "volatile",
        "answer_code_snippets": [
            "volatile\nvolatile\ntypedef struct\n{\n  int command;\n  int data;\n  int isBusy;\n} MyHardwareGadget;\n\nvoid SendCommand(MyHardwareGadget* gadget, int command, int data)\n{\n  // wait while the gadget is busy:\n  while (gadget-&gt;isBusy)\n  {\n    // do nothing here.\n  }\n  // set data first:\n  gadget-&gt;data    = data;\n  // writing the command starts the action:\n  gadget-&gt;command = command;\n}\n\nisBusy\ngadget\nvolatile\nvoid SendCommand(volatile MyHardwareGadget* gadget, int command, int data)\n{\n  // wait while the gadget is busy:\n  while (gadget-&gt;isBusy)\n  {\n    // do nothing here.\n  }\n  // set data first:\n  gadget-&gt;data    = data;\n  // writing the command starts the action:\n  gadget-&gt;command = command;\n}\n",
            "volatile\nvolatile\nvolatile",
            "volatile\nint quit = 0;\nwhile (!quit)\n{\n    /* very small loop which is completely visible to the compiler */\n}\n\nquit\nwhile (true)\nquit\nSIGINT\nSIGTERM\nquit\nvolatile",
            "volatile",
            "volatile\nbool usb_interface_flag = 0;\nwhile(usb_interface_flag == 0)\n{\n    // execute logic for the scenario where the USB isn't connected \n}\n\nusb_interface_flag\nwhile(true)",
            "f\ndouble der_f(double x)\n{\n    static const double h = 1e-3;\n    return (f(x + h) - f(x)) / h;\n}\n\nx+h-x\nh\ndouble der_f2(double x)\n{\n    static const double h = 1e-3;\n    double hh = x + h - x;\n    return (f(x + hh) - f(x)) / hh;\n}\n\n    volatile double hh = x + h;\n    hh -= x;\n",
            "volatile\nvolatile\nvolatile\n    void SendCommand (volatile MyHardwareGadget * gadget, int command, int data)\n    {\n      // Wait while the gadget is busy:\n      while (gadget-&gt;isbusy)\n      {\n        // Do nothing here.\n      }\n\n      // Set data first:\n      gadget-&gt;data    = data;\n\n      // Writing the command starts the action:\n      gadget-&gt;command = command;\n    }\n\ngadget-&gt;data = data\ngadget-&gt;command = command",
            "volatile\nvolatile\nvolatile",
            "volatile\nvolatile",
            "volatile\ni\nvolatile int i = 0;\n\nint main(int argc, char **argv)\n{\n    i *= argc;\n    return 0;\n}\n\nmain:\n        mov     eax, DWORD PTR i[rip]\n        add     eax, 1\n        mov     DWORD PTR i[rip], eax\n        xor     eax, eax\n        ret\ni:\n        .zero   4\n\nvolatile int i,j,k,l;\n\nint main(int argc, char **argv)\n{\n    i += j + k + l;\n}\n",
            "longjmp\nsetjmp/longjmp"
        ]
    },
    {
        "question_id": 1704407,
        "question_code": "char s[] = \"hello\";\n\nchar *s = \"hello\";\n",
        "answer_code_snippets": [
            "char *s = \"Hello world\";\n\n\"Hello world\"\ns\nchar s[] = \"Hello world\";\n\ns[0] = 'J';\n",
            "void foo(char *x);\nvoid foo(char x[]); // exactly the same in all respects\n\nchar *\nchar []\nchar *x = \"Foo\";\n// is approximately equivalent to:\nstatic const char __secret_anonymous_array[] = \"Foo\";\nchar *x = (char *) __secret_anonymous_array;\n\nx[1] = 'O'; // BAD. DON'T DO THIS.\n\nchar x[] = \"Foo\";\nx[1] = 'O'; // No problem.\n\nstrdup()",
            "char s[] = \"hello\";\n\nchar\ns\n'h', 'e', 'l', 'l', 'o', '\\0'\nchar *s =\"hello\";\n\nchar\n'h', 'e', 'l', 'l', 'o', '\\0'\ns\ns",
            "char *s0 = &quot;hello world&quot;;\nchar s1[] = &quot;hello world&quot;;\n\n0x00\n0x0001000C + 3\n0x0001000F\n&quot;hello world&quot;\nchar\nconst char\nchar *s0 = &quot;hello world&quot;;\n\ns0\nchar\ns0\n0x00008000\ns0\nstrtok()\nstrcat()\nstrcpy()\nchar s1[] = &quot;hello world&quot;;\n\ns1\nchar\n&quot;hello world&quot;\ns1\ns0\ns1\nsizeof s0 == sizeof (char*)\nsizeof s1 == 12\n\ntype of &amp;s0 == char **\ntype of &amp;s1 == char (*)[12] // pointer to a 12-element array of char\n\ns0\ns1",
            "char[]\nchar c[] = \"abc\";      \n\nchar c[] = {'a', 'b', 'c', '\\0'};\n\nc\nchar *c = \"abc\";\n\n/* __unnamed is magic because modifying it gives UB. */\nstatic char __unnamed[] = \"abc\";\nchar *c = __unnamed;\n\nchar[]\nchar *\nc[0]\n__unnamed\nchar s[] = \"abc\", t[3] = \"abc\";\n\ns\nt\nchar s[] = { 'a', 'b', 'c', '\\0' },\nt[] = { 'a', 'b', 'c' };\n\nchar *p = \"abc\";\n\np\np\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char *s = \"abc\";\n    printf(\"%s\\n\", s);\n    return 0;\n}\n\ngcc -ggdb -std=c99 -c main.c\nobjdump -Sr main.o\n\n char *s = \"abc\";\n8:  48 c7 45 f8 00 00 00    movq   $0x0,-0x8(%rbp)\nf:  00 \n        c: R_X86_64_32S .rodata\n\nchar*\n.rodata\n.text\n.rodata\n.text\nreadelf -l a.out\n\n Section to Segment mapping:\n  Segment Sections...\n   02     .text .rodata\n\nchar[]\n char s[] = \"abc\";\n\n17:   c7 45 f0 61 62 63 00    movl   $0x636261,-0x10(%rbp)\n\n%rbp",
            "char s[] = \"hello\";\n\ns\nchar\nchar\nchar *s = \"hello\";\n\ns\nchar\n\"hello\"",
            "char s[] = \"Hello world\";\n\ns\nchar *s = \"hello\";\n\ns",
            "printf(\"sizeof s[] = %zu\\n\", sizeof(s));  //6\nprintf(\"sizeof *s  = %zu\\n\", sizeof(s));  //4 or 8\n\n'\\0'",
            "[]\n*(&lt;var&gt; + &lt;index&gt;)\nprintf(\"%c\", x[1]);     //Prints r\n\nprintf(\"%c\", *(x + 1)); //Prints r\n\n*(x + 1) = 'a';\n",
            "printf(&quot;hello&quot; + 2); //llo\nchar a[] = &quot;hello&quot; + 2; //error\n",
            "char *str = \"Hello\";\n\nchar str[] = \"Hello\";\n\nmeans str[0] = 'M';\n",
            "char *s1 = \"Hello world\"; // Points to fixed character string which is not allowed to modify\nchar s2[] = \"Hello world\"; // As good as fixed array of characters in string so allowed to modify\n\n// s1[0] = 'J'; // Illegal\ns2[0] = 'J'; // Legal\n",
            "char *x = \"fred\";\n\nchar x[] = \"fred\";\n",
            "const DBJ* p means \"p points to a DBJ that is const\" \n\nDBJ* const p means \"p is a const pointer to a DBJ\" \n\nconst DBJ* const p means \"p is a const pointer to a const DBJ\" \n"
        ]
    },
    {
        "question_id": 9809213,
        "question_code": "",
        "answer_code_snippets": [
            ".a\n.so\n/usr/lib\n/lib\nLIBRARY_PATH"
        ]
    },
    {
        "question_id": 230062,
        "question_code": "int exists(const char *fname)\n{\n    FILE *file;\n    if ((file = fopen(fname, \"r\")))\n    {\n        fclose(file);\n        return 1;\n    }\n    return 0;\n}\n",
        "answer_code_snippets": [
            "access()\nunistd.h\nif (access(fname, F_OK) == 0) {\n    // file exists\n} else {\n    // file doesn't exist\n}\n\nunistd.h\n#ifdef WIN32\n#include &lt;io.h&gt;\n#define F_OK 0\n#define access _access\n#endif\n\nR_OK\nW_OK\nX_OK\nF_OK\nR_OK|W_OK\nW_OK\naccess( fname, W_OK )",
            "stat\n#include &lt;sys/stat.h&gt;   // stat\n#include &lt;stdbool.h&gt;    // bool type\n\nbool file_exists (char *filename) {\n  struct stat   buffer;   \n  return (stat (filename, &amp;buffer) == 0);\n}\n\n#include &lt;stdio.h&gt;      // printf\n\nint main(int ac, char **av) {\n    if (ac != 2)\n        return 1;\n\n    if (file_exists(av[1]))\n        printf(\"%s exists\\n\", av[1]);\n    else\n        printf(\"%s does not exist\\n\", av[1]);\n\n    return 0;\n}\n",
            "#include &lt;fcntl.h&gt;\n#include &lt;errno.h&gt;\n\nfd = open(pathname, O_CREAT | O_WRONLY | O_EXCL, S_IRUSR | S_IWUSR);\nif (fd &lt; 0) {\n  /* failure */\n  if (errno == EEXIST) {\n    /* the file already existed */\n    ...\n  }\n} else {\n  /* now you can use the file */\n}\n",
            "stat()\nstat(2)\nstat()\naccess()\nstat()",
            "FILE *file;\n    if((file = fopen(\"sample.txt\",\"r\"))!=NULL)\n        {\n            // file exists\n            fclose(file);\n        }\n    else\n        {\n            //File not found, no memory leak since 'file' == NULL\n            //fclose(file) would cause an error\n        }\n",
            "unistd.h\nLinux\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include&lt;unistd.h&gt;\n\nvoid fileCheck(const char *fileName);\n\nint main (void) {\n    char *fileName = \"/etc/sudoers\";\n\n    fileCheck(fileName);\n    return 0;\n}\n\nvoid fileCheck(const char *fileName){\n\n    if(!access(fileName, F_OK )){\n        printf(\"The File %s\\t was Found\\n\",fileName);\n    }else{\n        printf(\"The File %s\\t not Found\\n\",fileName);\n    }\n\n    if(!access(fileName, R_OK )){\n        printf(\"The File %s\\t can be read\\n\",fileName);\n    }else{\n        printf(\"The File %s\\t cannot be read\\n\",fileName);\n    }\n\n    if(!access( fileName, W_OK )){\n        printf(\"The File %s\\t it can be Edited\\n\",fileName);\n    }else{\n        printf(\"The File %s\\t it cannot be Edited\\n\",fileName);\n    }\n\n    if(!access( fileName, X_OK )){\n        printf(\"The File %s\\t is an Executable\\n\",fileName);\n    }else{\n        printf(\"The File %s\\t is not an Executable\\n\",fileName);\n    }\n}\n\nThe File /etc/sudoers    was Found\nThe File /etc/sudoers    cannot be read\nThe File /etc/sudoers    it cannot be Edited\nThe File /etc/sudoers    is not an Executable\n",
            "resolved_file = realpath(file_path, NULL);\nif (!resolved_keyfile) {\n   /*File dosn't exists*/\n   perror(keyfile);\n   return -1;\n}\n",
            "/* ACCESS.C: This example uses _access to check the\n * file named \"ACCESS.C\" to see if it exists and if\n * writing is allowed.\n */\n\n#include  &lt;io.h&gt;\n#include  &lt;stdio.h&gt;\n#include  &lt;stdlib.h&gt;\n\nvoid main( void )\n{\n   /* Check for existence */\n   if( (_access( \"ACCESS.C\", 0 )) != -1 )\n   {\n      printf( \"File ACCESS.C exists\\n\" );\n      /* Check for write permission */\n      if( (_access( \"ACCESS.C\", 2 )) != -1 )\n         printf( \"File ACCESS.C has write permission\\n\" );\n   }\n}\n\n_access(const char *path,\nint mode\n)\nfopen\nstat()"
        ]
    },
    {
        "question_id": 4295432,
        "question_code": "typedef void (*FunctionFunc)();\n\ntypedef\nvoid",
        "answer_code_snippets": [
            "typedef\ntypedef int myinteger;\ntypedef char *mystring;\ntypedef void (*myfunc)();\n\nmyinteger i;   // is equivalent to    int i;\nmystring s;    // is the same as      char *s;\nmyfunc f;      // compile equally as  void (*f)();\n\ntypedef\ntypedef\ntypedef\ntypedef int (*t_somefunc)(int,int);\n\nint product(int u, int v) {\n  return u*v;\n}\n\nt_somefunc afunc = &amp;product;\n...\nint x2 = (*afunc)(123, 456); // call product() to calculate 123*456\n",
            "typedef\nFunctionFunc\nvoid(*)()\ntypedef   void      (*FunctionFunc)  ( );\n//         ^                ^         ^\n//     return type      type name  arguments\n\nFunctionFunc\nFunctionFunc x;\nvoid doSomething() { printf(\"Hello there\\n\"); }\nx = &amp;doSomething;\n\nx(); //prints \"Hello there\"\n",
            "typedef\nFunctionFunc\nvoid\ntypedef\nFunctionFunc",
            "std::function\nusing\nusing FunctionFunc = std::function&lt;void(int arg1, std::string arg2)&gt;;\n",
            "#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\n\n/*\nTo define a new type name with typedef, follow these steps:\n1. Write the statement as if a variable of the desired type were being declared.\n2. Where the name of the declared variable would normally appear, substitute the new type name.\n3. In front of everything, place the keyword typedef.\n*/\n\n// typedef a primitive data type\ntypedef double distance;\n\n// typedef struct \ntypedef struct{\n    int x;\n    int y;\n} point;\n\n//typedef an array \ntypedef point points[100]; \n\npoints ps = {0}; // ps is an array of 100 point \n\n// typedef a function\ntypedef distance (*distanceFun_p)(point,point) ; // TYPE_DEF distanceFun_p TO BE int (*distanceFun_p)(point,point)\n\n// prototype a function     \ndistance findDistance(point, point);\n\nint main(int argc, char const *argv[])\n{\n    // delcare a function pointer \n    distanceFun_p func_p;\n\n    // initialize the function pointer with a function address\n    func_p = findDistance;\n\n    // initialize two point variables \n    point p1 = {0,0} , p2 = {1,1};\n\n    // call the function through the pointer\n    distance d = func_p(p1,p2);\n\n    printf(\"the distance is %f\\n\", d );\n\n    return 0;\n}\n\ndistance findDistance(point p1, point p2)\n{\ndistance xdiff =  p1.x - p2.x;\ndistance ydiff =  p1.y - p2.y;\n\nreturn sqrt( (xdiff * xdiff) + (ydiff * ydiff) );\n}\n",
            "typedef\nstorage-class-specifier\ndeclaration-specifiers\nlong typedef long a;\n\na\nlong long\nFunctionFunc"
        ]
    },
    {
        "question_id": 2670639,
        "question_code": "0x\n0x",
        "answer_code_snippets": [
            "0\nx\n8 1234\n0\n0\n00005 == 05\n#123\n0x\n00\n0h",
            "04524 // octal, leading 0\n\n8000h // hex\nFF00h // oops - valid identifier!  Hex or a variable or type named FF00h?\n\nxFF00 // also valid identifier\n\n#define ...\n#FF00 // invalid preprocessor token?\n\n0xFF00 // definitely not an identifier!\n",
            "0x6400\n6*16^3 + 4*16^2 + 0*16^1 +0*16^0 = 25600.\n0x6400\n0b00000001",
            "0x\n0b11101\n0o35\n0d29\n0x1D\n0"
        ]
    },
    {
        "question_id": 150355,
        "question_code": "",
        "answer_code_snippets": [
            "#include &lt;thread&gt;\n\n//may return 0 when not able to detect\nconst auto processor_count = std::thread::hardware_concurrency();\n\n#ifdef\nSYSTEM_INFO sysinfo;\nGetSystemInfo(&amp;sysinfo);\nint numCPU = sysinfo.dwNumberOfProcessors;\n\nint numCPU = sysconf(_SC_NPROCESSORS_ONLN);\n\nint mib[4];\nint numCPU;\nstd::size_t len = sizeof(numCPU); \n\n/* set the mib for hw.ncpu */\nmib[0] = CTL_HW;\nmib[1] = HW_AVAILCPU;  // alternatively, try HW_NCPU;\n\n/* get the number of CPUs from the system */\nsysctl(mib, 2, &amp;numCPU, &amp;len, NULL, 0);\n\nif (numCPU &lt; 1) \n{\n    mib[1] = HW_NCPU;\n    sysctl(mib, 2, &amp;numCPU, &amp;len, NULL, 0);\n    if (numCPU &lt; 1)\n        numCPU = 1;\n}\n\nint numCPU = mpctl(MPC_GETNUMSPUS, NULL, NULL);\n\nint numCPU = sysconf(_SC_NPROC_ONLN);\n\nNSUInteger a = [[NSProcessInfo processInfo] processorCount];\nNSUInteger b = [[NSProcessInfo processInfo] activeProcessorCount];\n",
            "#include &lt;thread&gt;\n\nunsigned int nthreads = std::thread::hardware_concurrency();\n\n#include &lt;boost/thread.hpp&gt;\n\nunsigned int nthreads = boost::thread::hardware_concurrency();\n\nhardware_concurrency()",
            "int omp_get_num_procs();\n",
            "#ifdef _WIN32\n#include &lt;windows.h&gt;\n#elif MACOS\n#include &lt;sys/param.h&gt;\n#include &lt;sys/sysctl.h&gt;\n#else\n#include &lt;unistd.h&gt;\n#endif\n\nint getNumCores() {\n#ifdef WIN32\n    SYSTEM_INFO sysinfo;\n    GetSystemInfo(&amp;sysinfo);\n    return sysinfo.dwNumberOfProcessors;\n#elif MACOS\n    int nm[2];\n    size_t len = 4;\n    uint32_t count;\n\n    nm[0] = CTL_HW; nm[1] = HW_AVAILCPU;\n    sysctl(nm, 2, &amp;count, &amp;len, NULL, 0);\n\n    if(count &lt; 1) {\n        nm[1] = HW_NCPU;\n        sysctl(nm, 2, &amp;count, &amp;len, NULL, 0);\n        if(count &lt; 1) { count = 1; }\n    }\n    return count;\n#else\n    return sysconf(_SC_NPROCESSORS_ONLN);\n#endif\n}\n",
            "NUMBER_OF_PROCESSORS\nprintf(\"%d\\n\", atoi(getenv(\"NUMBER_OF_PROCESSORS\")));\n",
            "size_t NumberOfPhysicalCores() noexcept {\n\n    DWORD length = 0;\n    const BOOL result_first = GetLogicalProcessorInformationEx(RelationProcessorCore, nullptr, &amp;length);\n    assert(GetLastError() == ERROR_INSUFFICIENT_BUFFER);\n\n    std::unique_ptr&lt; std::byte[] &gt; buffer(new std::byte[length]);\n    const PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX info = \n            reinterpret_cast&lt; PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX &gt;(buffer.get());\n\n    const BOOL result_second = GetLogicalProcessorInformationEx(RelationProcessorCore, info, &amp;length);\n    assert(result_second != FALSE);\n\n    size_t nb_physical_cores = 0;\n    size_t offset = 0;\n    do {\n        const PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX current_info =\n            reinterpret_cast&lt; PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX &gt;(buffer.get() + offset);\n        offset += current_info-&gt;Size;\n        ++nb_physical_cores;\n    } while (offset &lt; length);\n        \n    return nb_physical_cores;\n}\n\nNumberOfPhysicalCores\nGetLogicalProcessorInformation\nGetLogicalProcessorInformationEx\nGetLogicalProcessorInformation\nGetLogicalProcessorInformationEx\nsize_t NumberOfSystemCores() noexcept {\n    SYSTEM_INFO system_info;\n    ZeroMemory(&amp;system_info, sizeof(system_info));\n    \n    GetSystemInfo(&amp;system_info);\n    \n    return static_cast&lt; size_t &gt;(system_info.dwNumberOfProcessors);\n}\n",
            "grep processor /proc/cpuinfo | wc -l\n",
            "sysconf(_SC_NPROCESSORS_ONLN)\nHW_AVAILCPU/sysctl()",
            "sysconf(_SC_NPROCESSORS_CONF)\n\nsysconf(_SC_NPROCESSORS_ONLN)\n",
            "_SC_NPROCESSORS_ONLN\n_SC_NPROCESSORS_ONLN\n These values also exist, but may not be standard.\n\n     [...]     \n\n     - _SC_NPROCESSORS_CONF\n              The number of processors configured.   \n     - _SC_NPROCESSORS_ONLN\n              The number of processors currently online (available).\n\n/proc/stat\n/proc/cpuinfo\n#include&lt;unistd.h&gt;\n#include&lt;stdio.h&gt;\n\nint main(void)\n{\nchar str[256];\nint procCount = -1; // to offset for the first entry\nFILE *fp;\n\nif( (fp = fopen(\"/proc/stat\", \"r\")) )\n{\n  while(fgets(str, sizeof str, fp))\n  if( !memcmp(str, \"cpu\", 3) ) procCount++;\n}\n\nif ( procCount == -1) \n{ \nprintf(\"Unable to get proc count. Defaulting to 2\");\nprocCount=2;\n}\n\nprintf(\"Proc Count:%d\\n\", procCount);\nreturn 0;\n}\n\n/proc/cpuinfo\n#include&lt;unistd.h&gt;\n#include&lt;stdio.h&gt;\n\nint main(void)\n{\nchar str[256];\nint procCount = 0;\nFILE *fp;\n\nif( (fp = fopen(\"/proc/cpuinfo\", \"r\")) )\n{\n  while(fgets(str, sizeof str, fp))\n  if( !memcmp(str, \"processor\", 9) ) procCount++;\n}\n\nif ( !procCount ) \n{ \nprintf(\"Unable to get proc count. Defaulting to 2\");\nprocCount=2;\n}\n\nprintf(\"Proc Count:%d\\n\", procCount);\nreturn 0;\n}\n\ngrep -c ^processor /proc/cpuinfo\n\ngrep -c ^cpu /proc/stat # subtract 1 from the result\n",
            "#include&lt;sys/sysinfo.h&gt;\nint nproc = get_nprocs();\nint nproc_conf = get_nprocs_conf();\nprintf(&quot;processors available: %d, configured: %d\\n&quot;, nproc, nproc_conf);\n",
            "#include &lt;stdint.h&gt;\n\n#if defined(__APPLE__) || defined(__FreeBSD__)\n#include &lt;sys/sysctl.h&gt;\n\nuint32_t num_physical_cores(void)\n{\n    uint32_t num_cores      = 0;\n    size_t num_cores_len    = sizeof(num_cores);\n\n    sysctlbyname(&quot;hw.physicalcpu&quot;, &amp;num_cores, &amp;num_cores_len, 0, 0);\n\n    return num_cores;\n}\n#elif defined(__linux__)\n#include &lt;unistd.h&gt;\n#include &lt;stdio.h&gt;\nuint32_t num_physical_cores(void)\n{\n    uint32_t lcores = 0, tsibs = 0;\n\n    char buff[32];\n    char path[64];\n\n    for (lcores = 0;;lcores++) {\n        FILE *cpu;\n\n        snprintf(path, sizeof(path), &quot;/sys/devices/system/cpu/cpu%u/topology/thread_siblings_list&quot;, lcores);\n\n        cpu = fopen(path, &quot;r&quot;);\n        if (!cpu) break;\n\n        while (fscanf(cpu, &quot;%[0-9]&quot;, buff)) {\n            tsibs++;\n            if (fgetc(cpu) != ',') break;\n        }\n\n        fclose(cpu);\n    }\n\n    return lcores / (tsibs / lcores);\n}\n#else\n#error Unrecognized operating system\n#endif\n"
        ]
    },
    {
        "question_id": 252780,
        "question_code": "typedef struct \n{\n    int i;\n    char k;\n} elem;\n\nelem user;\n",
        "answer_code_snippets": [
            "struct\ntypedef struct {\n  int x, y;\n} Point;\n\nPoint point_new(int x, int y)\n{\n  Point a;\n  a.x = x;\n  a.y = y;\n  return a;\n}\n\ntypedef\nstruct\ntypedef struct Point Point;\n\nPoint * point_new(int x, int y);\n\nstruct\nstruct Point\n{\n  int x, y;\n};\n\nPoint * point_new(int x, int y)\n{\n  Point *p;\n  if((p = malloc(sizeof *p)) != NULL)\n  {\n    p-&gt;x = x;\n    p-&gt;y = y;\n  }\n  return p;\n}\n\ntypedef\nstruct",
            "#ifndef FOO_H\n#define FOO_H 1\n\n#define FOO_DEF (0xDEADBABE)\n\nstruct bar; /* forward declaration, defined in bar.h*/\n\nstruct foo {\n  struct bar *bar;\n};\n\n#endif\n\nFOO_DEF\nfoo\nstruct foo *foo;\n\nprintf(\"foo-&gt;bar = %p\", foo-&gt;bar);\n",
            "struct s\n    {\n    ...\n    };\n\ns x;    /* error in C */\ns *p;   /* error in C */\n\nstruct s x;     /* OK */\nstruct s *p;    /* OK */\n\nstruct s s;\n\nstruct s\n    {\n    ...\n    };\ntypedef struct s S;\n\nS x;\nS *p;\n\nS S;    // error\n\ntypedef struct\n    {\n    ...\n    } S;\n\ntypedef\ntypedef\ntypedef",
            "typedef\nstruct\nstruct elem\n{\n int i;\n char k;\n};\nelem user; // compile error!\nstruct elem user; // this is correct\n",
            "enum EnumDef\n{\n  FIRST_ITEM,\n  SECOND_ITEM\n};\n\nstruct StructDef\n{\n  enum EnuumDef MyEnum;\n  unsigned int MyVar;\n} MyStruct;\n\ntypedef \n{\n  FIRST_ITEM,\n  SECOND_ITEM\n} EnumDef;\n\ntypedef struct\n{\n  EnuumDef MyEnum; /* compiler error (unknown type) */\n  unsigned int MyVar;\n} StructDef;\nStrructDef MyStruct; /* compiler error (unknown type) */\n",
            "typedef\nvps_t a;\n\nstruct virtual_container *a;\n\ntypedef unsigned long myflags_t;\n",
            "typedef\ntypedef struct Tag{\n...members...\n}Type;\n\nType myType\nstruct Tag myTagType\nstruct Type myType\nTag myTagType\ntypedef Type *Type_ptr;\n\nType_ptr var1, var2;\nstruct Tag *myTagType1, myTagType2;\n\nvar1\nvar2\nmyTagType1\nmyTagType2\ntypedef struct MyWriter_t{\n    MyPipe super;\n    MyQueue relative;\n    uint32_t flags;\n...\n}MyWriter;\n\nvoid my_writer_func(MyPipe *s)\n{\n    MyWriter *self = (MyWriter *) s;\n    uint32_t myFlags = self-&gt;flags;\n...\n}\n\nflags\nMyPipe\n(struct MyWriter_ *) s;\ntypedef\n#define X char[10] or\ntypedef char Y[10]\n\nunsigned X x; but not\nunsigned Y y;\n\nvolatile\nconst",
            "struct point\n  {\n    int x, y;\n  };\n\npoint\nstruct point\n  {\n    int x, y;\n  } first_point, second_point;\n\nstruct point\n  {\n    int x, y;\n  };\nstruct point first_point, second_point;\n\nstruct point\ntypedef\ntypedef\ntypedef struct point\n  {\n    int x, y;\n  } Points;\n\nPoints first_point, second_point;\n",
            "struct MyStruct\n{\n  int i;\n};\n\n// The following is legal in C++:\nMyStruct obj;\nobj.i = 7;\n",
            "struct complex{ int real_part, img_part }COMPLEX;\n\nmain(){\n\n struct KOMPLEKS number; // number type is now a struct type\n number.real_part = 3;\n number.img_part = -1;\n printf(\"Number: %d.%d i \\n\",number.real_part, number.img_part);\n\n}\n\ntypedef struct complex{int real_part, img_part; }COMPLEX;\n//now COMPLEX is the new name for this structure and if I want to use it without\n// a keyword like in the first example 'struct complex number'.\n\nmain(){\n\nCOMPLEX number; // number is now the same type as in the first example\nnumber.real_part = 1;\nnumber.img)part = 5;\nprintf(\"%d %d \\n\", number.real_part, number.img_part);\n\n}\n",
            "struct bar;\nstruct foo;\n\nstruct foo {\n    struct bar *b;\n};\n\nstruct bar {\n    struct foo *f;\n};\n\ntypedef struct foo foo_t;\ntypedef struct bar bar_t;\n",
            "struct a\n{\n   int i;\n};\n\nstruct b\n{\n   struct a;\n   int i;\n   int j;\n};\n\nstruct b\n{\n    struct a\n    {\n        int i;\n    };\n    int i;\n    int j;\n}\n\ntypedef struct a A; //anticipated declaration for member declaration\n\ntypedef struct a //Implemented declaration\n{\n    A* b; // member declaration\n}A;\n"
        ]
    },
    {
        "question_id": 75191,
        "question_code": "unsigned char\nchar",
        "answer_code_snippets": [
            "char\nsigned char\nunsigned char\nchar\nchar\n'a'\n'0'\nint\n&quot;abcde&quot;\nsigned char\nunsigned char\nsigned char\nunsigned char\nsizeof (char)\nsizeof\n1\nsizeof (char) == sizeof (long) == 1",
            "char\nsigned\nunsigned\nsigned char\nunsigned char\nchar\nsigned char\nunsigned char\nsigned char\n-128\n127\nunsigned char\n0\n255\nchar\nsizeof(char)\n1\nCHAR_BIT\nlimits.h\n8\nint8_t\nuint8_t",
            "unsigned char\nunsigned char\n-1\nunsigned char\nunsigned char\n6.3.1.3p2\n-1\nunsigned char\nCHAR_BIT\nUCHAR_MAX+1\n-1\nUCHAR_MAX\nunsigned char\nunsigned char c = (unsigned char)-1;\n",
            "unsigned char\nunsigned char\nunsigned char\nsigned char\nsigned char\nunsigned char\nsigned char\nunsigned char",
            "signed char\nunsigned char\nchar\nchar",
            "unsigned char\nsigned char",
            "unsigned char\nchar\nchar",
            "char\nunsigned char",
            "CHAR_MIN\nCHAR_MAX\nCHAR_BIT\nchar\nunsigned char\nsigned char",
            "uint8_t\nint8_t\nuint16_t",
            "unsigned char\nunsigned char\nchar\nchar\nsigned char\nunsigned char",
            "unsigned char\nsigned char",
            "signed\nunsigned",
            "signed char\nunsigned char\n   Type        |      range\n-------------------------------\nsigned char    |  -128 to +127\nunsigned char  |     0 to 255\n\nsigned char\nchar letter = 'A'\nASCII/Unicode\nASCII/Unicode\n#include &lt;stdio.h&gt;\n\nint main()\n{\n    signed char char1 = 255;\n    signed char char2 = -128;\n    unsigned char char3 = 255;\n    unsigned char char4 = -128;\n\n    printf(\"Signed char(255) : %d\\n\",char1);\n    printf(\"Unsigned char(255) : %d\\n\",char3);\n\n    printf(\"\\nSigned char(-128) : %d\\n\",char2);\n    printf(\"Unsigned char(-128) : %d\\n\",char4);\n\n    return 0;\n}\n\nSigned char(255) : -1\nUnsigned char(255) : 255\n\nSigned char(-128) : -128\nUnsigned char(-128) : 128\n"
        ]
    },
    {
        "question_id": 25789644,
        "question_code": "",
        "answer_code_snippets": [
            "make\nCMake\nninja\nmake\nMakefile\nCMake\nCMake\nmake\nCMake\nmake\nMakefile\nmake\nCMake\nCMake\nmake\nmake\nmake\nCMake\nmake\nCMake\nmake\nset_property(TARGET helloworld APPEND PROPERTY INCLUDE_DIRECTORIES &quot;${CMAKE_CURRENT_SOURCE_DIR}&quot;)",
            "msbuild\nmsbuild /t:sdv /p:Inputs=&quot;Parameters&quot; ProjectFile /p:Configuration=configuration /p:Platform=platform\n"
        ]
    },
    {
        "question_id": 1662909,
        "question_code": "#include &lt;pthread.h&gt;\n#include &lt;stdio.h&gt;\n#define NUM_THREADS     5\n\nvoid *PrintHello(void *threadid)\n{\n   long tid;\n   tid = (long)threadid;\n   printf(\"Hello World! It's me, thread #%ld!\\n\", tid);\n   pthread_exit(NULL);\n}\n\nint main (int argc, char *argv[])\n{\n   pthread_t threads[NUM_THREADS];\n   int rc;\n   long t;\n   for(t=0; t&lt;NUM_THREADS; t++){\n      printf(\"In main: creating thread %ld\\n\", t);\n      rc = pthread_create(&amp;threads[t], NULL, PrintHello, (void *)t);\n      if (rc){\n         printf(\"ERROR; return code from pthread_create() is %d\\n\", rc);\n         exit(-1);\n      }\n   }\n   pthread_exit(NULL);\n}\n\ncorey@ubuntu:~/demo$ gcc -o term term.c\nterm.c: In function ‘main’:\nterm.c:23: warning: incompatible implicit declaration of built-in function ‘exit’\n/tmp/cc8BMzwx.o: In function `main':\nterm.c:(.text+0x82): undefined reference to `pthread_create'\ncollect2: ld returned 1 exit status\n\npthread.h\npthread_create",
        "answer_code_snippets": [
            "gcc -pthread -o term term.c\n\n-lpthread\nlibpthread.a\ngcc -lpthread ...\n",
            "gcc -o term term.c -lpthread\n",
            "gcc -o test test.c -pthread\n",
            "add_compile_options(-pthread)\n\nSET(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -pthread\")\n",
            "pthread\nCMake\nfind_package (Threads REQUIRED)\n\ntarget_link_libraries(helloworld\n    ${CMAKE_THREAD_LIBS_INIT}\n)\n",
            "-pthread\n-pthread",
            "-lpthread",
            "SYNOPSIS\n       #include &lt;pthread.h&gt;\n\n       int pthread_create(pthread_t *thread, const pthread_attr_t *attr,\n                          void *(*start_routine) (void *), void *arg);\n\n\n       Compile and link with -pthread.\n       ....\n",
            "#include &lt;functional&gt;\n\n&quot;compilerArgs&quot;: [&quot;-pthread&quot;],\n\nset(CMAKE_CXX_FLAGS &quot;-pthread&quot;)\n",
            "man gcc\n  -pthread\n       Define additional macros required for using the POSIX threads library.\n       You should use this option consistently for both compilation and linking.\n       This option is supported on GNU/Linux targets, \n           most other Unix derivatives, \n           and also on x86 Cygwin and MinGW targets.\n\n-pthread\n-pthread\n-lpthread -D_REENTRANT=1\n-pthread\n-lpthread\n_REENTRANT\n#define _REENTRANT 1\n-pthread\ngcc\n&lt;stdlib.h&gt;\nexit()\n-pthread",
            "LDFLAGS='-lpthread'\n"
        ]
    },
    {
        "question_id": 351733,
        "question_code": "",
        "answer_code_snippets": [
            "struct\ntypedef struct {\n    int (*open)(void *self, char *fspec);\n    int (*close)(void *self);\n    int (*read)(void *self, void *buff, size_t max_sz, size_t *p_act_sz);\n    int (*write)(void *self, void *buff, size_t max_sz, size_t *p_act_sz);\n    // And data goes here.\n} tCommClass;\n\ntCommClass commRs232;\ncommRs232.open = &amp;rs232Open;\n: :\ncommRs232.write = &amp;rs232Write;\n\ntCommClass commTcp;\ncommTcp.open = &amp;tcpOpen;\n: :\ncommTcp.write = &amp;tcpWrite;\n\nrs232Init()\nint stat = (commTcp.open)(commTcp, \"bigiron.box.com:5000\");\n\n#include &lt;stdio.h&gt;\n\n// The top-level class.\n\ntypedef struct sCommClass {\n    int (*open)(struct sCommClass *self, char *fspec);\n} tCommClass;\n\n// Function for the TCP 'class'.\n\nstatic int tcpOpen (tCommClass *tcp, char *fspec) {\n    printf (\"Opening TCP: %s\\n\", fspec);\n    return 0;\n}\nstatic int tcpInit (tCommClass *tcp) {\n    tcp-&gt;open = &amp;tcpOpen;\n    return 0;\n}\n\n// Function for the HTTP 'class'.\n\nstatic int httpOpen (tCommClass *http, char *fspec) {\n    printf (\"Opening HTTP: %s\\n\", fspec);\n    return 0;\n}\nstatic int httpInit (tCommClass *http) {\n    http-&gt;open = &amp;httpOpen;\n    return 0;\n}\n\n// Test program.\n\nint main (void) {\n    int status;\n    tCommClass commTcp, commHttp;\n\n    // Same 'base' class but initialised to different sub-classes.\n\n    tcpInit (&amp;commTcp);\n    httpInit (&amp;commHttp);\n\n    // Called in exactly the same manner.\n\n    status = (commTcp.open)(&amp;commTcp, \"bigiron.box.com:5000\");\n    status = (commHttp.open)(&amp;commHttp, \"http://www.microsoft.com\");\n\n    return 0;\n}\n\nOpening TCP: bigiron.box.com:5000\nOpening HTTP: http://www.microsoft.com\n",
            "stack_push(thing *)\n\nstack::push(thing *)\n\nclass stack {\n     public:\n        stack();\n        void push(thing *);\n        thing * pop();\n        static int this_is_here_as_an_example_only;\n     private:\n        ...\n};\n\nstruct stack {\n     struct stack_type * my_type;\n     // Put the stuff that you put after private: here\n};\nstruct stack_type {\n     void (* construct)(struct stack * this); // This takes uninitialized memory\n     struct stack * (* operator_new)(); // This allocates a new struct, passes it to construct, and then returns it\n     void (*push)(struct stack * this, thing * t); // Pushing t onto this stack\n     thing * (*pop)(struct stack * this); // Pops the top thing off the stack and returns it\n     int this_is_here_as_an_example_only;\n}Stack = {\n    .construct = stack_construct,\n    .operator_new = stack_operator_new,\n    .push = stack_push,\n    .pop = stack_pop\n};\n// All of these functions are assumed to be defined somewhere else\n\nstruct stack * st = Stack.operator_new(); // Make a new stack\nif (!st) {\n   // Do something about it\n} else {\n   // You can use the stack\n   stack_push(st, thing0); // This is a non-virtual call\n   Stack.push(st, thing1); // This is like casting *st to a Stack (which it already is) and doing the push\n   st-&gt;my_type.push(st, thing2); // This is a virtual call\n}\n",
            "this\nthis\nstruct Animal_Vtable{\n    typedef void (*Walk_Fun)(struct Animal *a_This);\n    typedef struct Animal * (*Dtor_Fun)(struct Animal *a_This);\n\n    Walk_Fun Walk;\n    Dtor_Fun Dtor;\n};\n\nstruct Animal{\n    Animal_Vtable vtable;\n\n    char *Name;\n};\n\nstruct Dog{\n    Animal_Vtable vtable;\n\n    char *Name; // Mirror member variables for easy access\n    char *Type;\n};\n\nvoid Animal_Walk(struct Animal *a_This){\n    printf(\"Animal (%s) walking\\n\", a_This-&gt;Name);\n}\n\nstruct Animal* Animal_Dtor(struct Animal *a_This){\n    printf(\"animal::dtor\\n\");\n    return a_This;\n}\n\nAnimal *Animal_Alloc(){\n    return (Animal*)malloc(sizeof(Animal));\n}\n\nAnimal *Animal_New(Animal *a_Animal){\n    a_Animal-&gt;vtable.Walk = Animal_Walk;\n    a_Animal-&gt;vtable.Dtor = Animal_Dtor;\n    a_Animal-&gt;Name = \"Anonymous\";\n    return a_Animal;\n}\n\nvoid Animal_Free(Animal *a_This){\n    a_This-&gt;vtable.Dtor(a_This);\n\n    free(a_This);\n}\n\nvoid Dog_Walk(struct Dog *a_This){\n    printf(\"Dog walking %s (%s)\\n\", a_This-&gt;Type, a_This-&gt;Name);\n}\n\nDog* Dog_Dtor(struct Dog *a_This){\n    // Explicit call to parent destructor\n    Animal_Dtor((Animal*)a_This);\n\n    printf(\"dog::dtor\\n\");\n\n    return a_This;\n}\n\nDog *Dog_Alloc(){\n    return (Dog*)malloc(sizeof(Dog));\n}\n\nDog *Dog_New(Dog *a_Dog){\n    // Explict call to parent constructor\n    Animal_New((Animal*)a_Dog);\n\n    a_Dog-&gt;Type = \"Dog type\";\n    a_Dog-&gt;vtable.Walk = (Animal_Vtable::Walk_Fun) Dog_Walk;\n    a_Dog-&gt;vtable.Dtor = (Animal_Vtable::Dtor_Fun) Dog_Dtor;\n\n    return a_Dog;\n}\n\nint main(int argc, char **argv){\n    /*\n      Base class:\n\n        Animal *a_Animal = Animal_New(Animal_Alloc());\n    */\n    Animal *a_Animal = (Animal*)Dog_New(Dog_Alloc());\n\n    a_Animal-&gt;vtable.Walk(a_Animal);\n\n    Animal_Free(a_Animal);\n}\n",
            "void *\n#ifndef FOO_H_\n#define FOO_H_\n\n...\n typedef struct FOO_type FOO_type;     /* That's all the rest of the program knows about FOO */\n\n/* Declaration of accessors, functions */\nFOO_type *FOO_new(void);\nvoid FOO_free(FOO_type *this);\n...\nvoid FOO_dosomething(FOO_type *this, param ...):\nchar *FOO_getName(FOO_type *this, etc);\n#endif\n\n#include &lt;stdlib.h&gt;\n...\n#include \"FOO.h\"\n\nstruct FOO_type {\n    whatever...\n};\n\n\nFOO_type *FOO_new(void)\n{\n    FOO_type *this = calloc(1, sizeof (FOO_type));\n\n    ...\n    FOO_dosomething(this, );\n    return this;\n}\n\nthis",
            "objc_msg_send",
            "#include&lt;stdio.h&gt;\n\nstruct foobarbaz{\n    int one;\n    int two;\n    int three;\n    int (*exampleMethod)(int, int);\n};\n\nint addTwoNumbers(int a, int b){\n    return a+b;\n}\n\nint main()\n{\n    // Define the function pointer\n    int (*pointerToFunction)(int, int) = addTwoNumbers;\n\n    // Let's make sure we can call the pointer\n    int test = (*pointerToFunction)(12,12);\n    printf (\"test: %u \\n\",  test);\n\n    // Now, define an instance of our struct\n    // and add some default values.\n    struct foobarbaz fbb;\n    fbb.one   = 1;\n    fbb.two   = 2;\n    fbb.three = 3;\n\n    // Now add a \"method\"\n    fbb.exampleMethod = addTwoNumbers;\n\n    // Try calling the method\n    int test2 = fbb.exampleMethod(13,36);\n    printf (\"test2: %u \\n\",  test2);\n\n    printf(\"\\nDone\\n\");\n    return 0;\n}\n",
            "#include &lt;stdio.h&gt;\n\nstruct Node {\n    int somevar;\n};\n\nvoid print() {\n    printf(\"Hello from an object-oriented C method!\");\n};\n\nstruct Tree {\n    struct Node * NIL;\n    void (*FPprint)(void);\n    struct Node *root;\n    struct Node NIL_t;\n} TreeA = {&amp;TreeA.NIL_t,print};\n\nint main()\n{\n    struct Tree TreeB;\n    TreeB = TreeA;\n    TreeB.FPprint();\n    return 0;\n}\n",
            "#include \"OOStd.h\"\n\nCLASS(Animal) {\n    char *name;\n    STATIC(Animal);\n    vFn talk;\n};\nstatic int Animal_load(Animal *THIS,void *name) {\n    THIS-&gt;name = name;\n    return 0;\n}\nASM(Animal, Animal_load, NULL, NULL, NULL)\n\nCLASS_EX(Cat,Animal) {\n    STATIC_EX(Cat, Animal);\n};\nstatic void Meow(Animal *THIS){\n    printf(\"Meow!My name is %s!\\n\", THIS-&gt;name);\n}\n\nstatic int Cat_loadSt(StAnimal *THIS, void *PARAM){\n    THIS-&gt;talk = (void *)Meow;\n    return 0;\n}\nASM_EX(Cat,Animal, NULL, NULL, Cat_loadSt, NULL)\n\n\nCLASS_EX(Dog,Animal){\n    STATIC_EX(Dog, Animal);\n};\n\nstatic void Woof(Animal *THIS){\n    printf(\"Woof!My name is %s!\\n\", THIS-&gt;name);\n}\n\nstatic int Dog_loadSt(StAnimal *THIS, void *PARAM) {\n    THIS-&gt;talk = (void *)Woof;\n    return 0;\n}\nASM_EX(Dog, Animal, NULL, NULL, Dog_loadSt, NULL)\n\nint main(){\n    Animal *animals[4000];\n    StAnimal *f;\n    int i = 0;\n    for (i=0; i&lt;4000; i++)\n    {\n        if(i%2==0)\n            animals[i] = NEW(Dog,\"Jack\");\n        else\n            animals[i] = NEW(Cat,\"Lily\");\n    };\n    f = ST(animals[0]);\n    for(i=0; i&lt;4000; ++i) {\n        f-&gt;talk(animals[i]);\n    }\n    for (i=0; i&lt;4000; ++i) {\n        DELETE0(animals[i]);\n    }\n    return 0;\n}\n",
            "#include&lt;favorite_OO_Guru.h&gt;",
            "//private_class.h\nstruct private_class;\nextern struct private_class * new_private_class();\nextern int ret_a_value(struct private_class *, int a, int b);\nextern void delete_private_class(struct private_class *);\nvoid (*late_bind_function)(struct private_class *p);\n\n//private_class.c\nstruct inherited_class_1;\nstruct inherited_class_2;\n\nstruct private_class {\n  int a;\n  int b;\n  struct inherited_class_1 *p1;\n  struct inherited_class_2 *p2;\n};\n\nstruct inherited_class_1 * new_inherited_class_1();\nstruct inherited_class_2 * new_inherited_class_2();\n\nstruct private_class * new_private_class() {\n  struct private_class *p;\n  p = (struct private_class*) malloc(sizeof(struct private_class));\n  p-&gt;a = 0;\n  p-&gt;b = 0;\n  p-&gt;p1 = new_inherited_class_1();\n  p-&gt;p2 = new_inherited_class_2();\n  return p;\n}\n\n    int ret_a_value(struct private_class *p, int a, int b) {\n      return p-&gt;a + p-&gt;b + a + b;\n    }\n\n    void delete_private_class(struct private_class *p) {\n      //release any resources\n      //call delete methods for inherited classes\n      free(p);\n    }\n    //main.c\n    struct private_class *p;\n    p = new_private_class();\n    late_bind_function = &amp;implementation_function;\n    delete_private_class(p);\n\nc_compiler main.c inherited_class_1.obj inherited_class_2.obj  private_class.obj",
            "typedef struct _peeker\n{\n    log_t     *log;\n    symbols_t *sym;\n    scanner_t  scan;            // inherited instance\n    peek_t     pk;\n    int        trace;\n\n    void    (*push) ( SELF *d, symbol_t *symbol );\n    short   (*peek) ( SELF *d, int level );\n    short   (*get)  ( SELF *d );\n    int     (*get_line_number) ( SELF *d );\n\n} peeker_t, SlkToken;\n\n#define push(self,a)            (*self).push(self, a)\n#define peek(self,a)            (*self).peek(self, a)\n#define get(self)               (*self).get(self)\n#define get_line_number(self)   (*self).get_line_number(self)\n\nINSTANCE_METHOD\nint\n(get_line_number) ( peeker_t *d )\n{\n    return  d-&gt;scan.line_number;\n}\n\nPUBLIC\nvoid\nInitializePeeker ( peeker_t  *peeker,\n                   int        trace,\n                   symbols_t *symbols,\n                   log_t     *log,\n                   list_t    *list )\n{\n    InitializeScanner ( &amp;peeker-&gt;scan, trace, symbols, log, list );\n    peeker-&gt;log = log;\n    peeker-&gt;sym = symbols;\n    peeker-&gt;pk.current = peeker-&gt;pk.buffer;\n    peeker-&gt;pk.count = 0;\n    peeker-&gt;trace = trace;\n\n    peeker-&gt;get_line_number = get_line_number;\n    peeker-&gt;push = push;\n    peeker-&gt;get = get;\n    peeker-&gt;peek = peek;\n}\n",
            "#include \"triangle.h\"\n#include \"rectangle.h\"\n#include \"polygon.h\"\n\n#include &lt;stdio.h&gt;\n\nint main()\n{\n    Triangle tr1= CTriangle-&gt;new();\n    Rectangle rc1= CRectangle-&gt;new();\n\n    tr1-&gt;width= rc1-&gt;width= 3.2;\n    tr1-&gt;height= rc1-&gt;height= 4.1;\n\n    CPolygon-&gt;printArea((Polygon)tr1);\n\n    printf(\"\\n\");\n\n    CPolygon-&gt;printArea((Polygon)rc1);\n}\n\n/*output:\n6.56\n13.12\n*/\n",
            "foo-&gt;method(a,b,c)\nmethod(foo,a,b,c)\nFOO_method(foo,a,b,c)"
        ]
    },
    {
        "question_id": 137038,
        "question_code": "",
        "answer_code_snippets": [
            "gcc\ng++\ngcc -S helloworld.c\n\nhelloworld.s\n-o -\ngcc -S -o my_asm_output.s helloworld.c\n\n--disassemble\n-d\nobjdump -S --disassemble helloworld &gt; helloworld.dump\n\n-S\nfile helloworld\nobjdump\n-rwC\n-Mintel\nobjdump -drwC -Mintel -S foo.o | less\n-r\n.o\n00 00 00 00",
            "# Create assembler code:\ng++ -S -fverbose-asm -g -O2 test.cc -o test.s\n\n# Create asm interlaced with source lines:\nas -alhnd test.s &gt; test.lst\n",
            "g++ -g -O -Wa,-aslh horton_ex2_05.cpp &gt;list.txt\n\ncd C:\\gpp_code\ng++ -g -O -Wa,-aslh horton_ex2_05.cpp &gt; list.txt\n\nhorton_ex2_05.cpp: In function `int main()':\nhorton_ex2_05.cpp:92: warning: assignment to `int' from `double'\n\n  16:horton_ex2_05.cpp **** using std::setw;\n  17:horton_ex2_05.cpp ****\n  18:horton_ex2_05.cpp **** void disp_Time_Line (void);\n  19:horton_ex2_05.cpp ****\n  20:horton_ex2_05.cpp **** int main(void)\n  21:horton_ex2_05.cpp **** {\n 164                    %ebp\n 165                            subl $128,%esp\n?GAS LISTING C:\\DOCUME~1\\CRAIGM~1\\LOCALS~1\\Temp\\ccx52rCc.s\n166 0128 55                    call ___main\n167 0129 89E5          .stabn 68,0,21,LM2-_main\n168 012b 81EC8000      LM2:\n168      0000\n169 0131 E8000000      LBB2:\n169      00\n170                    .stabn 68,0,25,LM3-_main\n171                    LM3:\n172                            movl $0,-16(%ebp)\n",
            "-save-temps\ngcc -save-temps -c -o main.o main.c\n\n#define INC 1\n\nint myfunc(int i) {\n    return i + INC;\n}\n\nmain.o\nmain.i\n# 1 &quot;main.c&quot;\n# 1 &quot;&lt;built-in&gt;&quot;\n# 1 &quot;&lt;command-line&gt;&quot;\n# 31 &quot;&lt;command-line&gt;&quot;\n# 1 &quot;/usr/include/stdc-predef.h&quot; 1 3 4\n# 32 &quot;&lt;command-line&gt;&quot; 2\n# 1 &quot;main.c&quot;\n\n\nint myfunc(int i) {\n    return i + 1;\n}\n\nmain.s\n    .file    &quot;main.c&quot;\n    .text\n    .globl    myfunc\n    .type    myfunc, @function\nmyfunc:\n.LFB0:\n    .cfi_startproc\n    pushq    %rbp\n    .cfi_def_cfa_offset 16\n    .cfi_offset 6, -16\n    movq    %rsp, %rbp\n    .cfi_def_cfa_register 6\n    movl    %edi, -4(%rbp)\n    movl    -4(%rbp), %eax\n    addl    $1, %eax\n    popq    %rbp\n    .cfi_def_cfa 7, 8\n    ret\n    .cfi_endproc\n.LFE0:\n    .size    myfunc, .-myfunc\n    .ident    &quot;GCC: (Ubuntu 8.3.0-6ubuntu1) 8.3.0&quot;\n    .section    .note.GNU-stack,&quot;&quot;,@progbits\n\n-save-temps=obj\n-save-temps=obj\n\n-o\ngcc -save-temps -c -o out/subdir/main.o subdir/main.c\n\nout/subdir/main.i\nout/subdir/main.o\nout/subdir/main.s\n\n-save-temps -v\n-v\ngcc -save-temps -c -o main.o -v main.c\n\n/tmp\n/usr/lib/gcc/x86_64-linux-gnu/8/cc1 -E -quiet -v -imultiarch x86_64-linux-gnu main.c -mtune=generic -march=x86-64 -fpch-preprocess -fstack-protector-strong -Wformat -Wformat-security -o main.i\n/usr/lib/gcc/x86_64-linux-gnu/8/cc1 -fpreprocessed main.i -quiet -dumpbase main.c -mtune=generic -march=x86-64 -auxbase-strip main.o -version -fstack-protector-strong -Wformat -Wformat-security -o main.s\nas -v --64 -o main.o main.s\n\nmake help\n\nmake main.s\n\nCompiling C source to assembly CMakeFiles/main.dir/main.c.s\n/usr/bin/cc    -S /home/ciro/hello/main.c -o CMakeFiles/main.dir/main.c.s\n\nCMakeFiles/main.dir/main.c.s",
            "g++ -S main.cpp\n\ngcc\ngcc -S main.c\n",
            "gcc -S\n#!/usr/bin/perl -w\n$ptr='(BYTE|WORD|DWORD|QWORD|XMMWORD) PTR ';\n$reg='(?:[er]?(?:[abcd]x|[sd]i|[sb]p)|[abcd][hl]|r1?[0-589][dwb]?|mm[0-7]|xmm1?[0-9])';\nopen FH, '-|', '/usr/bin/objdump', '-w', '-M', 'intel', @ARGV or die;\n$prev = &quot;&quot;;\nwhile(&lt;FH&gt;){\n    if(/$ptr/o) {\n        s/$ptr(\\[[^\\[\\]]+\\],$reg)/$2/o or\n        s/($reg,)$ptr(\\[[^\\[\\]]+\\])/$1$3/o or\n        s/$ptr/lc $1/oe;\n    }\n    if($prev =~ /\\t(repz )?ret / and\n       $_ =~ /\\tnop |\\txchg *ax,ax$/) {\n       # drop this line\n    } else {\n       print $prev;\n       $prev = $_;\n    }\n}\nprint $prev;\nclose FH;\n\ngcc -S",
            "-S\n-O0\n-O2",
            "gcc -S program.c\n",
            "llvm-gcc -emit-llvm -S hello.c\n",
            "gcc -S program.c &amp;&amp; gcc program.c -o output\n",
            "cd C:\\gcc\ngcc -S complete path of the C file  ENTER\n\ngcc  -S D:\\Aa_C_Certified\\alternate_letters.c\n\ncpp filename.s ENTER\n\ncpp alternate_letters.s  &lt;enter&gt;\n",
            "gcc main.c    // 'main.c' source file\ngdb a.exe     // 'gdb a.out' in Linux\n\ndisass main   // Note here 'main' is a function\n              // Similarly, it can be done for other functions.\n"
        ]
    },
    {
        "question_id": 2386772,
        "question_code": "float\ndouble",
        "answer_code_snippets": [
            "double\nfloat\ndouble\nfloat\ndouble\nfloat\nfloat a = 1.f / 81;\nfloat b = 0;\nfor (int i = 0; i &lt; 729; ++ i)\n    b += a;\nprintf(&quot;%.7g\\n&quot;, b); // prints 9.000023\n\ndouble a = 1.0 / 81;\ndouble b = 0;\nfor (int i = 0; i &lt; 729; ++ i)\n    b += a;\nprintf(&quot;%.15g\\n&quot;, b); // prints 8.99999999999996\n\n3e38\n1.7e308\nfloat\ndouble\ndouble\nlong double\nint\n+=\nfsum\nfloat\ndouble\nlong double\nfloat\ndouble",
            "float\ndouble\nlong double\ndouble\nfloat\nlong double\ndouble\nfloat\ndouble\ndouble\nlong double",
            "float\ndouble\n#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\n\nvoid dbl_solve(double a, double b, double c)\n{\n    double d = b*b - 4.0*a*c;\n    double sd = sqrt(d);\n    double r1 = (-b + sd) / (2.0*a);\n    double r2 = (-b - sd) / (2.0*a);\n    printf(&quot;%.5f\\t%.5f\\n&quot;, r1, r2);\n}\n\nvoid flt_solve(float a, float b, float c)\n{\n    float d = b*b - 4.0f*a*c;\n    float sd = sqrtf(d);\n    float r1 = (-b + sd) / (2.0f*a);\n    float r2 = (-b - sd) / (2.0f*a);\n    printf(&quot;%.5f\\t%.5f\\n&quot;, r1, r2);\n}   \n\nint main(void)\n{\n    float fa = 1.0f;\n    float fb = -4.0000000f;\n    float fc = 3.9999999f;\n    double da = 1.0;\n    double db = -4.0000000;\n    double dc = 3.9999999;\n    flt_solve(fa, fb, fc);\n    dbl_solve(da, db, dc);\n    return 0;\n}  \n\n2.00000 2.00000\n2.00032 1.99968\n\nfloat",
            "#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n\nint main(){\n  for(float t=0;t&lt;1;t+=0.01){\n     std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; t &lt;&lt; std::endl;\n  }\n}\n\n0.000000\n0.010000\n0.020000\n0.030000\n0.040000\n0.050000\n0.060000\n0.070000\n0.080000\n0.090000\n0.100000\n0.110000\n0.120000\n0.130000\n0.140000\n0.150000\n0.160000\n0.170000\n0.180000\n0.190000\n0.200000\n0.210000\n0.220000\n0.230000\n0.240000\n0.250000\n0.260000\n0.270000\n0.280000\n0.290000\n0.300000\n0.310000\n0.320000\n0.330000\n0.340000\n0.350000\n0.360000\n0.370000\n0.380000\n0.390000\n0.400000\n0.410000\n0.420000\n0.430000\n0.440000\n0.450000\n0.460000\n0.470000\n0.480000\n0.490000\n0.500000\n0.510000\n0.520000\n0.530000\n0.540000\n0.550000\n0.560000\n0.570000\n0.580000\n0.590000\n0.600000\n0.610000\n0.620000\n0.630000\n0.640000\n0.650000\n0.660000\n0.670000\n0.680000\n0.690000\n0.700000\n0.710000\n0.720000\n0.730000\n0.740000\n0.750000\n0.760000\n0.770000\n0.780000\n0.790000\n0.800000\n0.810000\n0.820000\n0.830000\n0.839999\n0.849999\n0.859999\n0.869999\n0.879999\n0.889999\n0.899999\n0.909999\n0.919999\n0.929999\n0.939999\n0.949999\n0.959999\n0.969999\n0.979999\n0.989999\n0.999999\n\nt",
            "double\nfloat\nfloat\ndouble\ndouble\nfloat\ndouble\nfloat\nfloat\ndouble\nfloat\ndouble\ndouble\nfloat\ndouble\nfloat\ndouble\nfloat",
            "int\nfloat\ndouble\ndouble\nfloat"
        ]
    },
    {
        "question_id": 2524611,
        "question_code": "size_t\nprintf()\n%u\ng++ -g -W -Wall -Werror -ansi -pedantic\nsize_t x = &lt;something&gt;;\nprintf(\"size = %u\\n\", x);\n\nwarning: format '%u' expects type 'unsigned int', \n    but argument 2 has type 'long unsigned int'\n\n%lu\nunsigned long\n%lu",
        "answer_code_snippets": [
            "z\nsize_t x = ...;\nssize_t y = ...;\nprintf(\"%zu\\n\", x);  // prints as unsigned decimal\nprintf(\"%zx\\n\", x);  // prints as hex\nprintf(\"%zd\\n\", y);  // prints as signed decimal\n",
            "%zu\n%zx\n%zd\n%Iu\n%Ix\n%Id\n%zu\ncout",
            "%lu\nunsigned long\nsize_t foo;\n...\nprintf(\"foo = %lu\\n\", (unsigned long) foo);\n\n%zu\nsize_t foo;\n...\nprintf(\"foo = %zu\\n\", foo);\n",
            "&quot;%zu&quot;\nsize_t\nprintf(&quot;sizeof (int) = %zu\\n&quot;, sizeof (int));\n\n&quot;%zu&quot;\nunsigned long\n&quot;%lu&quot;\nprintf(&quot;sizeof (int) = %lu\\n&quot;, (unsigned long)sizeof (int));\n\nlong long\nunsigned long long\nsize_t\nunsigned long\n&quot;%lu&quot;\n&quot;%llu&quot;\nsize_t\nprintf(&quot;%lu\\n&quot;, sizeof (int));\n#if __STDC_VERSION__ &lt; 199901L\n    printf(&quot;sizeof (int) = %lu\\n&quot;, (unsigned long)sizeof (int));\n#else\n    printf(&quot;sizeof (int) = %zu\\n&quot;, sizeof (int));\n#endif\n\n__STD_VERSION__ &gt;= 199901L\n&quot;%zu&quot;\n__STD_VERSION__\n&quot;%zu&quot;\nlong long\nsize_t\nunsigned long long\n&quot;%zu&quot;\n__STDC_VERSION__\nunsigned long\nsize_t\n&quot;%zu&quot;\nunsigned long\nsize_t\nULONG_MAX\n&quot;%zu&quot;\n#include &lt;stdio.h&gt;\n#include &lt;limits.h&gt;\nint main(void) {\n    const size_t size = -1; /* largest value of type size_t */\n#if __STDC_VERSION__ &lt; 199901L\n    if (size &gt; ULONG_MAX) {\n        printf(&quot;size is too big to print\\n&quot;);\n    }\n    else {\n        printf(&quot;old: size = %lu\\n&quot;, (unsigned long)size);\n    }\n#else\n    printf(&quot;new: size = %zu\\n&quot;, size);\n#endif\n    return 0;\n}\n\nx86_64-w64-mingw32-gcc.exe -std=c90\nunsigned long long\nunsigned long long\n&quot;%llu&quot;\n&quot;%zu&quot;\nsize_t\nstd::cout &lt;&lt; sizeof (int)",
            "printf(\"size = %zu\\n\", sizeof(thing) );\n",
            "// test.c\n\n#include &lt;stdio.h&gt;\n#include &lt;BaseTsd.h&gt; // see the note below\n\nint main()\n{\n    size_t x = 1;\n    SSIZE_T y = 2;\n    printf(\"%zu\\n\", x);  // prints as unsigned decimal\n    printf(\"%zx\\n\", x);  // prints as hex\n    printf(\"%zd\\n\", y);  // prints as signed decimal\n    return 0;\n}\n\nssize_t\nSSIZE_T\n&lt;BaseTsd.h&gt;\nC11 - &lt;stdalign.h&gt;\nC11 - &lt;stdatomic.h&gt;\nC11 - &lt;stdnoreturn.h&gt;\nC99 - &lt;tgmath.h&gt;\nC11 - &lt;threads.h&gt;\n\n&lt;uchar.h&gt;",
            "std::cout &lt;&lt; boost::format(\"Sizeof(Var) is %d\\n\") % sizeof(Var);\n",
            "std::size_t s = 1024;\nstd::cout &lt;&lt; s; // or any other kind of stream like stringstream!\n",
            "size_t\nint\nprintf(&quot;int is %u bytes&quot;, (unsigned)sizeof (int) );\n\nprintf(&quot;int is %zu bytes&quot;, sizeof (int) );\n\nint\nunsigned int\nsizeof (int)\nunsigned\nsizeof (int)",
            "&lt;inttypes.h&gt;",
            "%p",
            "char text[] = \"Lets go fishing in stead of sitting on our but !!\";\nsize_t line = 2337200120702199116;\n\n/* on windows I64x or I64d others %lld or %llx if it works %zd or %zx */\nprintf(\"number: %I64d\\n\",*(size_t*)&amp;text);\nprintf(\"text: %s\\n\",*(char(*)[])&amp;line);\n"
        ]
    },
    {
        "question_id": 1518711,
        "question_code": "",
        "answer_code_snippets": [
            "malloc()\nfree()",
            "free\n ____ The allocated block ____\n/                             \\\n+--------+--------------------+\n| Header | Your data area ... |\n+--------+--------------------+\n          ^\n          |\n          +-- The address you are given\n\nmalloc\nmalloc\nfree",
            "comp.lang.c",
            "malloc\nfree\nfree\nfree\nfree\nfree\nmalloc\nmalloc",
            "malloc()\nfree()",
            "malloc",
            "typedef struct {\n    size_t numElements\n    int elements[1]; /* but enough space malloced for numElements at runtime */\n} IntArray_t;\n\n#define SIZE 10\nIntArray_t* myArray = malloc(sizeof(intArray_t) + SIZE * sizeof(int));\nmyArray-&gt;numElements = SIZE;\n",
            "malloc()"
        ]
    },
    {
        "question_id": 1903954,
        "question_code": "",
        "answer_code_snippets": [
            "template &lt;typename T&gt; int sgn(T val) {\n    return (T(0) &lt; val) - (val &lt; T(0));\n}\n\ncopysign\n&lt; 0\n-Wtype-limits\n template &lt;typename T&gt; inline constexpr\n int signum(T x, std::false_type is_signed) {\n     return T(0) &lt; x;\n }\n\n template &lt;typename T&gt; inline constexpr\n int signum(T x, std::true_type is_signed) {\n     return (T(0) &lt; x) - (x &lt; T(0));\n }\n\n template &lt;typename T&gt; inline constexpr\n int signum(T x) {\n     return signum(x, std::is_signed&lt;T&gt;());\n }\n",
            "(x &gt; 0) - (x &lt; 0)\n\nif (x &gt; 0) return 1;\nif (x &lt; 0) return -1;\nreturn 0;\n\n(x &gt; 0) ? 1 : ((x &lt; 0) ? -1 : 0)\n",
            "result = copysign(1.0, value) // double\nresult = copysignf(1.0, value) // float\nresult = copysignl(1.0, value) // long double\n",
            "sgn",
            "copysign\ncopysign(1.0, arg)\nboost\n    #include &lt;boost/math/special_functions/sign.hpp&gt;\n\n    //Returns 1 if x &gt; 0, -1 if x &lt; 0, and 0 if x is zero.\n    template &lt;class T&gt;\n    inline int sign (const T&amp; z);\n",
            "signbit()\n&lt;math.h&gt;\nint signbit\nx\nsignbit\n#define signbit_p1_or_n1(x)  ((signbit(x) ?  -1 : 1)\n\nx\n0.0, -0.0, +NaN, -NaN\nsignum()\n+1\nx&gt;0\n-1\nx&lt;0\n0\nx==0\nx\n-0.0, +NaN, -NaN\nsignnum_typical()\n-0.0, +NaN, -NaN\n0.0, 0.0, 0.0\nint signnum_typical(double x) {\n  if (x &gt; 0.0) return 1;\n  if (x &lt; 0.0) return -1;\n  return 0;\n}\n\n-0.0, +NaN, -NaN\n-0.0, +NaN, -NaN\ndouble signnum_c(double x) {\n  if (x &gt; 0.0) return 1.0;\n  if (x &lt; 0.0) return -1.0;\n  return x;\n}\n",
            "(x &lt; 0) ? -1 : (x &gt; 0)\n",
            "sign = -(int)((unsigned int)((int)v) &gt;&gt; (sizeof(int) * CHAR_BIT - 1));\n",
            "abs()\nx == 0.0\n(x &gt; 0) - (x &lt; 0)\ndefine _Generic\ncopysignf(1.0f, x)\ncopysign(1.0, x)\ncopysignl(1.0l, x)",
            "is_signed\ntemplate &lt;typename T&gt; inline constexpr\n  int signum(T x, std::false_type) {\n  return T(0) &lt; x;\n}\n\ntemplate &lt;typename T&gt; inline constexpr\n  int signum(T x, std::true_type) {\n  return (T(0) &lt; x) - (x &lt; T(0));\n}\n\ntemplate &lt;typename T&gt; inline constexpr\n  int signum(T x) {\n  return signum(x, std::is_signed&lt;T&gt;());\n}\n\ntemplate &lt;typename T&gt;\ntypename std::enable_if&lt;std::is_unsigned&lt;T&gt;::value, int&gt;::type\ninline constexpr signum(T const x) {\n    return T(0) &lt; x;  \n}\n\ntemplate &lt;typename T&gt;\ntypename std::enable_if&lt;std::is_signed&lt;T&gt;::value, int&gt;::type\ninline constexpr signum(T const x) {\n    return (T(0) &lt; x) - (x &lt; T(0));  \n}\n",
            "#include &lt;math.h&gt;\n\nint signValue(float a) {\n    return ((!signbit(a)) &lt;&lt; 1) - 1;\n}\n",
            "boost::math::sign()\nboost/math/special_functions/sign.hpp",
            "#define sign(a) ( ( (a) &lt; 0 )  ?  -1   : ( (a) &gt; 0 ) )\n",
            "template&lt;typename T&gt;\nconstexpr int sgn(const T &amp;a, const T &amp;b) noexcept{\n    return (a &gt; b) - (a &lt; b);\n}\n\ntemplate&lt;typename T&gt;\nconstexpr int sgn(const T &amp;a) noexcept{\n    return sgn(a, T(0));\n}\n\nint comp(unsigned a, unsigned b){\n   return sgn( int(a) - int(b) );\n}\n\nint comp(unsigned a, unsigned b){\n   return sgn(a, b);\n}\n\ntemplate &lt;class T&gt;\nint comp(const T &amp;a, const T &amp;b){\n    log__(\"all\");\n    if (a &lt; b)\n        return -1;\n\n    if (a &gt; b)\n        return +1;\n\n    return 0;\n}\n\ninline int comp(int const a, int const b){\n    log__(\"int\");\n    return a - b;\n}\n\ninline int comp(long int const a, long int const b){\n    log__(\"long\");\n    return sgn(a, b);\n}\n",
            "inline int signum(const double x) {\n    if(x == 0) return 0;\n    return (1 - (static_cast&lt;int&gt;((*reinterpret_cast&lt;const uint64_t*&gt;(&amp;x)) &gt;&gt; 63) &lt;&lt; 1));\n}\n\ninline int signum(const double x) {\n    return (x != 0) * \n        (1 - (static_cast&lt;int&gt;((*reinterpret_cast&lt;const uint64_t*&gt;(&amp;x)) &gt;&gt; 63) &lt;&lt; 1));\n}\n",
            "template &lt;typename T&gt; double sgn(T val) {\n    return double((T(0) &lt; val) - (val &lt; T(0)))/(val == val);\n}\n\nNAN\nval = -NAN\nval = NAN\nnan\n-nan\nabs(val)",
            "int sign(float n)\n{     \n  union { float f; std::uint32_t i; } u { n };\n  return 1 - ((u.i &gt;&gt; 31) &lt;&lt; 1);\n}\n",
            "double signof(double a) { return (a == 0) ? 0 : (a&lt;0 ? -1 : 1); }\n",
            "#define sgn(x) x==0 ? 0 : x/abs(x)\n"
        ]
    },
    {
        "question_id": 1775865,
        "question_code": "",
        "answer_code_snippets": [
            "SubSystem",
            "Tools-&gt;Options-&gt;Debugging-&gt;Automatically close the console\n",
            "#include &lt;stdlib.h&gt;\n\n#ifdef _WIN32\n    #define WINPAUSE system(\"pause\")\n#endif\n\n#ifdef _WIN32\nWINPAUSE\nWINPAUSE;",
            "Console.ReadLine()\n&lt;ENTER&gt;",
            "getchar()\nmain()",
            "int main() {\n  ...\n#if _DEBUG\n  LOG_INFO(\"end, press key to close\");\n  getchar();\n#endif // _DEBUG\n  return 0;\n}\n",
            "system(\"pause\");\n",
            "runthenpause.bat\n%1 %2 %3 %4 %5 %6 %7 %8 %9\npause\n\n$(TargetPath)\nrunthenpause.bat\nrunthenpause.bat\n/Z7",
            "if (Debugger.IsAttached)\n{\n    Console.WriteLine(&quot;Debugger is attached. Press any key to exit.&quot;);\n    Console.ReadKey();\n}\n",
            "int a = 0;\nscanf(\"%d\",&amp;a);\n\nreturn YOUR_MAIN_CODE;\n\na",
            "Console.WriteLine(\"Press any key to exit...\");\nConsole.ReadKey();\n\nprivate void Pause()\nPause()",
            "atexit([] { system(\"PAUSE\"); });\n\ncin.sync(); cin.ignore();\nsystem(\"pause\");\nextern \"C\" int __stdcall IsDebuggerPresent(void);\nint main(int argc, char** argv) {\n    if (IsDebuggerPresent())\n        atexit([] {system(\"PAUSE\"); });\n    ...\n}\n",
            "Console.ReadLine()",
            "cin.get();\nsystem(\"pause\");\nmain()\nreturn",
            "#include &lt;conio.h&gt; \n/* run this program using the console pauser or add your own getch, system(\"pause\") or input loop */\nint main() {\n   .\n   .\n   .\n   getch(); \n\n   return 0;\n}\n",
            "CTRL\nALT\nL\nProperties\nLinker\nSystem\nSubSystem\nCONSOLE\nApply\nTools\nOptions...\nCTRL\nE\nconsole\nEnter\nDebugging\nGeneral\nAutomatically close the console when debugging stops\nCTRL\nF5",
            "#include &lt;iostream&gt;;\n\nint main()\n{\n    getchar();\n    return 0;\n}\n"
        ]
    },
    {
        "question_id": 24886,
        "question_code": "i++\n++i",
        "answer_code_snippets": [
            "i++\n++i\ni\n++i\ni++\n$ cat i++.c\nextern void g(int i);\nvoid f()\n{\n    int i;\n\n    for (i = 0; i &lt; 100; i++)\n        g(i);\n\n}\n\n++i\ni++\n$ diff i++.c ++i.c\n6c6\n&lt;     for (i = 0; i &lt; 100; i++)\n---\n&gt;     for (i = 0; i &lt; 100; ++i)\n\n$ gcc -c i++.c ++i.c\n$ gcc -S i++.c ++i.c\n\n$ md5 i++.s ++i.s\nMD5 (i++.s) = 90f620dda862cd0205cd5db1f2c8c06e\nMD5 (++i.s) = 90f620dda862cd0205cd5db1f2c8c06e\n\n$ md5 *.o\nMD5 (++i.o) = dd3ef1408d3a9e4287facccec53f7d22\nMD5 (i++.o) = dd3ef1408d3a9e4287facccec53f7d22\n",
            "++i\ni++\ni++\n++i\n++i",
            "++i\ni\nint\ni\ni++\n++i\nFoo Foo::operator++()\n{\n  Foo oldFoo = *this; // copy existing value - could be slow\n  // yadda yadda, do increment\n  return oldFoo;\n}\n\n++i\n++i\ni++",
            "i++\n++i\n++i\ni++\nfor(i=0; i&lt;n; i++)\ni++\ni++\ni\n1\n++\ni\n1\n++i\ni++\narray[i++] = x;\narray[++i] = x;\ni\narray[i++] = x;\ni\ni\ni\ni\ni\n++\n++\n++",
            "// Prefix\nInteger&amp; Integer::operator++()\n{\n    *this += 1;\n    return *this;\n}\n\n// Postfix\nconst Integer Integer::operator++(int)\n{\n    Integer oldValue = *this;\n    ++(*this);\n    return oldValue;\n}\n",
            "i++\n++i\n++i\n++i\ni\n++i\nfoo(i++)\nfoo()\nfoo()\ni\ni++\n++i\ni++\ni++\n++i\ni++",
            "for (i = 0; i &lt; 100; i++)\n\n1\ni\ni\n100\ni\n100\nfor (i = 100; i != 0; i--)\n\ni\nZ==0",
            "i++\n++i\n--i\ni--\n*(i++)\n*(++i)",
            "A\na = ++b + c;\n\n; increment b\nLD    A, [&amp;b]\nINC   A\nST    A, [&amp;b]\n\n; add with c\nADD   A, [&amp;c]\n\n; store in a\nST    A, [&amp;a]\n\na = b++ + c;\n\n; load b\nLD    A, [&amp;b]\n\n; add with c\nADD   A, [&amp;c]\n\n; store in a\nST    A, [&amp;a]\n\n; increment b\nLD    A, [&amp;b]\nINC   A\nST    A, [&amp;b]\n\nb\ni++;\nb++\n++b\n- 1\nb++\n++b\n++b\na = b++ + 1;\na = ++b;",
            "myArray[i++] = \"hello\";\n\nmyArray[++i] = \"hello\";\n"
        ]
    },
    {
        "question_id": 8225776,
        "question_code": "#include &lt;stdio.h&gt;\n\nint main() {\n    int x = 5;\n    printf(&quot;%d and &quot;, sizeof(x++)); // note 1\n    printf(&quot;%d\\n&quot;, x); // note 2\n    return 0;\n}\n\nx\n4 and 5\n\nx",
        "answer_code_snippets": [
            "sizeof\nsizeof\nshort func(short x) {  // this function never gets called !!\n   printf(\"%d\", x);    // this print never happens\n   return x;\n}\n\nint main() {\n   printf(\"%d\", sizeof(func(3))); // all that matters to sizeof is the \n                                  // return type of the function.\n   return 0;\n}\n\n2\n\nshort\ndouble\ndouble func(short x) {\n// rest all same\n\n8",
            "sizeof(foo)\nmalloc(3)",
            "sizeof\n(sizeof x)  // This also works\n",
            "6.5.3.4\nsizeof(char[x++]);\n\nsizeof(char[func()]);\n\n6.7.5.2\n6.7.6.2\nsizeof(int (*)[x++])\n",
            "++i\ni++\nsizeof(foo())",
            "sizeof\nint f(); //no definition, which means we cannot call it\n\nint main(void) {\n        printf(\"%d\", sizeof(f()) );  //no linker error\n        return 0;\n}\n\nf\nsizeof\nsizeof\nsizeof\nsizeof(f())\nf()\nf\nstruct A\n{\n  A(); //no definition, which means we cannot create instance!\n  int f(); //no definition, which means we cannot call it\n};\n\nint main() {\n        std::cout &lt;&lt; sizeof(A().f())&lt;&lt; std::endl;\n        return 0;\n}\n\nsizeof\nA\nA()\nf\nA().f()\nsizeof",
            "sizeof\nx++\nsizeof\nsizeof",
            "printf(&quot;%d and &quot;, sizeof(x++)); // note 1\n\n%d\nint\nsize_t\nstdout\n%d\n%zu\nint\nx",
            "sizeof()"
        ]
    },
    {
        "question_id": 1018853,
        "question_code": "alloca()\nmalloc()\nmalloc()\nalloca()",
        "answer_code_snippets": [
            "man\nalloca\nmalloc",
            "alloca\nvoid DoSomething() {\n   wchar_t* pStr = alloca(100);\n   //......\n}\n\nvoid Process() {\n   for (i = 0; i &lt; 1000000; i++) {\n     DoSomething();\n   }\n}\n\nDoSomething\nProcess()\nalloca\nalloca",
            "char arr[size];\n\nchar *arr=alloca(size);\n",
            "alloca\nalloca\nalloca",
            "while\nfor\nfor {int i = 0; i &lt; 2; ++i) { X }\nalloca\ninline\nalloca\nalloca\nalloca\nmalloc\nmalloc\nWonderfulObject_DestructorFree(ptr)\nWonderfulObject* p = WonderfulObject_AllocConstructor();\nmalloc\np\nalloca\nWonderfulObject_AllocConstructor\nfree\nalloca()\nalloca()\nmalloc\nrealloc\nfree\nalloca\n#include &lt;alloca.h&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nstruct Base\n{\n    virtual ~Base() { }\n    virtual int to_int() const = 0;\n};\n\nstruct Integer : Base\n{\n    Integer(int n) : n_(n) { }\n    int to_int() const { return n_; }\n    int n_;\n};\n\nstruct Double : Base\n{\n    Double(double n) : n_(n) { }\n    int to_int() const { return -n_; }\n    double n_;\n};\n\ninline Base* factory(double d) __attribute__((always_inline));\n\ninline Base* factory(double d)\n{\n    if ((double)(int)d != d)\n        return new (alloca(sizeof(Double))) Double(d);\n    else\n        return new (alloca(sizeof(Integer))) Integer(d);\n}\n\nint main()\n{\n    std::vector&lt;Base*&gt; numbers;\n    numbers.push_back(factory(29.3));\n    numbers.push_back(factory(29));\n    numbers.push_back(factory(7.1));\n    numbers.push_back(factory(2));\n    numbers.push_back(factory(231.0));\n    for (std::vector&lt;Base*&gt;::const_iterator i = numbers.begin();\n         i != numbers.end(); ++i)\n    {\n        std::cout &lt;&lt; *i &lt;&lt; ' ' &lt;&lt; (*i)-&gt;to_int() &lt;&lt; '\\n';\n        (*i)-&gt;~Base();   // optionally / else Undefined Behaviour iff the\n                         // program depends on side effects of destructor\n    }\n}\n",
            "alloca()\nalloca()\nalloca()\nalloca()\nalloca()\nalloca()\nalloca()\nalloca()\nalloca()\nalloca()",
            "alloca()\nmalloc()\nalloca( 0x00ffffff )\nchar hugeArray[ 0x00ffffff ];",
            "alloca\nlongjmp\nsetjmp\nalloca\nlongjmp\nalloca\nalloca\nalloca\nlongjmp\nalloca\nsetjmp\nalloca\nalloca\nsetjmp\nalloca\nalloca\nalloca\nlongjmp\nalloca\njmp_buf\nalloca",
            "char x;\nchar *y=malloc(1);\nchar *z=alloca(&amp;x-y);\n*z = 1;\n\nalloca\nalloca\nalloca",
            "alloca\nalloca",
            "malloc()\nalloca()",
            "alloca()\nmalloc()\nalloca()\nalloca()",
            "alloca()\nalloca()\nmalloc()\nmalloc()\nmalloc()\nmalloc()\nrealloc()\nrealloc()",
            "longjmp\nalloca\nalloca\nalloca\n1-&gt;2-&gt;3-&gt;1",
            "alloca()\nmalloc()\nalloca()\nalloca()",
            "_alloca()\n_alloca()\nwhile (condition) {\n    char buffer[0x100]; // Chill.\n    /* ... */\n}\n\nwhile (condition) {\n    char* buffer = _alloca(0x100); // Bad!\n    /* ... */\n}\n",
            "free()\nreturn;"
        ]
    },
    {
        "question_id": 859634,
        "question_code": "int* arr1[8];\nint (*arr2)[8];\nint *(arr3[8]);\n",
        "answer_code_snippets": [
            "int* arr[8]; // An array of int pointers.\nint (*arr)[8]; // A pointer to an array of integers\n",
            "$ cdecl\nType `help' or `?' for help\ncdecl&gt; explain int* arr1[8];\ndeclare arr1 as array 8 of pointer to int\ncdecl&gt; explain int (*arr2)[8]\ndeclare arr2 as pointer to array 8 of int\ncdecl&gt; explain int *(arr3[8])\ndeclare arr3 as array 8 of pointer to int\ncdecl&gt;\n\ncdecl&gt; declare x as pointer to function(void) returning pointer to float\nfloat *(*x)(void )\n",
            "int* arr1[8];\n\narr1\nint (*arr2)[8];\n\narr2\nint *(arr3[8]);\n\narr3",
            "int *a[4]; // Array of 4 pointers to int\n\nint (*a)[4]; //a is a pointer to an integer array of size 4\n\nint (*a[8])[5]; //a is an array of pointers to integer array of size 5 \n",
            "int (*arr2)[8];\narr2\nint *(arr3[8]);\narr3\nfloat *(*x)(void )\nx\nfloat\narr2\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\n#define NUM_ELEM(ar) (sizeof(ar) / sizeof((ar)[0]))\n\nint *\nput_off(const int newrow[2])\n{\n    static int mymatrix[3][2];\n    static int (*rowp)[2] = mymatrix;\n    int (* const border)[] = mymatrix + NUM_ELEM(mymatrix);\n\n    memcpy(rowp, newrow, sizeof(*rowp));\n    rowp += 1;\n    if (rowp == border) {\n        rowp = mymatrix;\n    }\n\n    return *rowp;\n}\n\nint\nmain(int argc, char *argv[])\n{\n    int i = 0;\n    int row[2] = {0, 1};\n    int *rout;\n\n    for (i = 0; i &amp;lt; 6; i++) {\n        row[0] = i;\n        row[1] += i;\n        rout = put_off(row);\n        printf(\"%d (%p): [%d, %d]\\n\", i, (void *) rout, rout[0], rout[1]);\n    }\n\n    return 0;\n}\n\n0 (0x804a02c): [0, 0]\n1 (0x804a034): [0, 0]\n2 (0x804a024): [0, 1]\n3 (0x804a02c): [1, 2]\n4 (0x804a034): [2, 4]\n5 (0x804a024): [3, 7]\n\nconst int (*border)[3]",
            "typedef int (*PointerToIntArray)[];\ntypedef int *ArrayOfIntPointers[];\n",
            "[]\n()\nint *(*ptr)()[];",
            "example int * (*ptr)()[];\nstart from ptr \n\nptr",
            "int *something[n];\n\n[]\n*\n[]\n*\nint *(something[i]);\n\nint num\nnum\nint\nint *ptr\nint (*ptr)\nptr\nint\nptr\nint\nint (*something)[n];\n\nsomethingElse[i]\n*(somethingElse + i)\nsomethingElse\n(*something)\n*(*something + i)\n(*something)",
            "int B[8]\n(*A) == B\nint* (*C) [8]",
            "int *arr1[5]\n\narr1\nint (*arr2)[5]\n\narr2"
        ]
    },
    {
        "question_id": 1993390,
        "question_code": "",
        "answer_code_snippets": [
            "gcc\n-fpic\n-fPIC\ngcc",
            "Static linking\nDynamic linking\nABI",
            "crunchgen\ninit\nld.so\ncrunchgen"
        ]
    },
    {
        "question_id": 577554,
        "question_code": "",
        "answer_code_snippets": [
            "float\nuint64_t\n__int128\n// on a 32-bit machine, int can hold 32-bit fixed-point integers.\nint inline FixedPointMul (int a, int b)\n{\n  long long a_long = a; // cast to 64 bit.\n\n  long long product = a_long * b; // perform multiplication\n\n  return (int) (product &gt;&gt; 16);  // shift by the fixed point bias\n}\n\nint inline FixedPointMul (int a, int b)\n{\n    return (int) __ll_rshift(__emul(a,b),16);\n}\n\npopcnt\nffs()\nbsf\nbsr\npopcnt\n__builtin_popcnt\n_mm_popcnt_u32\n&lt;immintrin.h&gt;\nstd::bitset&lt;32&gt;\n.count()\nntohl\nbswap\ndst[i] += src[i] * 10.0;",
            "#include \"stdafx.h\"\n#include &lt;windows.h&gt;\n\nfloat KahanSum(const float *data, int n)\n{\n   float sum = 0.0f, C = 0.0f, Y, T;\n\n   for (int i = 0 ; i &lt; n ; ++i) {\n      Y = *data++ - C;\n      T = sum + Y;\n      C = T - sum - Y;\n      sum = T;\n   }\n\n   return sum;\n}\n\nfloat AsmSum(const float *data, int n)\n{\n  float result = 0.0f;\n\n  _asm\n  {\n    mov esi,data\n    mov ecx,n\n    fldz\n    fldz\nl1:\n    fsubr [esi]\n    add esi,4\n    fld st(0)\n    fadd st(0),st(2)\n    fld st(0)\n    fsub st(0),st(3)\n    fsub st(0),st(2)\n    fstp st(2)\n    fstp st(2)\n    loop l1\n    fstp result\n    fstp result\n  }\n\n  return result;\n}\n\nint main (int, char **)\n{\n  int count = 1000000;\n\n  float *source = new float [count];\n\n  for (int i = 0 ; i &lt; count ; ++i) {\n    source [i] = static_cast &lt;float&gt; (rand ()) / static_cast &lt;float&gt; (RAND_MAX);\n  }\n\n  LARGE_INTEGER start, mid, end;\n\n  float sum1 = 0.0f, sum2 = 0.0f;\n\n  QueryPerformanceCounter (&amp;start);\n\n  sum1 = KahanSum (source, count);\n\n  QueryPerformanceCounter (&amp;mid);\n\n  sum2 = AsmSum (source, count);\n\n  QueryPerformanceCounter (&amp;end);\n\n  cout &lt;&lt; \"  C code: \" &lt;&lt; sum1 &lt;&lt; \" in \" &lt;&lt; (mid.QuadPart - start.QuadPart) &lt;&lt; endl;\n  cout &lt;&lt; \"asm code: \" &lt;&lt; sum2 &lt;&lt; \" in \" &lt;&lt; (end.QuadPart - mid.QuadPart) &lt;&lt; endl;\n\n  return 0;\n}\n\n  C code: 500137 in 103884668\nasm code: 500137 in 52129147\n\nloop",
            "for (int y=0; y &lt; imageHeight; y++) {\n    for (int x=0; x &lt; imageWidth; x++) {\n       // do something\n    }\n}\n",
            "int16_t x, y;\n// int16_t is a typedef for \"short\"\n// set x and y to something\nint16_t prod = (int16_t)(((int32_t)x*y)&gt;&gt;16);`\n\n// 256-bit array shifted right in its entirety:\nuint8_t x[32];\nfor (int i = 32; --i &gt; 0; )\n{\n   x[i] = (x[i] &gt;&gt; 1) | (x[i-1] &lt;&lt; 7);\n}\nx[0] &gt;&gt;= 1;\n",
            "strlen()\nint c;\nfor(c = 0; str[c] != '\\0'; c++) {}\n\nmov esi, offset string\nmov edi, esi\nxor ecx, ecx\n\nlp:\nmov ax, byte ptr [esi]\ncmp al, cl\nje  end_1\ncmp ah, cl\nje end_2\nmov bx, byte ptr [esi + 2]\ncmp bl, cl\nje end_3\ncmp bh, cl\nje end_4\nadd esi, 4\njmp lp\n\nend_4:\ninc esi\n\nend_3:\ninc esi\n\nend_2:\ninc esi\n\nend_1:\ninc esi\n\nmov ecx, esi\nsub ecx, edi\n",
            "movzx\nadd eax, 1\ninc eax",
            "add edx,[DeltaVFrac] ; add in dVFrac\nsbb ebp,ebp ; store carry\nmov [edi],al ; write pixel n\nmov al,[esi] ; fetch pixel n+1\nadd ecx,ebx ; add in dUFrac\nadc esi,[4*ebp + UVStepVCarry]; add in steps\n"
        ]
    },
    {
        "question_id": 1461432,
        "question_code": "",
        "answer_code_snippets": [
            "int numbers [5]\nnumbers = 0x5a5aff23\nnumbers\nint*\nint [5]\nsizeof\nvoid by_value(const T* array)   // const T array[] means the same\nvoid by_pointer(const T (*array)[U])\nvoid by_reference(const T (&amp;array)[U])\n\nsizeof",
            "const int a[] = { 2, 3, 5, 7, 11 };\n\nconst int* p = a;\n\nsizeof\nassert( sizeof(p) != sizeof(a) );  // sizes are not equal\n",
            "sizeof\n&amp;\nchar a[80];\nstrcpy(a, &quot;This is a test&quot;);\n\na\nstrcpy()\nsizeof\n&amp;\nstrcpy()\nchar *strcpy(char *dest, const char *src);\n\nchar a[80];\nchar *ptr_to_first_element = a;\nchar (*ptr_to_array)[80] = &amp;a;\n\nptr_to_first_element\nptr_to_array\na[i] == ptr_to_first_element[i] == (*ptr_to_array)[i] != *ptr_to_array[i] != ptr_to_array[i]\n\na[i]\n*(a+i)\na[i]\nptr_to_first_element[i]\n(*ptr_to_array)[i]\n*(*a+i)\n*ptr_to_array[i]\nptr_to_array[i]\na[i]\nsizeof a == sizeof *ptr_to_array == 80\n\nsizeof\nsizeof *ptr_to_first_element == sizeof (char) == 1\nsizeof ptr_to_first_element == sizeof (char *) == whatever the pointer size\n                                                  is on your platform\n\nptr_to_first_element",
            "pointer to (type of array elements)\nvoid foo(int arr[]);\n\nfoo\nint arr[5];\nint *ip = &amp;(arr[1]);\nif (arr == ip) { /* something; */ }\n\narr\nip\narr[42];\n/* same as *(arr + 42); */\n/* same as *(&amp;(arr[0]) + 42); */\n",
            "\nvoid f(double a[10]) {\n    printf(&quot;in function: %d&quot;, sizeof(a));\n    printf(&quot;pointer size: %d\\n&quot;, sizeof(double *));\n}\n\nint main() {\n    double a[10];\n    printf(&quot;in main: %d&quot;, sizeof(a));\n    f(a);\n}\n\nsizeof\nmain\nvoid f(double a[10]\nvoid f(double *a)\n*a\na[100]\na[1]\na[10]",
            "void do_something(int *array) {\n  // We don't know how big array is here, because it's decayed to a pointer.\n  printf(\"%i\\n\", sizeof(array));  // always prints 4 on a 32-bit machine\n}\n\nint main (int argc, char **argv) {\n    int a[10];\n    int b[20];\n    int *c;\n    printf(\"%zu\\n\", sizeof(a)); //prints 40 on a 32-bit machine\n    printf(\"%zu\\n\", sizeof(b)); //prints 80 on a 32-bit machine\n    printf(\"%zu\\n\", sizeof(c)); //prints 4 on a 32-bit machine\n    do_something(a);\n    do_something(b);\n    do_something(c);\n}\n\nvoid do_something(int array[][10])\n{\n    // We don't know how big the first dimension is.\n}\n\nint main(int argc, char *argv[]) {\n    int a[5][10];\n    int b[20][10];\n    do_something(a);\n    do_something(b);\n    return 0;\n}\n",
            "arr[idx]\n*(arr + idx)\nstruct\nsizeof()",
            "#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;cassert&gt;\n\nusing namespace std;\n\n// test data\n// notice native array init with no copy aka \"=\"\n// not possible in C\n const char* specimen[]{ __TIME__, __DATE__, __TIMESTAMP__ };\n\n// ONE\n// simple, dangerous and useless\ntemplate&lt;typename T&gt;\nvoid as_pointer(const T* array) { \n    // a pointer\n    assert(array != nullptr); \n} ;\n\n// TWO\n// for above const T array[] means the same\n// but and also , minimum array size indication might be given too\n// this also does not stop the array decay into T *\n// thus size information is lost\ntemplate&lt;typename T&gt;\nvoid by_value_no_size(const T array[0xFF]) { \n    // decayed to a pointer\n    assert( array != nullptr ); \n}\n\n// THREE\n// size information is preserved\n// but pointer is asked for\ntemplate&lt;typename T, size_t N&gt;\nvoid pointer_to_array(const T (*array)[N])\n{\n   // dealing with native pointer \n    assert( array != nullptr ); \n}\n\n// FOUR\n// no C equivalent\n// array by reference\n// size is preserved\ntemplate&lt;typename T, size_t N&gt;\nvoid reference_to_array(const T (&amp;array)[N])\n{\n    // array is not a pointer here\n    // it is (almost) a container\n    // most of the std:: lib algorithms \n    // do work on array reference, for example\n    // range for requires std::begin() and std::end()\n    // on the type passed as range to iterate over\n    for (auto &amp;&amp; elem : array )\n    {\n        cout &lt;&lt; endl &lt;&lt; elem ;\n    }\n}\n\nint main()\n{\n     // ONE\n     as_pointer(specimen);\n     // TWO\n     by_value_no_size(specimen);\n     // THREE\n     pointer_to_array(&amp;specimen);\n     // FOUR\n     reference_to_array( specimen ) ;\n}\n",
            "int a[5]\nint *a\nint (*a)[5]\nint a[5]\nint a[5]\nint (*a)[5]\na\nint *\nint a[5]\na\na+1\n*(a+1)\nint\nint a[5]\nint\nint\nint *\nint (*)[5]\na\na\nint a[5]\na\nsizeof\nint a[5]\nint *a\nint *\nint (*a)[5]"
        ]
    },
    {
        "question_id": 12717138,
        "question_code": "",
        "answer_code_snippets": []
    },
    {
        "question_id": 426230,
        "question_code": "",
        "answer_code_snippets": [
            "LD_PRELOAD\nlibc.so\nls\nmalloc()\n$ LD_PRELOAD=/path/to/my/malloc.so /bin/ls\n",
            "LD_PRELOAD\nLD_LIBRARY_PATH",
            "LD_PRELOAD\nldd\nlibselinux.so.1\n&gt; ldd /bin/ls\n    ...\n    libselinux.so.1 =&gt; /lib/x86_64-linux-gnu/libselinux.so.1 (0x00007f3927b1d000)\n    libacl.so.1 =&gt; /lib/x86_64-linux-gnu/libacl.so.1 (0x00007f3927914000)\n    libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f392754f000)\n    libpcre.so.3 =&gt; /lib/x86_64-linux-gnu/libpcre.so.3 (0x00007f3927311000)\n    libdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f392710c000)\n    /lib64/ld-linux-x86-64.so.2 (0x00007f3927d65000)\n    libattr.so.1 =&gt; /lib/x86_64-linux-gnu/libattr.so.1 (0x00007f3926f07000)\n\nexport LD_PRELOAD=/home/patric/libselinux.so.1\n\n&gt;ldd /bin/ls\n    ...\n    libselinux.so.1 =&gt;\n    /home/patric/libselinux.so.1 (0x00007fb9245d8000)\n    ...\n",
            "LD_PRELOAD\nmalloc\nfree\nLD_PRELOAD\nmalloc\nfree",
            "LD_PRELOAD\n/etc/ld.so.preload\n/lib/ld-linux.so\nLD_PRELOAD",
            "mylib.so\n$ export LD_PRELOAD=/path/mylib.so\n$ ./mybin\n\n$ unset LD_PRELOAD\n",
            "LD_PRELOAD",
            "$export LD_PRELOAD=/path/lib"
        ]
    },
    {
        "question_id": 146159,
        "question_code": "",
        "answer_code_snippets": [
            "void transform (float *output, float const * input, float const * matrix, int *n)\n{\n    int i;\n    for (i=0; i&lt;*n; i++)\n    {\n        float x = input[i*2+0];\n        float y = input[i*2+1];\n        output[i*2+0] = matrix[0] * x + matrix[1] * y;\n        output[i*2+1] = matrix[2] * x + matrix[3] * y;\n    }\n}\n\nint\nrestrict\ndouble*\nint*\nchar*\nvoid*\nrestrict\nCALL TRANSFORM(A(1, 30), A(2, 31), A(3, 32), 30)",
            "matmul(a,b)\n\nsqrt(sum(x**2))\n\nFORALL\nPURE\nELEMENTAL",
            "struct { double re; double im; };",
            "strcpy(char *d, const char* s)\n{\n  while(*d++ = *s++);\n}\n"
        ]
    },
    {
        "question_id": 10087113,
        "question_code": "*\nint a = 10;\nint *p = &amp;a;\n\nint **q = &amp;p;\nint ***r = &amp;q;\n\nint ****************zz;\n",
        "answer_code_snippets": [
            "C",
            "struct list { struct list *next; ... };\n\nlist-&gt;next-&gt;next-&gt;next-&gt;...-&gt;next\n*(*(..(*(*(*list).next).next).next...).next).next\n.next\n***..***ptr",
            "size = 10\ng++ create.cpp -o create ; ./create &gt; ptr.cpp ; g++ ptr.cpp -o ptr ; ./ptr\n#include &lt;iostream&gt;\n\nint main()\n{\n    const int size = 200;\n    std::cout &lt;&lt; \"#include &lt;iostream&gt;\\n\\n\";\n    std::cout &lt;&lt; \"int main()\\n{\\n\";\n    std::cout &lt;&lt; \"    int i0 = \" &lt;&lt; size &lt;&lt; \";\";\n    for (int i = 1; i &lt; size; ++i)\n    {\n        std::cout &lt;&lt; \"    int \";\n        for (int j = 0; j &lt; i; ++j) std::cout &lt;&lt; \"*\";\n        std::cout &lt;&lt; \" i\" &lt;&lt; i &lt;&lt; \" = &amp;i\" &lt;&lt; i-1 &lt;&lt; \";\\n\";\n    }\n    std::cout &lt;&lt; \"    std::cout &lt;&lt; \";\n    for (int i = 1; i &lt; size; ++i) std::cout &lt;&lt; \"*\";\n    std::cout &lt;&lt; \"i\" &lt;&lt; size-1 &lt;&lt; \" &lt;&lt; \\\"\\\\n\\\";\\n\";\n    std::cout &lt;&lt; \"    return 0;\\n}\\n\";\n    return 0;\n}\n",
            "*",
            "int i = 0;\n\nint *ip01 = &amp; i;\n\nint **ip02 = &amp; ip01;\n\nint ***ip03 = &amp; ip02;\n\nint ****ip04 = &amp; ip03;\n\nint *****ip05 = &amp; ip04;\n\nint ******ip06 = &amp; ip05;\n\nint *******ip07 = &amp; ip06;\n\nint ********ip08 = &amp; ip07;\n\nint *********ip09 = &amp; ip08;\n\nint **********ip10 = &amp; ip09;\n\nint ***********ip11 = &amp; ip10;\n\nint ************ip12 = &amp; ip11;\n\n************ip12 = 1; /* i = 1 */\n",
            "#include &lt;cstdio&gt;\n\ntypedef void (*FuncType)();\n\nstatic void Print() { std::printf(\"%s\", \"Hello, World!\\n\"); }\n\nint main() {\n  FuncType const ft = &amp;Print;\n  ft();\n  (*ft)();\n  (**ft)();\n  /* ... */\n}\n",
            "int a = 10;\nint *p = &amp;a;\n\nint **q = &amp;p;\n\nq\np\na\n int **************************************************************************z;\n",
            "typedef int *type0;\ntypedef type0 *type1;\ntypedef type1 *type2; /* etc */\n",
            "4 MB / 4 b = 1024\nint *ptr = new int;\ninfinity / 2 = infinity",
            "#include &lt;iostream&gt;\n\nconst int CBlockSize = 1048576;\n\nint main() \n{\n    int number = 0;\n    int** ptr = new int*[CBlockSize];\n\n    ptr[0] = &amp;number;\n\n    for (int i = 1; i &lt; CBlockSize; ++i)\n        ptr[i] = reinterpret_cast&lt;int *&gt; (&amp;ptr[i - 1]);\n\n    for (int i = CBlockSize-1; i &gt;= 0; --i)\n        std::cout &lt;&lt; i &lt;&lt; \" \" &lt;&lt; (int)ptr[i] &lt;&lt; \"-&gt;\" &lt;&lt; *ptr[i] &lt;&lt; std::endl;\n\n    return 0;\n}\n\nnumber\n92K"
        ]
    },
    {
        "question_id": 2844,
        "question_code": "#include &lt;stdio.h&gt;\nint main() {\n    unsigned long long int num = 285212672; //FYI: fits in 29 bits\n    int normalInt = 5;\n    printf(\"My number is %d bytes wide and its value is %ul. A normal number is %d.\\n\", sizeof(num), num, normalInt);\n    return 0;\n}\n\nMy number is 8 bytes wide and its value is 285212672l. A normal number is 0.\n\nunsigned long long int\nprintf()\nunsigned long long int",
        "answer_code_snippets": [
            "printf(\"%llu\", 285212672);\n",
            "%d\nint\n%u\nunsigned int\n%ld\nlong int\nlong\n%lu\nunsigned long int\nlong unsigned int\nunsigned long\n%lld\nlong long int\nlong long\n%llu\nunsigned long long int\nunsigned long long",
            "int32_t\nint64_t\nuint64_t\n#include &lt;inttypes.h&gt;\n\nuint64_t x;\nuint32_t y;\n\nprintf(&quot;x: %&quot;PRIu64&quot;, y: %&quot;PRIu32&quot;\\n&quot;, x, y);\n\nlong\nunsigned long long",
            "__int64 a;\ntime_t b;\n...\nfprintf(outFile,\"%I64d,%I64d\\n\",a,b);    //I is capital i\n",
            "#include &lt;stdio.h&gt;\n#include &lt;inttypes.h&gt;\n\nint main() {\n    unsigned long long int num = 285212672; //FYI: fits in 29 bits\n    int normalInt = 5;\n    /* NOTE: PRIu64 is a preprocessor macro and thus should go outside the quoted string. */\n    printf(\"My number is %d bytes wide and its value is %\" PRIu64 \". A normal number is %d.\\n\", sizeof(num), num, normalInt);\n    return 0;\n}\n\nMy number is 8 bytes wide and its value is 285212672. A normal number is 5.\n",
            "%llu\n%I64u",
            "unsigned long long int\nprintf\n&quot;ll&quot;\no,u,x,X\nunsigned long long num = 285212672;\nprintf(&quot;Base 10: %llu\\n&quot;, num);\nnum += 0xFFF; // For more interesting hex/octal output.\nprintf(&quot;Base 16: %llX\\n&quot;, num); // Use uppercase A-F\nprintf(&quot;Base 16: %llx\\n&quot;, num); // Use lowercase a-f\nprintf(&quot;Base  8: %llo\\n&quot;, num);\nputs(&quot;or 0x,0X prefix&quot;);\nprintf(&quot;Base 16: %#llX %#llX\\n&quot;, num, 0ull); // When non-zero, print leading 0X\nprintf(&quot;Base 16: %#llx %#llx\\n&quot;, num, 0ull); // When non-zero, print leading 0x\nprintf(&quot;Base 16: 0x%llX\\n&quot;, num); // My hex fave: lower case prefix, with A-F\n\nBase 10: 285212672\nBase 16: 11000FFF\nBase 16: 11000fff\nBase  8: 2100007777\nor 0x,0X prefix\nBase 16: 0X11000FFF 0\nBase 16: 0x11000fff 0\nBase 16: 0x11000FFF\n",
            "lltoa()\n#include &lt;stdlib.h&gt; /* lltoa() */\n// ...\nchar dummy[255];\nprintf(&quot;Over 4 bytes: %s\\n&quot;, lltoa(5555555555, dummy, 10));\nprintf(&quot;Another one: %s\\n&quot;, lltoa(15555555555, dummy, 10));\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt; /* lltoa() */\n\nint main() {\n    unsigned long long int num = 285212672; // fits in 29 bits\n    char dummy[255];\n    int normalInt = 5;\n    printf(&quot;My number is %d bytes wide and its value is %s. &quot;\n        &quot;A normal number is %d.\\n&quot;, \n        sizeof(num), lltoa(num, dummy, 10), normalInt);\n    return 0;\n}\n\n%lld\n_ui64toa()\nlltoa()",
            "unsigned long long\nuintmax_t\nstdint.h\nuintmax_t\nintmax_t\nuintmax_t\nuintmax_t\n%ju\nintmax_t\n%jd\nuintmax_t\nuintmax_t\n#include &lt;stdio.h&gt;\n#include &lt;stdint.h&gt;\n\nint main(void) {\n    unsigned long long num = 285212672;\n    printf(&quot;%ju\\n&quot;, (uintmax_t)num);\n\n    return 0;\n}\n",
            "main.c:30:3: warning: unknown conversion type character 'l' in format [-Wformat=]\nprintf(\"%llu\\n\", k);\n-std=c99",
            "L\nll\nq\nll",
            "int normalInt = 5; \nunsigned long long int num=285212672;\nprintf(\n    \"My number is %d bytes wide and its value is %ul. \n    A normal number is %d \\n\", \n    sizeof(num), \n    num, \n    normalInt);\n\nint normalInt = 5; \nunsigned __int64 num=285212672;\nprintf(\n    \"My number is %d bytes wide and its value is %I64u. \n    A normal number is %d\", \n    sizeof(num),\n    num, normalInt);\n",
            "printf(\"64bit: %llp\", 0xffffffffffffffff);\n\n64bit: FFFFFFFFFFFFFFFF\n"
        ]
    },
    {
        "question_id": 238603,
        "question_code": "malloc()\nmalloc(10000*sizeof(char));",
        "answer_code_snippets": [
            "fseek(fp, 0L, SEEK_END);\nsz = ftell(fp);\n\nfseek(fp, 0L, SEEK_SET);\n\nrewind(fp);\n",
            "fseek(f, 0, SEEK_END); // seek to end of file\nsize = ftell(f); // get current file pointer\nfseek(f, 0, SEEK_SET); // seek back to beginning of file\n// proceed with allocating memory and reading the file\n\nstat\nfstat\n#include &lt;sys/stat.h&gt;\nstruct stat st;\nstat(filename, &amp;st);\nsize = st.st_size;\n",
            "fstat()\n#include &lt;sys/types.h&gt;\n#include &lt;sys/stat.h&gt;\n#include &lt;unistd.h&gt;\n\n// fd = fileno(f); //if you have a stream (e.g. from fopen), not a file descriptor.\nstruct stat buf;\nfstat(fd, &amp;buf);\noff_t size = buf.st_size;\n",
            "fsize\nint fsize(FILE *fp){\n    int prev=ftell(fp);\n    fseek(fp, 0L, SEEK_END);\n    int sz=ftell(fp);\n    fseek(fp,prev,SEEK_SET); //go back to where we were\n    return sz;\n}\n\n/dev/null",
            "#include &lt;fcntl.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;sys/stat.h&gt;\n\nvoid\nfseek_filesize(const char *filename)\n{\n    FILE *fp = NULL;\n    long off;\n\n    fp = fopen(filename, &quot;r&quot;);\n    if (fp == NULL)\n    {\n        printf(&quot;failed to fopen %s\\n&quot;, filename);\n        exit(EXIT_FAILURE);\n    }\n\n    if (fseek(fp, 0, SEEK_END) == -1)\n    {\n        printf(&quot;failed to fseek %s\\n&quot;, filename);\n        exit(EXIT_FAILURE);\n    }\n\n    off = ftell(fp);\n    if (off == -1)\n    {\n        printf(&quot;failed to ftell %s\\n&quot;, filename);\n        exit(EXIT_FAILURE);\n    }\n\n    printf(&quot;[*] fseek_filesize - file: %s, size: %ld\\n&quot;, filename, off);\n\n    if (fclose(fp) != 0)\n    {\n        printf(&quot;failed to fclose %s\\n&quot;, filename);\n        exit(EXIT_FAILURE);\n    }\n}\n\nvoid\nfstat_filesize(const char *filename)\n{\n    int fd;\n    struct stat statbuf;\n\n    fd = open(filename, O_RDONLY, S_IRUSR | S_IRGRP);\n    if (fd == -1)\n    {\n        printf(&quot;failed to open %s\\n&quot;, filename);\n        exit(EXIT_FAILURE);\n    }\n\n    if (fstat(fd, &amp;statbuf) == -1)\n    {\n        printf(&quot;failed to fstat %s\\n&quot;, filename);\n        exit(EXIT_FAILURE);\n    }\n\n    printf(&quot;[*] fstat_filesize - file: %s, size: %lld\\n&quot;, filename, statbuf.st_size);\n\n    if (close(fd) == -1)\n    {\n        printf(&quot;failed to fclose %s\\n&quot;, filename);\n        exit(EXIT_FAILURE);\n    }\n}\n\nvoid\nstat_filesize(const char *filename)\n{\n    struct stat statbuf;\n\n    if (stat(filename, &amp;statbuf) == -1)\n    {\n        printf(&quot;failed to stat %s\\n&quot;, filename);\n        exit(EXIT_FAILURE);\n    }\n\n    printf(&quot;[*] stat_filesize - file: %s, size: %lld\\n&quot;, filename, statbuf.st_size);\n\n}\n\nvoid\nseek_filesize(const char *filename)\n{\n    int fd;\n    off_t off;\n\n    if (filename == NULL)\n    {\n        printf(&quot;invalid filename\\n&quot;);\n        exit(EXIT_FAILURE);\n    }\n\n    fd = open(filename, O_RDONLY, S_IRUSR | S_IRGRP);\n    if (fd == -1)\n    {\n        printf(&quot;failed to open %s\\n&quot;, filename);\n        exit(EXIT_FAILURE);\n    }\n\n    off = lseek(fd, 0, SEEK_END);\n    if (off == -1)\n    {\n        printf(&quot;failed to lseek %s\\n&quot;, filename);\n        exit(EXIT_FAILURE);\n    }\n\n    printf(&quot;[*] seek_filesize - file: %s, size: %lld\\n&quot;, filename, (long long) off);\n\n    if (close(fd) == -1)\n    {\n        printf(&quot;failed to close %s\\n&quot;, filename);\n        exit(EXIT_FAILURE);\n    }\n}\n\nint\nmain(int argc, const char *argv[])\n{\n    int i;\n\n    if (argc &lt; 2)\n    {\n        printf(&quot;%s &lt;file1&gt; &lt;file2&gt;...\\n&quot;, argv[0]);\n        exit(0);\n    }\n\n    for(i = 1; i &lt; argc; i++)\n    {\n        seek_filesize(argv[i]);\n        stat_filesize(argv[i]);\n        fstat_filesize(argv[i]);\n        fseek_filesize(argv[i]);\n    }\n\n    return 0;\n}\n",
            "#define CHUNK 1024\n\n/* Read the contents of a file into a buffer.  Return the size of the file \n * and set buf to point to a buffer allocated with malloc that contains  \n * the file contents.\n */\nint read_file(FILE *fp, char **buf) \n{\n  int n, np;\n  char *b, *b2;\n\n  n = CHUNK;\n  np = n;\n  b = malloc(sizeof(char)*n);\n  while ((r = fread(b, sizeof(char), CHUNK, fp)) &gt; 0) {\n    n += r;\n    if (np - n &lt; CHUNK) { \n      np *= 2;                      // buffer is too small, the next read could overflow!\n      b2 = malloc(np*sizeof(char));\n      memcpy(b2, b, n * sizeof(char));\n      free(b);\n      b = b2;\n    }\n  }\n  *buf = b;\n  return n;\n}\n"
        ]
    },
    {
        "question_id": 3209909,
        "question_code": "unsigned long\nunsigned_foo\nunsigned long\nprintf(\"%lu\\n\", unsigned_foo)\nprintf(\"%du\\n\", unsigned_foo)\nprintf(\"%ud\\n\", unsigned_foo)\nprintf(\"%ll\\n\", unsigned_foo)\nprintf(\"%ld\\n\", unsigned_foo)\nprintf(\"%dl\\n\", unsigned_foo)\n-123123123\nunsigned long",
        "answer_code_snippets": [
            "%lu\nunsigned long",
            "%d\n%ld\n%lld\n%llu",
            "%lu\n%llu",
            "%ld\n%lu\n%lu\n%lx\n%lX\n%lo\n%\nl",
            "%lu",
            "%lu",
            "int main()\n{\n    unsigned long long d;\n    scanf(\"%llu\",&amp;d);\n    printf(\"%llu\",d);\n    getch();\n}\n"
        ]
    },
    {
        "question_id": 346536,
        "question_code": "struct\nunion\nstruct\nunion",
        "answer_code_snippets": [
            "union foo {\n  int a;   // can't use both a and b at once\n  char b;\n} foo;\n\nstruct bar {\n  int a;   // can use both a and b simultaneously\n  char b;\n} bar;\n\nunion foo x;\nx.a = 3; // OK\nx.b = 'c'; // NO! this affects the value of x.a!\n\nstruct bar y;\ny.a = 3; // OK\ny.b = 'c'; // OK\n\nunion foo x;\nx.a = 3;\nx.b = 'c';\nprintf(\"%i, %i\\n\", x.a, x.b);\n\n99, 99\n\nunion foo x;\nx.a = 387439;\nx.b = 'c';\nprintf(\"%i, %i\\n\", x.a, x.b);\n\n387427, 99\n\nunion foo x;\nx.a = 0xDEADBEEF;\nx.b = 0x22;\nprintf(\"%x, %x\\n\", x.a, x.b);\n\ndeadbe22, 22\n",
            "struct foobarbazquux_t {\n    int foo;\n    long bar;\n    double baz; \n    long double quux;\n}\n\n(sizeof(int)+sizeof(long)+sizeof(double)+sizeof(long double))\nunion foobarbazquux_u {\n    int foo;\n    long bar;\n    double baz; \n    long double quux;\n}\n\nsizeof(union foobarbazquux_u) ≥ max((sizeof(int),sizeof(long),sizeof(double),sizeof(long double))",
            "struct packetheader {\n   int sourceaddress;\n   int destaddress;\n   int messagetype;\n   union request {\n       char fourcc[4];\n       int requestnumber;\n   };\n};\n",
            "union\nstruct\nunion\nstruct\nint\nunion test {\n    int a;\n    long b;\n}; \n\nsizeof\nstruct test {\n    int a;\n    double b;\n} * some_test_pointer;\n\nint*\ndouble*\ntest\nint*\na\nunion a {\n    int a;\n    double b;\n};\n\nunion a * v = (union a*)some_int_pointer;\n*some_int_pointer = 5;\nv-&gt;a = 10;\nreturn *some_int_pointer;    \n\nv-&gt;a = 10;\n*some_int_pointer\n10\n5",
            "union\nunion\nfloat\nunion\nstruct\nfloat\nfloat\nfloat\nstruct\nunion\n#include &lt;stdio.h&gt;                                                                                                                                       \n\nunion foo {\n    struct float_guts {\n        unsigned int fraction : 23;\n        unsigned int exponent : 8;\n        unsigned int sign     : 1;\n    } fg;\n    float f;\n};\n\nvoid print_float(float f) {\n    union foo ff;\n    ff.f = f;\n    printf(\"%f: %d 0x%X 0x%X\\n\", f, ff.fg.sign, ff.fg.exponent, ff.fg.fraction);\n\n}\n\nint main(){\n    print_float(0.15625);\n    return 0;\n}\n\nunion",
            "union SIGSELECT\n{\n  SIGNAL_1 signal1;\n  SIGNAL_2 signal2;\n  .....\n};\n",
            "struct",
            "struct MAIN_STRUCT\n{\nUINT64 bufferaddr;   \nunion {\n    UINT32 data;\n    struct INNER_STRUCT{\n        UINT16 length;  \n        UINT8 cso;  \n        UINT8 cmd;  \n           } flags;\n     } data1;\n};\n",
            "struct s_tag\n{\n   int a; \n   long int b;\n} x;\n\nunion u_tag\n{\n   int a; \n   long int b;\n} y;\n\n#include&lt;stdio.h&gt;\nstruct s_tag\n{\n  int a;\n  long int b;\n} x;\nunion u_tag\n{\n     int a;\n     long int b;\n} y;\nint main()\n{\n    printf(\"Memory allocation for structure = %d\", sizeof(x));\n    printf(\"\\nMemory allocation for union = %d\", sizeof(y));\n    return 0;\n}\n",
            "struct emp\n{\n    char x; //1 byte\n    float y; //4 byte\n} e;\n\nunion emp\n{\n    char x; //1 byte\n    float y; //4 byte\n} e;\n",
            "#include&lt;stdio.h&gt;\nunion pw {\nshort int i;\nchar ch[2];\n};\nint putw(short int num, FILE *fp);\nint main (void)\n{\nFILE *fp;\nfp fopen(\"test.tmp\", \"wb \");\nputw(1000, fp); /* write the value 1000 as an integer*/\nfclose(fp);\nreturn 0;\n}\nint putw(short int num, FILE *fp)\n{\npw word;\nword.i = num;\nputc(word.c[0] , fp);\nreturn putc(word.c[1] , fp);\n}    \n",
            "int main(int argc, char **argv) {\n    union {\n        short   s;\n        char    c[sizeof(short)];\n    } un;\n\n    un.s = 0x0102;\n\n    if (sizeof(short) == 2) {\n        if (un.c[0] == 1 &amp;&amp; un.c[1] == 2)\n            printf(\"big-endian\\n\");\n        else if (un.c[0] == 2 &amp;&amp; un.c[1] == 1)\n            printf(\"little-endian\\n\");\n        else\n            printf(\"unknown\\n\");\n    } else\n        printf(\"sizeof(short) = %d\\n\", sizeof(short));\n\n    exit(0);\n}\n// Program from Unix Network Programming Vol. 1 by Stevens.\n",
            "struct car{\n    char model[];\n    int mileage;\n    int price;\n    char fuel_type[];\n};\n\nunion verification_details{\n    char account_number[10];\n    char PAN[10];\n    char voter_id[10];\n};\n",
            "struct Human\n{\n    char Name[255];\n    int age;\n    int salary;\n}\n\nunion Building\n{\n    int age;\n    char name[255];\n    int capacity;\n}\n",
            "union\nunion\nunion\nunion data\n{\n    uint32_t packet;\n    uint8_t  packetbyte[4];\n} txdata;\n\nfor\ntxdata.packetbyte\ntxdata.packet\ntxdata\ntxdata.packet\ntxdata.packet = 0"
        ]
    },
    {
        "question_id": 233328,
        "question_code": "",
        "answer_code_snippets": [
            "set print elements 0\n\nset print elements \nnumber-of-elements\nset print elements",
            "call (void)puts(your_string)",
            "printf\n(gdb) printf \"%s\\n\", string\n",
            "x/300s your_string",
            "(gdb) p (char[10]) *($ebx)\n$87 =   \"asdfasdfe\\n\"\n\n(gdb) p/x (char[10]) *($ebx)\n$90 =   {0x61,\n  0x73,\n  0x64,\n  0x66,\n  0x61,\n  0x73,\n  0x64,\n  0x66,\n  0x65,\n  0xa}\n",
            "set elements ...\nset string-elements ...\ndefine pstr\n  ptype $arg0._M_dataplus._M_p\n  printf \"[%d] = %s\\n\", $arg0._M_string_length, $arg0._M_dataplus._M_p\nend\n\ndefine pcstr\n  ptype $arg0\n  printf \"[%d] = %s\\n\", strlen($arg0), $arg0\nend\n"
        ]
    },
    {
        "question_id": 162941,
        "question_code": "",
        "answer_code_snippets": [
            "sizeof\nchar* a = \"Hello\";\nchar a[] = \"Hello\";\n\nprintf(\"Second char is: %c\", a[1]);\n\nprintf(\"Second char is: %c\", *(a+1));\n\nprintf(\"Second char is: %s\", (a+1)); /* WRONG */\n\nchar* a = \"Hello\";\nint b = 120;\nprintf(\"Second char is: %s\", b);\n\nchar* x;\n/* Allocate 6 bytes of memory for me and point x to the first of them. */\nx = (char*) malloc(6);\nx[0] = 'H';\nx[1] = 'e';\nx[2] = 'l';\nx[3] = 'l';\nx[4] = 'o';\nx[5] = '\\0';\nprintf(\"String \\\"%s\\\" at address: %d\\n\", x, x);\n/* Delete the allocation (reservation) of the memory. */\n/* The char pointer x is still pointing to this address in memory though! */\nfree(x);\n/* Same as malloc but here the allocated space is filled with null characters!*/\nx = (char *) calloc(6, sizeof(x));\nx[0] = 'H';\nx[1] = 'e';\nx[2] = 'l';\nx[3] = 'l';\nx[4] = 'o';\nx[5] = '\\0';\nprintf(\"String \\\"%s\\\" at address: %d\\n\", x, x);\n/* And delete the allocation again... */\nfree(x);\n/* We can set the size at declaration time as well */\nchar xx[6];\nxx[0] = 'H';\nxx[1] = 'e';\nxx[2] = 'l';\nxx[3] = 'l';\nxx[4] = 'o';\nxx[5] = '\\0';\nprintf(\"String \\\"%s\\\" at address: %d\\n\", xx, xx);\n",
            "public void doSomething()\n{\n    int i = 10;\n    doSomethingElse(i);  // passes i by references since doSomethingElse() receives it\n                         // by reference, but the syntax makes it appear as if i is passed\n                         // by value\n}\n\npublic void doSomethingElse(int&amp; i)  // receives i as a reference\n{\n    cout &lt;&lt; i &lt;&lt; endl;\n}\n\npublic void doSomething()\n{\n    int i = 10;\n    doSomethingElse(&amp;i);\n}\n\npublic void doSomethingElse(int* i)\n{\n    cout &lt;&lt; *i &lt;&lt; endl;\n}\n",
            "char hello[] = \"hello\";\n\nchar *p = hello;\n\nwhile (*p)\n{\n    *p += 1; // increase the character by one\n\n    p += 1; // move to the next spot\n}\n\nprintf(hello);\n\nifmmp\n",
            "MyType a; //let's ignore what MyType actually is right now.\na = modify(a); \n\nMyType *p = NULL; //empty pointer\nif(p)\n{\n    //we never reach here, because the pointer points to nothing\n}\n//now, let's allocate some memory\np = new MyType[50000];\nif(p) //if the memory was allocated, this test will pass\n{\n    //we can do something with our allocated array\n    for(size_t i=0; i!=50000; i++)\n    {\n        MyType &amp;v = *(p+i); //get a reference to the ith object\n        //do something with it\n        //...\n    }\n    delete[] p; //we're done. de-allocate the memory\n}\n",
            "unsigned char *pVideoMemory = (unsigned char *)0xA0000000;\n"
        ]
    },
    {
        "question_id": 5727,
        "question_code": "",
        "answer_code_snippets": [
            "type\n    THouse = class\n    private\n        FName : array[0..9] of Char;\n    public\n        constructor Create(name: PChar);\n    end;\n\nTHouse.Create('My house');\n\nvar\n    h: THouse;\nbegin\n    h := THouse.Create('My house');\n    ...\n\nvar\n    h1, h2: THouse;\nbegin\n    h1 := THouse.Create('My house');\n    h2 := h1; // copies the address, not the house\n    ...\n\nvar\n    h: THouse;\nbegin\n    h := THouse.Create('My house');\n    ...\n    h.Free;\n    h := nil;\n\nvar\n    h: THouse;\nbegin\n    h := THouse.Create('My house');\n    ...\n    h.Free;\n    ... // forgot to clear h here\n    h.OpenFrontDoor; // will most likely fail\n\nh\n.Free\nvar\n    h: THouse;\nbegin\n    h := THouse.Create('My house');\n    h := THouse.Create('My house'); // uh-oh, what happened to our first house?\n    ...\n    h.Free;\n    h := nil;\n\nh\nprocedure OpenTheFrontDoorOfANewHouse;\nvar\n    h: THouse;\nbegin\n    h := THouse.Create('My house');\n    h.OpenFrontDoor;\n    // uh-oh, no .Free here, where does the address go?\nend;\n\nvar\n    h1, h2: THouse;\nbegin\n    h1 := THouse.Create('My house');\n    h2 := h1; // copies the address, not the house\n    ...\n    h1.Free;\n    h1 := nil;\n    h2.OpenFrontDoor; // uh-oh, what happened to our house?\n\nh1\nh1\nh2\nvar\n    h1, h2: THouse;\nbegin\n    h1 := THouse.Create('My house');\n    h2 := THouse.Create('My other house somewhere');\n                         ^-----------------------^\n                          longer than 10 characters\n                         0123456789 &lt;-- 10 characters\n\nvar\n    h1, h2: THouse;\nbegin\n    h1 := THouse.Create('Home');\n    h2 := THouse.Create('Cabin');\n    h1.NextHouse := h2;\n\nNextHouse\nvar\n    h1, h2: THouse;\n    h: THouse;\nbegin\n    h1 := THouse.Create('Home');\n    h2 := THouse.Create('Cabin');\n    h1.NextHouse := h2;\n    ...\n    h := h1;\n    while h &lt;&gt; nil do\n    begin\n        h.LockAllDoors;\n        h.CloseAllWindows;\n        h := h.NextHouse;\n    end;\n",
            "int john;\nint *sally = &amp;john;\nint *bill = sally;\nint sam;\nbill = &amp;sam;",
            "struct {\nchar a;\nchar b;\nchar c;\nchar d;\n} mystruct;\nmystruct.a = 'r';\nmystruct.b = 's';\nmystruct.c = 't';\nmystruct.d = 'u';\n\nchar* my_pointer;\nmy_pointer = &amp;mystruct.b;\ncout &lt;&lt; 'Start: my_pointer = ' &lt;&lt; *my_pointer &lt;&lt; endl;\nmy_pointer++;\ncout &lt;&lt; 'After: my_pointer = ' &lt;&lt; *my_pointer &lt;&lt; endl;\nmy_pointer = &amp;mystruct.a;\ncout &lt;&lt; 'Then: my_pointer = ' &lt;&lt; *my_pointer &lt;&lt; endl;\nmy_pointer = my_pointer + 3;\ncout &lt;&lt; 'End: my_pointer = ' &lt;&lt; *my_pointer &lt;&lt; endl;\n\n// Same example as above, except in C:\nstruct {\n    char a;\n    char b;\n    char c;\n    char d;\n} mystruct;\n\nmystruct.a = 'r';\nmystruct.b = 's';\nmystruct.c = 't';\nmystruct.d = 'u';\n\nchar* my_pointer;\nmy_pointer = &amp;mystruct.b;\n\nprintf(\"Start: my_pointer = %c\\n\", *my_pointer);\nmy_pointer++;\nprintf(\"After: my_pointer = %c\\n\", *my_pointer);\nmy_pointer = &amp;mystruct.a;\nprintf(\"Then: my_pointer = %c\\n\", *my_pointer);\nmy_pointer = my_pointer + 3;\nprintf(\"End: my_pointer = %c\\n\", *my_pointer);\n\nStart: my_pointer = s\nAfter: my_pointer = t\nThen: my_pointer = r\nEnd: my_pointer = u\n",
            "int puts(const char *s);\n\nconst.\nputs()\nputs(strA);",
            "widget-&gt;wazzle.fizzle = fazzle.foozle-&gt;wazzle;\n",
            "-------------------\n|     |     |     |\n|  1  |  2  |  3  |\n|     |     |     |\n\nparking_lot[3] = {0}\n   1     2     3\n-------------------\n| o=o | o=o | o=o |\n| |B| | |R| | |G| |\n| o-o | o-o | o-o |\n\nint\nblue\nred\ngreen\nenum\nint *finger = parking_lot\nint **finger_two = &amp;finger\n   1     2     3\n-------------------\n| o=o |     | o=o |\n| |B| |     | |G| |\n| o-o |     | o-o |\n\n   1     2     3\n-------------------\n| o=o | o=o | o=o |\n| |B| | |O| | |G| |\n| o-o | o-o | o-o |\n\nfinger+1\n*(finger+1)",
            "int doIt(char *buffer )\n//*buffer is a pointer to the buffer\n\ndoIt(mybuffer)\ndoIt(*myBuffer)\ndoIt(&amp;mybuffer)\ndoIt(mybuffer)\ndoIt(*mybuffer)\ndoIt(&amp;mybuffer)\ndoIt(&amp;&amp;mybuffer)\ndoIt(&amp;&amp;&amp;mybuffer)",
            "int *mypointer;\n\n*\nint* mypointer;\n",
            "unsigned char RAM[10] = { 10, 14, 4, 3, 2, 1, 20, 19, 50, 9 };\n\nunsigned char index = 2\nRAM[RAM[index]]",
            "int* my_int_pointer;\n"
        ]
    }
]